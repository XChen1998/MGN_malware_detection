@rrs_ssl = global i32 0, align 4
@sslprotocols = global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)], align 16
@sourceport = global i32 0, align 4
@cport = global i32 31337, align 4
@lport = global i32 31337, align 4
@rrs_listen = global i32 0, align 4
@rrs_daemon = global i32 0, align 4
@rrs_sslverify = global i32 1, align 4
@silent = global i32 0, align 4
@timeout = global i32 0, align 4
@reconnect = global i32 0, align 4
@infinite_reconnect = global i32 0, align 4
@monitor = global i32 0, align 4
@set_effective_uid = global i32 0, align 4
@keyfile = global i8* null, align 8
@cipher = global i8* null, align 8
@cafile = global i8* null, align 8
@crlfile = global i8* null, align 8
@remote_command = global i8* null, align 8
@twofishkey = global i8* null, align 8
@xorkey = global i8* null, align 8
@wsize = global %struct.winsize zeroinitializer, align 2
@On = global i32 1, align 4
@Off = global i32 0, align 4
@we_got_a_crl = global i32 0, align 4
@xorcrypt_write.xorcrypt_internal_counter = internal global i32 0, align 4
@xorcrypt_key = internal global i8* null, align 8
@xorcrypt_key_length = internal global i32 0, align 4
@xorcrypt_read.xorcrypt_internal_counter = internal global i32 0, align 4
@generate_xorcrypt_key.key = internal global [145 x i8] zeroinitializer, align 16
@get_revision.revision = internal global [16 x i8] zeroinitializer, align 16
@convert2dotted_hex.buf = internal global [1024 x i8] zeroinitializer, align 16
@child_is_dead = common global i32 0, align 4
@stderr = external global %struct._IO_FILE*, align 8
@connecting_pty_shell.sopt = internal global i32 0, align 4
@sslctx = common global %struct.ssl_ctx_st* null, align 8
@ssl = common global %struct.ssl_st* null, align 8
@peer_cert = common global %struct.x509_st* null, align 8
@usingtty = common global i32 0, align 4
@oldttyattr = common global %struct.termios zeroinitializer, align 4
@got_winch = common global i32 0, align 4
@listener.sopt = internal global i32 1, align 4
@newttyattr = common global %struct.termios zeroinitializer, align 4
@listener_clisd = common global i32 0, align 4
@gbuf = common global [1500 x i8] zeroinitializer, align 16
@banner = internal global [84 x i8] c"rrs %s - Reverse Remote Shell\0ACopyright (C) 2004 Michel Blomgren <michel@cycom.se>\0A\00", align 16
@rcsid = internal global [52 x i8] c"$Id: rrs.c,v 1.70 2004/05/30 00:32:03 shadow Exp $\0A\00", align 16
@helptext = internal global [9662 x i8] c"rrs is distributed under the MIT License, type \22rrs -L\22 for details.\0A\0Aconnect: rrs [options] hostname port\0A listen: rrs [options] -l [-p port]\0A\0Aoptions:\0A   -h, --help          This help.\0A   -l, --listen        Listen for incoming rrs connection, default port is\0A                       31337, change with -p.\0A   -p, --port n        For -l (listen), bind to port n instead of 31337.\0A   -b, --source-port n For the connector, bind to source port n instead of\0A                       letting the kernel choose a source port. Good if you\0A                       bump into some strange fw config that only allows\0A                       specific tcp source/dest port pairs through (then use\0A                       -b and laugh at their lousy sec).\0A   -r, --reconnect n   Reconnect until we've got a connection, pause for n\0A                       seconds between connection attempts. --timeout is\0A                       relevant here, since it'll control how long connect()\0A                       may take until timing out. The kernel max connect()\0A                       timeout can never be increased though.\0A   -R, --infinite-reconnect n\0A                       Same as --reconnect, except it won't exit after a\0A                       successful connection has been terminated. It will\0A                       loop continuously, until killed.\0A   -t, --timeout n     Timeout in seconds, for both -l and connect().\0A   -D, --daemon        Tell the connector to fork into a background process\0A                       before attempting to connect. --daemon automatically\0A                       enables --quiet.\0A   -k, --twofishkey phrase\0A                       Tell rrs to use the built-in Twofish encryption for\0A                       communication. This implementation isn't all that\0A                       efficient, something you will experience when typing,\0A                       but not when receiving/sending a steady stream. phrase\0A                       is either a password or phrase that you specify on the\0A                       command line, or if you specify \22-k-\22 rrs will read\0A                       one from stdin. IMPORTANT! With a symmetric cipher\0A                       both the listener and the connector has to use the\0A                       same pass phrase in order to communicate. If you use\0A                       the -k option, you can not use -s (OpenSSL) or -x\0A                       (xorcrypt).\0A   -x, --xorkey phrase\0A                       Tell rrs to use the built-in per-byte XOR (very simple\0A                       symmetric) encryption for communication. This cipher\0A                       is quite weak and should not be considered decent\0A                       encryption. It's useful for effectively evading a NIDS\0A                       and general interception. As with -k above, phrase is\0A                       either a password that you specify on the command line\0A                       or from stdin using \22-x-\22. Since this XOR cipher\0A                       loops the key for the data received/transmitted, the\0A                       engine will be initialized with a 144 byte ascii hash\0A                       (SHA1+MD5+SHA1+MD5). The hash is generated by\0A                       calculating a SHA1+MD5 hash of the phrase, then the\0A                       phrase is reversed and hashed again (SHA1+MD5) to form\0A                       the entire key.\0A   -s, --ssl           OpenSSL encrypted communication instead of plain text.\0A                       rrs will use the TLSv1 protocol method by default, you\0A                       can change it with, e.g., --ssl=tlsv1 for instance, or\0A                       the -S option.\0A   -S, --ssl=method    Choose OpenSSL protocol (case doesn't matter):\0A                           -S SSLv2\0A                           -S SSLv3\0A                           -S TLSv1\0A                       If you use --ssl instead of -S, please remember to use\0A                       the equal sign, e.g., --ssl=sslv3.\0A   -P, --pem file      Specify private key and certificate (public key) file.\0A                       The file should begin with a PEM encoded private key\0A                       followed by a PEM encoded certificate. Both the\0A                       listener and the connector must provide a private key\0A                       and certificate since authentication of the listener\0A                       is the default behavior. If you specify -v0 on both\0A                       sides, only the listener (-l) needs a PEM file, not\0A                       the connector. The PEM file can contain several\0A                       certificates after each other that you trust. Whoever\0A                       has got the private key to those certificates will be\0A                       allowed to receive the connection by the connector (in\0A                       default -v1 mode). As a security precaution, the\0A                       receiver (listener) verifies the connector's\0A                       certificate by default, thus, both the listener and\0A                       the connector must exchange their public keys\0A                       (certificates), or trust a common CA (self-signed\0A                       certificate) who's signed each party's certificate.\0A   -C, --ca file       Optional. If you want to specify additional\0A                       certificates you trust, just append them to file, one\0A                       certificate after the other. By default, the\0A                       certificate(s) in the -P (--pem) file is/are trusted.\0A                       You may also use the -C option to add CRL (Certificate\0A                       Revocation List) files (only supported in OpenSSL\0A                       0.9.7 or later). The -C (--ca or --crl) can be\0A                       specified several times on the command line to include\0A                       an arbitrary amount of certificate files and/or CRL\0A                       files, e.g.: -C ca.crt -C subca.crt -C subca.crl\0A                       If no CRL file is added, no CRL checking is done.\0A   --crl file          Same as above. Option added for logical reasons.\0A   -c, --cipher cipher Define permitted SSL ciphers in a colon delimited\0A                       list, for example:\0A                           --cipher AES256-SHA:AES128-SHA\0A                           --cipher HIGH\0A                           --cipher HIGH:MEDIUM\0A                           --cipher \22DES-CBC3-SHA\22\0A                       DO NOT USE EXPORT OR NULL CIPHERS SUCH AS\0A                       \22EXPORT40\22, \22NULL\22, \22aNULL\22 or \22EXPORT\22.\0A                       Type \22openssl ciphers\22 or \22openssl ciphers HIGH\22\0A                       for a list of your OpenSSL suite's ciphers.\0A   -v, --verify n      Verify peer SSL certificate (authentication), this is\0A                       on by default. Replace n with:\0A                           0 = no verification/authentication\0A                           1 = verify both listener and connector (default)\0A                       Both the connector (the shell provider) and the\0A                       listener trust the certificate(s) in the --pem file and\0A                       in the --ca file (if --ca file was provided).\0A   -e, --exec command  Have the listener execute command on remote host.\0A                       Please note that after the command line has been\0A                       execute, it won't exit the shell (like ssh, e.g.).\0A                       You'll manually have to add \22 ; exit\22 to your\0A                       command to log out.\0A   -m, --monitor       Connector only. When serving a shell, echo/monitor\0A                       everything that the listener is doing. You can record\0A                       the session with a program called ttyrec found at\0A                       http://namazu.org/~satoru/ttyrec/.\0A   -0, --setuid        With this option, rrs will try to setuid(geteuid()) if\0A                       current UID and the effective UID isn't the same (if\0A                       rrs is chmodded 4755 and chowned root, e.g.). The\0A                       primary purpose of this option is to offer a root\0A                       shell from a regular account or if you want to receive\0A                       connections to privileged ports (<1024). You *must*\0A                       chmod rrs 4755 or 6755 and chown it to root if you\0A                       plan to offer root shells. The security issues\0A                       involved with chmodding rrs 4755 are quite obvious! ;)\0A   -q, --quiet         Be quiet, don't print anything.\0A   -L, --license       Print the MIT License and exit.\0A   -V, --version       Print program banner, copyright and RCS id then exit.\0AGenerate an OpenSSL private/public key file like this, e.g.:\0A$ openssl req -new -x509 -nodes -out rrs.crt -keyout rrs.pem -days 3650\0A$ cat rrs.crt >> rrs.pem\0A$ cat rrs.crt | mail -s \22My certificate\22 other@side.tld\0A\22-nodes\22 means not to encrypt the private key, you can remove it, either\0Away, make sure you keep the private key *private*! Another example:\0A$ openssl genrsa -aes256 -out rrs.pem 2048\0A$ openssl req -x509 -new -key rrs.pem -out rrs.crt -days 3650\0A$ cat rrs.crt >> rrs.pem\0AThe two examples above are PKC (public-key cryptography). For PKI (public-key\0Ainfrastructure) please read the README file and/or use the accompanied scripts\0Aunder the openssl_scripts directory.\0A\0ASECURITY WARNING: Avoid using plain-text communication as it can be\0Aintercepted, recorded and even modified. NIDS like Snort may (if correctly\0Aconfigured) trigger alerts when, e.g. you type \22id\22. Beware!\0A\0ASend bug reports to <michel@cycom.se>. Make sure you include the\0Aoutput of \22rrs -V\22 and describe how to reproduce the bug.\0A\00", align 16
@main.long_options = internal global [23 x %struct.option] [%struct.option { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0), i32 0, i32* null, i32 104 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.52, i32 0, i32 0), i32 0, i32* null, i32 108 }, %struct.option { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0), i32 1, i32* null, i32 112 }, %struct.option { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.54, i32 0, i32 0), i32 1, i32* null, i32 98 }, %struct.option { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i32 0, i32 0), i32 1, i32* null, i32 114 }, %struct.option { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.56, i32 0, i32 0), i32 1, i32* null, i32 82 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.57, i32 0, i32 0), i32 1, i32* null, i32 116 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.58, i32 0, i32 0), i32 0, i32* null, i32 68 }, %struct.option { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i32 0, i32* null, i32 113 }, %struct.option { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.60, i32 0, i32 0), i32 1, i32* null, i32 107 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.61, i32 0, i32 0), i32 1, i32* null, i32 120 }, %struct.option { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.62, i32 0, i32 0), i32 2, i32* null, i32 83 }, %struct.option { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.63, i32 0, i32 0), i32 1, i32* null, i32 80 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.64, i32 0, i32 0), i32 1, i32* null, i32 99 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.65, i32 0, i32 0), i32 1, i32* null, i32 118 }, %struct.option { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.66, i32 0, i32 0), i32 1, i32* null, i32 67 }, %struct.option { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i32 1, i32* null, i32 67 }, %struct.option { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.68, i32 0, i32 0), i32 1, i32* null, i32 101 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.69, i32 0, i32 0), i32 0, i32* null, i32 109 }, %struct.option { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.70, i32 0, i32 0), i32 0, i32* null, i32 48 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.71, i32 0, i32 0), i32 0, i32* null, i32 76 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.72, i32 0, i32 0), i32 0, i32* null, i32 86 }, %struct.option zeroinitializer], align 16
@stdout = external global %struct._IO_FILE*, align 8
@optarg = external global i8*, align 8
@optind = external global i32, align 4
@sslmethod = common global %struct.ssl_method_st* null, align 8
@sslstore = common global %struct.x509_store_st* null, align 8
@stdin = external global %struct._IO_FILE*, align 8
@alarm_triggered = common global i32 0, align 4
  %113 = load i32, i32* %di, align 4
  %114 = icmp slt i32 %113, 16
  %117 = load i32, i32* %xi, align 4
  %118 = sext i32 %117 to i64
  %119 = getelementptr inbounds i8, i8* getelementptr inbounds ([145 x i8], [145 x i8]* @generate_xorcrypt_key.key, i32 0, i32 0), i64 %118
  %120 = load i32, i32* %di, align 4
  %121 = mul nsw i32 %120, 2
  %122 = sext i32 %121 to i64
  %123 = getelementptr inbounds i8, i8* %119, i64 %122
  %124 = load i32, i32* %di, align 4
  %125 = sext i32 %124 to i64
  %126 = getelementptr inbounds [16 x i8], [16 x i8]* %digest, i64 0, i64 %125
  %127 = load i8, i8* %126, align 1
  %128 = zext i8 %127 to i32
  %129 = call i32 (i8*, i8*, ...) @sprintf(i8* %123, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.5, i32 0, i32 0), i32 %128) #9
  %132 = load i32, i32* %di, align 4
  %133 = add nsw i32 %132, 1
  store i32 %133, i32* %di, align 4
  %136 = load %struct.sha1_state*, %struct.sha1_state** %s, align 8
  call void @sha1_init(%struct.sha1_state* %136)
