##v##00.4.50
pagenumber=18
linenumber=2349
sellength=0
topline=0
EditHelpFileTitle.Text=Cheat Engine help
form2.STextForeHeadline.Color=16777215
form2.STextForeText.Color=0
form2.STextBackHeadline.Color=12845056
form2.STextBackText.Color=14876671
form2.STextHeadlineFont.Caption=Arial
form2.STextTextFont.Caption=Arial
form2.sTextFontSizeForHeadline.Caption=12
form2.sTextFontSizeForText.Caption=9
form2.CBoxBold.Checked=1
form2.CBoxNoForeColor.Checked=0
form2.CBoxLanguageID.ItemIndex=0
form2.CBoxCharSet.ItemIndex=0
form2.EditContents.Text=Contents
form2.EditFrontpageName.Text=Front page with index
form2.CBoxDontMakeFrontpage.Checked=1
form2.EditLogoPath.Text=
form2.EditFrontpageButtonCaption.Text=Front page
form2.RGroupHorizontalAlignment.ItemIndex=0
form2.RGroupVerticalAlignment.ItemIndex=0
form2.CBoxBlankLineBeforeEachHeading.Checked=1
form2.CBoxMakeFrontPageButton.Checked=0
form2.SpinEditFrontpageIDnumber.Value=9999
form2.CBoxAddAboutMenu.Checked=0
form2.EditAboutMenuCaption.Text=&About this help file...
form2.CBoxPopupPagesForAboutMenu.Tag=-1
form2.EditConstantNameFilePrefix.Text=pageConstants_
form2.EditConstantNameFileExt.Text=txt
form2.CBoxDontMakeHeadersKeywords.Checked=0
form2.CBoxDontMakeTargetsKeywords.Checked=0
copyToPath=
form5.sTextColor1=0
form5.sTextColor2=9743070
form5.sTextColor3=12386403
form5.sTextColor4=255
form5.sTextColor5=8421376
form5.sTextColor6=8650752
form5.sTextColor7=33280
form5.sTextColor8=32896
form5.sTextColor9=13026246
form5.sTextColor10=16711680
form5.sTextColor11=65280
form5.sTextColor12=8651007
form5.sTextColor13=16777215
form5.sTextColor14=16757429
form5.sTextColor15=9764863
form5.sTextColor16=8421504
form5.sTextComment1=
form5.sTextComment2=
form5.sTextComment3=
form5.sTextComment4=
form5.sTextComment5=
form5.sTextComment6=
form5.sTextComment7=
form5.sTextComment8=
form5.sTextComment9=
form5.sTextComment10=
form5.sTextComment11=
form5.sTextComment12=
form5.sTextComment13=
form5.sTextComment14=
form5.sTextComment15=
form5.sTextComment16=
NumOfPages=29
------------ end of project settings / page settings follow ------------
pageC.pages[0].ImageIndex=-1
pageTitle(0).Text=About this helpfile
getPageConstantLabel(0).Caption=
getPageContentHeaderLabel(0).Caption=
pageKeywords(0).Text=crap;poor;shit;lame;mistakes;errors;I am a lemming;Please kill me now
pageC.pages[1].ImageIndex=-1
pageTitle(1).Text=About Cheat Engine
getPageConstantLabel(1).Caption=
getPageContentHeaderLabel(1).Caption=
pageKeywords(1).Text=icq
pageC.pages[2].ImageIndex=-1
pageTitle(2).Text=Standard scan settings
getPageConstantLabel(2).Caption=
getPageContentHeaderLabel(2).Caption=
pageKeywords(2).Text=First scan;Next scan;scan types;value types;array to scan;read only;Undo scan;
pageC.pages[3].ImageIndex=-1
pageTitle(3).Text=Select Process
getPageConstantLabel(3).Caption=
getPageContentHeaderLabel(3).Caption=
pageKeywords(3).Text=
pageC.pages[4].ImageIndex=0
pageTitle(4).Text=Process
getPageConstantLabel(4).Caption=
getPageContentHeaderLabel(4).Caption=
pageKeywords(4).Text=
pageC.pages[5].ImageIndex=-1
pageTitle(5).Text=Found list
getPageConstantLabel(5).Caption=
getPageContentHeaderLabel(5).Caption=
pageKeywords(5).Text=max;results
pageC.pages[6].ImageIndex=-1
pageTitle(6).Text=Value types
getPageConstantLabel(6).Caption=
getPageContentHeaderLabel(6).Caption=
pageKeywords(6).Text=
pageC.pages[7].ImageIndex=0
pageTitle(7).Text=Signed value
getPageConstantLabel(7).Caption=
getPageContentHeaderLabel(7).Caption=
pageKeywords(7).Text=
pageC.pages[8].ImageIndex=-1
pageTitle(8).Text=Scan types
getPageConstantLabel(8).Caption=
getPageContentHeaderLabel(8).Caption=
pageKeywords(8).Text=Exact;Bigger than;Smaller than;Increased;Increased by;Decreased;Decreased by;Changed;Unchanged
pageC.pages[9].ImageIndex=-1
pageTitle(9).Text=Address list
getPageConstantLabel(9).Caption=
getPageContentHeaderLabel(9).Caption=
pageKeywords(9).Text=
pageC.pages[10].ImageIndex=-1
pageTitle(10).Text=Comments
getPageConstantLabel(10).Caption=
getPageContentHeaderLabel(10).Caption=
pageKeywords(10).Text=comments
pageC.pages[11].ImageIndex=-1
pageTitle(11).Text=Memory view
getPageConstantLabel(11).Caption=
getPageContentHeaderLabel(11).Caption=
pageKeywords(11).Text=assembler;debugger;codecave;thread;dll;inject
pageC.pages[12].ImageIndex=-1
pageTitle(12).Text=About the debugger
getPageConstantLabel(12).Caption=
getPageContentHeaderLabel(12).Caption=
pageKeywords(12).Text=
pageC.pages[13].ImageIndex=-1
pageTitle(13).Text=Settings Window
getPageConstantLabel(13).Caption=
getPageContentHeaderLabel(13).Caption=
pageKeywords(13).Text=
pageC.pages[14].ImageIndex=-1
pageTitle(14).Text=Network versions
getPageConstantLabel(14).Caption=
getPageContentHeaderLabel(14).Caption=
pageKeywords(14).Text=
pageC.pages[15].ImageIndex=-1
pageTitle(15).Text=Trainer
getPageConstantLabel(15).Caption=
getPageContentHeaderLabel(15).Caption=
pageKeywords(15).Text=designer
pageC.pages[16].ImageIndex=-1
pageTitle(16).Text=Speedhack
getPageConstantLabel(16).Caption=
getPageContentHeaderLabel(16).Caption=
pageKeywords(16).Text=speed;sleeptime
pageC.pages[17].ImageIndex=-1
pageTitle(17).Text=Auto Assemble
getPageConstantLabel(17).Caption=
getPageContentHeaderLabel(17).Caption=
pageKeywords(17).Text=ALLOC;LABEL;FULLACCESS
pageC.pages[18].ImageIndex=-1
pageTitle(18).Text=Script engine
getPageConstantLabel(18).Caption=
getPageContentHeaderLabel(18).Caption=
pageKeywords(18).Text=
pageC.pages[19].ImageIndex=-1
pageTitle(19).Text=Other stuff
getPageConstantLabel(19).Caption=
getPageContentHeaderLabel(19).Caption=
pageKeywords(19).Text=
pageC.pages[20].ImageIndex=-1
pageTitle(20).Text=Tutorials
getPageConstantLabel(20).Caption=
getPageContentHeaderLabel(20).Caption=
pageKeywords(20).Text=
pageC.pages[21].ImageIndex=-1
pageTitle(21).Text=Anti tab protected games
getPageConstantLabel(21).Caption=
getPageContentHeaderLabel(21).Caption=
pageKeywords(21).Text=anti tab;protected
pageC.pages[22].ImageIndex=-1
pageTitle(22).Text=What is the difference in bytetype
getPageConstantLabel(22).Caption=
getPageContentHeaderLabel(22).Caption=
pageKeywords(22).Text=valuetype
pageC.pages[23].ImageIndex=-1
pageTitle(23).Text=3D pinball for windows (pointer+code)
getPageConstantLabel(23).Caption=
getPageContentHeaderLabel(23).Caption=
pageKeywords(23).Text=pointers;code;pinball
pageC.pages[24].ImageIndex=-1
pageTitle(24).Text=Direct x-mess +anti-debug
getPageConstantLabel(24).Caption=
getPageContentHeaderLabel(24).Caption=
pageKeywords(24).Text=directx;debugger
pageC.pages[25].ImageIndex=-1
pageTitle(25).Text=Find out what addresses are accessed by a piece of code
getPageConstantLabel(25).Caption=
getPageContentHeaderLabel(25).Caption=
pageKeywords(25).Text=code
pageC.pages[26].ImageIndex=-1
pageTitle(26).Text=Basic assembler
getPageConstantLabel(26).Caption=
getPageContentHeaderLabel(26).Caption=
pageKeywords(26).Text=assembler
pageC.pages[27].ImageIndex=-1
pageTitle(27).Text=Code Injection and the auto assembler
getPageConstantLabel(27).Caption=
getPageContentHeaderLabel(27).Caption=
pageKeywords(27).Text=code injection;Auto Assemble;assembler
pageC.pages[28].ImageIndex=-1
pageTitle(28).Text=Searching Tip
getPageConstantLabel(28).Caption=
getPageContentHeaderLabel(28).Caption=
pageKeywords(28).Text=
pageC.pages[29].ImageIndex=-1
pageTitle(29).Text=Remote desktop instead of network version
getPageConstantLabel(29).Caption=
getPageContentHeaderLabel(29).Caption=
pageKeywords(29).Text=network;client;server;remote desktop
------------ end of page titles / full text of pages follow ------------
----- SHM ---- page 0 ---- 
This helpfile is just to help with the basics of Cheat Engine, if you think you can write a better helpfile please do so and send it to dark_byte@hotmail.com, thanks! ;-)

DB
----- SHM ---- page 1 ---- 
Cheat Engine is a program designed to make cheating on games easy for people that are new to cheating in games, and for people who already know a lot about cheating.
This program came into existance because at the time there where no free easy to use cheat programs, and the ones that where free weren't very easy to use for a beginner. (Or lacked some essential stuff)

Also, I was used to cheat on games using gamehack, and when I moved on to Win2000 I couldn't get it to work, so decided to make something that did work... (And cause I just had to do something, like how to learn to program)

Over time Cheat Engine has had a lot of improvements, more features, and better stability than the very first versions, and that all thanks to the ideas and suggestions of people that sent me some feedback, so, if you want to help make Cheat Engine better, send your ideas and suggestions, to dark_byte@hotmail.com (MSN supported) .
Or you could download the source code, make changes yourself and send them to me. (CE is written mainly in Delphi, so it helps if you know that language before you try it ;-)  )

Also, another way to motivate me to work on Cheat Engine, is to donate. You can donate whatever ammount you prefer to dark_byte@hotmail.com using paypal.
----- SHM ---- page 2 ---- 
<b>First scan</b>
The "First Scan" is the first thing you do when you are scanning the memory. "First Scan" initializes the data structures inside cheat engine and reads the complete memory of the selected game. If you already know the value it will scan the memory while it's reading, and take less memory.

<b>Next scan</b>
The next scan processes the results of the previous scan. If you did a first scan before with a "Advanced" scantype, it wont have any results, but cheat engine does contain the memory of the game as it was when you did the scan the previous time. That way you can do a scan for a changed,unchanged value etc...
If you did get results from a previous scan the next scan will look at those results, and compare them to the scantype you selected, and remove those addresses that dont pass the test, making the list smaller and smaller till there are only a few or even 1 address left.

<b>Undo scan</b>
If you made a error while scanning, like searching for a increased value, while you had to search for a decreased value, you can click "Undo Scan" and Cheat Engine will restore the results back to the previous scan, allowing you to try again, instead of completly starting over.

<b>New scan</b>
The new scan whipes out all your results, and frees the memory, allowing you to start a new scan.

<b><klink=scan types,1>Scan types</klink></b>
In the scantype combobox you can select what type of scanning will be done.

<b><klink=value types,1>Value types</klink></b>
In the value types combobox you can select what type of address you are looking for.
Normaly a value is 4-bytes in windows, but sometimes it is different, or you are looking for something else, in that case choose another value type.

<b>array to scan</b>
Programs reside in the memory, and store their addresses in various locations. With the Array to scan option you can increase/decrease the number of locations that Cheat Engine will look at for the address you need. This can dramatically increase your scanning speed, and improve the results, when used wisely.

<i>If you're playing dosgames in windows ME or earlier choose the 16-bit memory array. If you're targeting a dos game in NT, 2000, XP , Vista or later, target ntvdm.exe and set as range 0 to 7fffffff </i>

<b>readonly</b>
The readonly checkbox tells Cheat Engine, if you want to scan read-only memory or not. Normaly games do not store important game information in read-only memory, but sometimes you may feel a need to scan that memory anyhow. (e.g. If you want to change some text in the game etc...)

<b>fastscan</b>
The fastscan checkbox tells CE to skip addresses that arn't located on a alligned. (Address devidable by 2 or 4 depending on the type)
----- SHM ---- page 3 ---- 
The select window process can be accessed by clicking on the computer icon on the top left side of the main window.

This window holds a list of all the processes currently running.
Double click on a entry and cheat engine will open this <pop=SHM_contents0005>process</pop> for scanning.

If you click on the window button at the bottom you'll get to see all the windows, and the processes that own them, so if you dont know the process name you can use the window to find the process.

The process window also has the ability to attach the debugger the a running process, or to create a new process. The option to attach to a running process is usefull if you don't want a delay when you want to use the debugger, and he option to create a process is usefull when you're using windows 98 or ealier which doesn't have the ability to attach to a running process.

If you have enabled the option to use the processwatcher in settings->extra you will have a 3th button at the bottom saying "Process watcher". Clicking that will open the process watcher window. It'll show you which processes have been created since the start of CE
----- SHM ---- page 4 ---- 
A process is a program or game running in windows.
----- SHM ---- page 5 ---- 
The found list is the list on the left side of the window, under the <klink=Select Process,1>Select Process </klink>button.

When you do a search and the number of addresses your scan found is smaller or equal to the max number of addresses to show(You can change that in the <klink=Settings Window,1>setting window</klink>), then this list will be filled with the addresses you've found.

If you double click an address, drag it to the list at the bottom, or select some addresses and click the red arrow, the addresses will be added to the memory watch list at the bottom
----- SHM ---- page 6 ---- 
<b>Binary</b>
The binary scan is a slow but powerfull scan.
It will scan between bytes for a value
Also, if you want to search for a array of bits that possible too, it even allows wildcard(?,*) instead of the normal 1's and 0's. This allows you to do a search like 1101?001, which will give the results of all addresses+bit that have either 11010001 or 11011001. (More wildcards in a string are allowed)

The range of a bitscan can be as long as you like. (as long as it fits in the memory)

If you're wondering if this is usefull: 
Lets say a program stores the following values as follow:
100=1001100100110110
200=1011001000101001
300=1100101100110110

also note that in normal binary notation the following values are:
100=1100100
200=11001000
300=100101100

now, if you look at the above example you'll notice that the binary value of 100 does apear in the binary that represents 100, but has a 1 as last bit, and the first few bits are random (read from right to left) , same for 200 and 300, with the binary scan you can scan for the binary representation of the values 100-200 or 300.

<b>Byte</b> (8-bits)
A byte is a value that can hold a number between 0 and 255 or -128 to 127. (The last one if it is a <pop=SHM_contents0008>signed value</pop>)
1-byte values aren't used much except for 8-bit emulators, etc... Even though a 1-byte scan seems useless, it will normaly find the value when you dont know for sure wheter the value is either 1-byte, 2-bytes, 4-bytes, or 8-bytes, that is because all those types are build from this base type.

Of course, the number of initial addresses you'll find doing a 1 byte scan is very big, and it will take a while to find the address you're looking for, but at least the change of finding it is higher.

<b>2 bytes</b> (16-bits)
a "2 Byte" value can hold a number between 0 and 65536 or -32768 to 32767 (The last one if it is a <pop=SHM_contents0008>signed value</pop>)
"2 byte" values are used in old dos games, and other 16-bit application.


<b>4 bytes</b> (32-bits)
a "4 byte" value can hold a number between 0..4294967295 or -2147483648 and 2147483647 (The last one if it is a <pop=SHM_contents0008>signed value</pop>)
"4 byte" values are the standard way of storing information in a windows system. So doing a 4-byte scan will normaly give the best results.

<b>8 bytes</b> (64-bits)
a "8 byte" value can hold a number between 9223372036854775808 and 9223372036854775807 (no need for unsigned values anymore)
"8 bytes" aren't used often because they take up a lot of space, and require extra processing. (except for 64-bit processors)
Some programs do use them though, and scanning for a "8-byte" value doesn't return many addresses, so finding the right one is easy then.

If the address you're looking for is smaller than 8 bytes, the chance that the scan has skipped that address is big.

<b>Single</b> (32-bits) (IEEE standard)
a "Single" value can hold a number between 1.5 x 10^-45 and 3.4 x 10^38	.

This is one of the 2 standard floating-point value allocations. (IEEE) The other one is DOUBLE
A Single consists of 4 bytes, which is build up in a special way, which is VERY different from normal variables! (so normal byte scanning wont work)

Cheat Engine rounds values up/down till the number of digits you specify in the scan value box.
e.g.:if you scan for 12 it will find all values between 11.5 and 12.4 and 12.0 results in values between 11.95 and 12.04

<b>double</b> (64-bits) (IEEE standard)
See Single, and the range is between 5.0 x 10^-324 and 1.7 x 10^308	


<b>Text</b>
The "Text" scanvalue can be used to scan the memory of a game for text. E.g: if you know that 12 bytes after your name as a variable you need you can use that to recalculate the addresses each time a game restarts.

<b>array of byte</b>
Same as text, but uses a array of byte instead of characters, and supports wildcards.
input:
xx xx xx xx ...
xx ?? xx xx
xx ** xx xx

a array of byte scan can be usefull when you know that prior to the address you need is always a specific occurance of bytes. (like: 66 66 66 10 10, and 4 bytes after that is your health which is stored as 1 byte. Scanning for 1 byte will take a lot longer than scanning for this string of bytes. Scanning for this string will propably only result 1 address, where as scanning for 1 byte will return thousands of addresses the first time)

<b>All</b>
A combination of byte, 2 bytes, 4 bytes, 8 bytes, single and double

<b>Custom</b>
Lets you assign an auto assembler script where you can fill in how the compare wioth an address should be done and what would result in a positive or negative result
To delete a custom scanscript selexct it and when it's still focuseed press delete
----- SHM ---- page 7 ---- 
Signed:
A value can hold a negative value if it is a signed value.
This is done by inverting all the bits. (all 0's become 1's and 1's become 0's) and increasing the resulting value by 1

example:
12=		00001100
invert=	11110011
-12=		11110100 (notice that if this was a unsigned value this would be 244)
----- SHM ---- page 8 ---- 
Unknown initial values: ("First scan" only)
This scantype  makes a copy of the game in memory, so it can be used later on. (Like comparing it with the current memory and see if it has changed or not)

Exact:
The "exact" scan will scan the memory for the value(or string) you've entered

Bigger than
The "Bigger than" scantype scans for all the values that are higher than the value you've entered

Smaller than
The "Smaller than" scantype scans for all the values that are smaller than the value you've entered

The following scantypes are available only when doing a "next scan"
Increased
If the value of a address has increased it will be added to the list.

Increased by...
If the value of a address has increased with the specified ammount it will be added to the list.

Decreased
If the value of a address has decreased it will be added to the list.

Decreased by...
If the value of a address has decreased with the specified ammount it will be added to the list.

Changed
This scantype will check if the value of an address has changed or not. If it has changed it'll be added to the list

Unchanged
This scantype will check if the value of an address has changed or not . If it has not it'll be added to the list

Same as first scan
This scantype will check if the value of an address is the same as when it was when you did first scan. If it is, it'll be added to the list.
----- SHM ---- page 9 ---- 
The address list is the place where all the addresses will go that you think are usable.

The list can be navigated by using they keyboard and mouse.
There are 2 ways to change a value in the list, by either double-clicking the value, or by selecting it and pressing enter.
For all the other items in the list just double click on it and it will open up a new window allowing you to change it.

The checkboxes allow you to freeze and unfreeze the address. If you freeze a address the address will not change untill you unfreeze it. The value does change but Cheat Engine will restore the value to it's frozen state every few milliseconds(The number of milliseconds can be changed in the <klink=Settings Window,1>settings window</klink>) 

There are 3 types of freezing: Normal (=),Allow Positive (+), and Allow Negative (-). You can change the type of freezing by clicking on the symbol right of the checkbox. The allow positive and negative can be set also by keyboard's numeric + and - keys.

Also, when you right-click on one or more addresses a popup window will show with additional options.


The following keys can be used when the address list has focus:
ENTER:		Change value
Ctrl+Enter:	Change destription
Alt+Enter:	Change Address
Space:		Freeze
+			Positive freeze
-			Negative freeze
Delete:		Delete Address
Ctrl+S:		Switch the position of 2 selected addresses
Ctrl+E:		Edit the selected address
Ctrl+Alt+A:	Open the auto assembler
Ctrl+Alt+Grey Plus:	Move down one position
Ctrl+Alt+Grey Minus:	Move up one position
----- SHM ---- page 10 ---- 
The questionmark on the bottom right of the cheat engine window opens the Comments window.
The comments window can be used to store extra information in your cheat tables. You can for example use it to leave notes on how you found a address, or other stuff, like your name.
----- SHM ---- page 11 ---- 
The memory view can be reached by clicking on the memory view in the main cheat engine window.

The memory view contains several tools and functions for advanced game hackers like the autoassembler, a codecave scanner, a thread generator, a memory allocator, a code dissector, a dll injector, debugger options, a disassembler, a assembler, a hex viewer and more.

To change assembler code just stand on the address you want to edit and type in your now code.
To edit the value of some bytes directly in memory just click on a byte and start typing in the new values.

There are also some hotkeys, like CTRL+G to jump which will popup a box where you can fill in the new address you want to go to and ctrl+f in the hex view to do a simple scan
If you have a jmp or call selected you can press SPACE to follow that address. BACKSPACE and CTRL+SPACE will go back
----- SHM ---- page 12 ---- 
You will sometimes read about the debugger of cheat engine, this is a thread that has access to the opened process, and handles all debugging events, like creating threads, handling exeptions, etc...
a thread is a part of the program that runs seperatly from the rest of the program, but still has access to the memory of the main program
----- SHM ---- page 13 ---- 
The settings window allows you to change several aspects of Cheat Engine ranging from how it looks to how it scans.
----- SHM ---- page 14 ---- 
Older versions of cheat engine come with a seperate Client and Server version

There are a few games that give no possibility to switch between programs. (It either closes, crashes, or takes down your whole pc when you switch to something else)
In those cases the Network versions of Cheat Engine come in handy.(Assuming you have 2 computers or a friend over internet willing to help)

Load the server program on the computer that will run the game and start the server.
Then run the game on that computer and start the client part of Cheat Engine on another computer.
Make a connection with the client to the computer that runs the server. When a connection is established the Cheat Engine userinterface will show up on the client side. With that you can open the process of the game on the server and scan the memory as if you're local.

To get them, download Cheat engine 5.3 or earlier
----- SHM ---- page 15 ---- 
To create a trainer click on the advanced button and then click on the create trainer button (the one with the save file icon) or save your table with a .exe extention to get to the same screen.
In this screen you can choose to open a already existing trainer, or to create a new one. 

File patcher: This will allow you to create a trainer that will scan through your files and take out code.

Memory trainer:
With the memory trainer you can create cheats by adding cheats to the list and assigning hotkeys to them.
Also got other features like pop-up on keypress, etc...

Designer:
If the default userinterface of the trainer doesn't look good you can always try to make your own by using the option to design your own.
If activated it opens a window in which you can place controls like images, and buttons.

keys for the designer: (when a object is selected)

arrow keys:	move the object 1 pixel in that direction
shift+arrow keys:	resize the object 1 pixel in that direction
delete:		delete the selected object
ctrl+n:		go to next object
----- SHM ---- page 16 ---- 
The speedhack of cheat engine replaces some commonly used funtions in games to keep the speed constant with it's own routine that goes faster or slower.

There are 2 values you can fill in, speed and sleeptime.
Speed allows you to specify the speed you want the game to run at. (0.5=Half speed, 2=Double speed)

The sleeptime handles how accurate the speed is emulated. A higher sleeptime gives a more accurate speed, but if you make it too high, the game may become choppy. This is due to the way the speedhack works. Every few milliseconds it updates the time. And the time it waits between the updates is the sleeptime. As you can imagine, waiting a long time before uopdating the current time will result in weird/choppy behaviour, but having no wait will eat up the whole cpu leaving no time for the game, making it extremely slow.
----- SHM ---- page 17 ---- 
Auto assemble allows you to write assembler code at different locations using a script. It can be found in the memoryview part of cheat engine under extra.

There are 3 special commands you can give it, ALLOC , LABEL and FULLACCESS. With LABEL you can give a address a name by declaring it before you use it. ALLOC is basicly the same as LABEL but allocates some memory for you.
Usage: 
LABEL(labelname) //Enables the word labelname to be used as a address
ALLOC(allocname,sizeinbytes) //same as label, but allocates the memory it points to itself
DEALLOC(allocname) //Deallocates a block of memory allocated with alloc. It always gets executed last, no matter where it is positioned in the code, and only actually frees the memory when all allocations have been freed.  only usable in a script designed as cheattable. (e.g used for the disable cheat)
FULLACCESS(address,size)  //makes a memory region at the specified address and at least "size" bytes readable, writable and executable

REGISTERSYMBOL(symboname) //adds the symbol to the userdefined symbol list so cheattables and the memory browser can use that name instead of a address (The symbol has to be declared in the script when using it)
UNREGISTERSYMBOL(symbolname) //removes the symbol from the userdefined symbol list. It won't give a error if it isn't found

DEFINE(name,whatever) //Will replace all tokens with the specified name with the text of whatever
INCLUDE(filename) //includes another auto assembler file at that spot
LOADBINARY(address,filename) //will load a binary file at the specified address
CREATETHREAD(address) //Will spawn a thread in the process at the specified address
LOADLIBRARY(filename) //Will inject the specified dll into the target process
READMEM(address,size) //Will write the addresses at address at the location this instruction is placed

<b>Basic Example</b>:
00451029:
jmp 00410000
nop
nop
nop

00410000:
mov [00580120],esi
mov [esi+80],ebx
xor eax,eax
jmp 00451031

<b>Example using LABEL</b>:
label(mylabel)

00451029:
jmp 00410000
nop
nop
nop
mylabel:

00410000:
mov [00580120],esi
mov [esi+80],ebx
xor eax,eax
jmp mylabel

<b>Example using ALLOC</b>:
alloc(memloc1,4)

00451029:
jmp 00410000
nop
nop
nop

00410000:
mov [alloc1],esi
mov [esi+80],ebx
xor eax,eax
jmp 00451031

<b>Example using ALLOC and LABEL</b>
alloc(alloc1,4)
label(mylabel)

00451029:
jmp 00410000
nop
nop
nop
mylabel:

00410000:
mov [alloc1],esi
mov [esi+80],ebx
xor eax,eax
jmp mylabel


<b>Example using FULLACCESS</b>
FULLACCESS(00400800,4) //00400800 is usually read only non executable data, this makes it writable and executable
00451029:
jmp 00410000
nop
nop
nop

00410000:
mov [00400800],esi
mov [esi+80],ebx
xor eax,eax
jmp 00451031

<b>Example using DEFINE</b>
DEFINE(clear_eax,xor eax,eax)
00400500:
clear_eax

<b>ReadMem example</b>
alloc(x,16)
alloc(script,2048)

script:
mov eax,[x]
mov edx,[x+c]
ret

x:
readmem(00410000,16) //place the contents of address 00410000 at the address of X
----- SHM ---- page 18 ---- 
Cheat engine also has a script engine in which you can execute simple c-scripts.
You can run thos c-scripts inside CE, but you can also inject them into the target process and let it execute there. The scripts have access to the real memory.
Also, when running in the contectx of Cheat Engine using the normal execute button the script engine provides you with several extra commands that are not available when using the injected form.
They are:

<b>void ce_showmessage(char* message);</b>
Will popup a messagebox with the specified message
Usefull for showing the result of an operation.
e.g:
char result[100];
int x=123;
x=x+6;
sprintf(result,"123+6 = %d",x);
ce_showmessage(result);

<b>int ce_ChangeRegistersAtAddress(unsigned long addresstonbreakat, void *changeregstructure);</b>
This will use ce's "Change register at address" feature.
addresstonbreakat is the address to place the break at and changeregstructure is a pointer to the changereg structure.

Look at the plugin-system help or the changeregtest.CEC  example provided for the structure.

<b>int ce_AutoAssemble(char *script);</b>
Will autoassemble the script provided in script.
will return 0 if failure

<b>int ce_Assembler(unsigned int address, char *instruction, unsigned char *outputbuffer, int maxbuffersize, int *numberofbytes);</b>
Will assemble one specific instruction and return the bytes to a structure you've allocated


<b>int ce_Disassembler(unsigned int address, char *outputstring, int maxsizeofstring);</b>
Will disassemble a specific address of the currently selected process and fill it in outputstring.

<b>int ce_InjectDLL(char *pathtodll, char *optionalfunction);</b>
Will inject a dll and calls a function of that dll (No parameters) Optionalfunction can be 0

<b>unsigned int ce_GetAddressFromPointer(unsigned int baseaddress, int offsetcount, unsigned int *offsetlist);</b>
Will convert an address with offsets to the final address.
offsetcount is the number of offsets in the list (offsetlist)

<b>int ce_GetSelectedProcessHandle(void);</b>
Will return the current processhandle;

<b>int ce_ReadProcessMemory(unsigned int processhandle, void *baseaddress, void *buffer, unsigned long bytestoread, void *numberofbytesread);</b>
Will use the current ReadProcessMemory currently used by Cheat Engine

<b>int ce_WriteProcessMemory(unsigned int processhandle, void *baseaddress, void *buffer, unsigned long bytestowrite, void *numberofbyteswritten);</b>
Will use the current WriteProcessMemory currently used by Cheat Engine.
----- SHM ---- page 19 ---- 
Cheat Engine is filled with other features, try to find them and find out what they do, or send questions about them to dark_byte@hotmail.com
----- SHM ---- page 20 ---- 
This section contains a collection of all usefull tutorials originally posted on the cheat engine forum.
----- SHM ---- page 21 ---- 
Originally posted by Emperor:

Hope it's usefull ...after all i did much research on it. This guide written by me explains how to use CE for anti tab protected games. 
First you may wonder : 
<b>What does anti tab protected mean? </b>
It means if you minimize it, it will never come up again, it will kill itself. This happens if you use any kind of task switching or click on any other program. 
<b>What can be done about it? </b>
Possiblity 1: 
There is a program AAT that freezes the game and then brings your cheat-tool (of course we all use CE don't we?) to the front. Once a scan is done you can press another button to switch back to the game and resume it. Because it was frozen during that time it didn't notice it was not in the foreground. Altough being frozen CE can still attach itself to the game (although it may require you to switch to the game unfreeze it and then freeze again in order to make it work). With AAT however there's always the risc the game will crash anywaays or AAT will stop responding making it impossible to unfreeze the game. 
Possbility 2: 
Xunleashed. With it you can run directx programs in a normal window. 
Xunleashed has not been tried by me as it costs 20$ (after all i can still use AAT and CE network version). It should work, if you are unsure weather it works with your game or not look at the message board. 
Possiblity 3 
Use the CE network version. This of course requires 2 computers and you to switch between them. Also the functions in the network version are limited, but new features are being added. 
<b>What do game creators do against those? </b>
-Game guard. : The 4.4 Version of CE can cheat Anti Tab protected games. Therefore you can safely use the network version. AAT will not work with nProtected games but if you execute the game as a normal user and AAT as an administrator it will still work.
----- SHM ---- page 22 ---- 
Originally posted by emperor:

2 Byte means: 00 00 to FF FF this allows only up to 65535, obviously. 
4 byte maens: 00 00 00 00 to FF FF FF FF (allows up to 4294967295). 
Now for example you can miss 2 byte values with 4 byte scans: 
example: value in game is 300 stored in game's memory as 012C 
If you search for 12C as 2 Byte it will be in your results. 
If you search for 12C as 4 byte the 2 Bytes before the 012C matter as well. 
For example the 012C would be after an FF FF. 
Meaning: FF FF 01 2C is in the memory 01 2C being what you are searching for. However seen as 4 Byte this is not 01 2C (300) but it's FF FF 01 2 C (4294902060) . 
To my mind for exact value scans you should use the smallest appopirate byte type (for ex if it doesn't rise over 65000 use 2 byte). However since most games multiply it with a certain factor exact value scans are hardly any useful...when doing an unknown value scan it's up to you to chose the correct bytesize...most commonly used is 4 byte after all. It's nothing new to me seeing games showing a stat up to like 2000-3000 as 4 Byte in a huge number over serveral hundret thousands..however how much a certain game multiplies,adds or substracts, or tries to hide it depends on the game, is therefore sort of unknown therefore i think in many cases the bytesize is also sort of unknown although 4 Byte is always likely. Note doing increase/decrease value scans wouldn't fail even if there were some other bytes before it: for ex 
FF FF 01 2C is increased by one... 
---> FF FF 01 2D increased would still be okay as unknown initial. 
But if the FF FF also changes 
to like FE FE then it would screw up the scan.
----- SHM ---- page 23 ---- 
Originally posted by me. (no not me, but the user called me)

this is to try answer the most common questions from people new to cheat engine 

using 3d pinball for windows space cadet as an example,,, 
it might be an idea to print this and other tuts so its easier to work through them,,, 

( this game gives you some free balls so be on the look out for that during this tut ) 

start 3D PINBALL FOR WINDOWS ,, and wait for the first ball to deploy 
start cheat engine 
click on the flashing icon in the top left of cheat engine 
in the bottom of process list window 
double click on PINBALL.EXE to attache the game to cheat engine 
in the value box type in 3 
go into the pinball game and lose a ball 
wait for the next ball to be deployed 
go back into cheat engine 
type 2 into the value box 
click on the next scan button 
I got the address A9FEE6 yours may be different 

ok 

I'll double click on the found address A9FEE6 to add it to the bottom pane 
click on the checkbox to freeze this address 
go back into the PINBALL GAME 
lose some balls to see if its the right address 
if you have got it right you'll have infinite balls 

------------------------------------------------------------------------------- 
now to find the code that changes the number of balls 
------------------------------------------------------------------------------- 

go back into cheat engine 
(if you want you can double click on the value part of the address in the bottom pane and change it back to 3 or 4 balls) 
In the bottom pane again right click on the address A9FEE6 and choose 
FIND OUT WHAT WRITES TO THIS ADDRESS 

you will then get the debugger window 
go back into pinball and lose another ball 
in the debugger window you should see the address of the code that changes the number of balls 

I got 01015f02 - 89 86 46 01 00 00 - mov [esi+00000146],eax 
click on this to highlight the code,, and click on the ADD TO CODELIST button 
a box called CHEAT ENGINE CODE will pop up 
name balls 
and hit the OK button 

a window called ADVANCED OPTIONS WILL pop up with balls in it 
you can right click it and choose REPLACE WITH CODE THAT DOES NOTHING 
to show that the code has been nopped out the name will turn red 
you can hit the ok button to close the advanced options window then the stop and close button to exit the debugger 
then save your table,,,, but for now 
just hit the ok button to close the advanced options window 

in the debugger window look at the code 01015f02 - 89 86 46 01 00 00 - mov [esi+00000146],eax 
now with the code highlighted click on the MORE INFORMATION button 
the EXTRA INFO box will pop up 
in this box under copy memory you will see the sentance 

THE VALUE OF THE POINTER NEEDED TO FIND THIS ADDRESS IS PROBABLY 00A9FDA0 

this is the address held in the ESI register below this you can see all the values that the registers held at the instant you lost a ball,, 
as you can see ESI=00A9FDA0 
and highlighted in red you can see 

01015F02 - mov [ esi + 00000146 ],eax 

this is all in hexadecimal 
so the ESI register holds 00A9FDA0 therefore 
[esi + 00000146] = [ 00A9FDA0 + 00000146 ] 
00A9FDA0 + 146 = 00A9EEF6 

the first address I found when I started scanning at the start of the game 

so note down the address 00A9FDA0 
and the offset 146 

close the EXTRA INFO window 
in the main cheat engine window ,,,hit the new scan button 
next to the value box theres a hex checkbox ,, check it so you can enter a hex value 
put in our address without the zeros in front of it A9FDAO 
and hit the first scan button 

you will get a couple of hundred results 
i'll try the first address on the list 009A4356 

click on the add address manually button 
click on the poiter checkbox and you will see the ADD ADDRESS window change 

where it says ADDRESS OF POINTER type in our address 9A4356 
and in the OFFSET [HEX] box type in 146 ,,,,,,,,, remember [esi + 00000146] 
and hit the ok button 

hopefully a new address with should look like this in the bottom pane 
No description P->00A9FEE6 4 bytes 0x00000003 
or how ever many balls you got left 
you can freeze the number of balls from this pointer now,,,,, 
in games that use Dynamic Memory Allocation ,,, DMA 
and use the same code to change things for you and the enemies,, 
pointers are usfull 

------------------------------------ 
ok a couple of things 

1) this game don't use dma ,, but its an easy game to practice on 
2) Its free and most people have it 
3) so for newcomers it gives an idea of how to use the basic search / pointer / and advanced options 

well as they say thats my two cents 
----- SHM ---- page 24 ---- 
Originaly posted by Dark Byte
If you want to use the directx-mess functions in a game but the game detects the debugger (or crashes because of it) then before clicking on OK to run the game select another process, or simpley close Cheat Engine.
This will detach the debugger from Cheat Engine.
----- SHM ---- page 25 ---- 
Originally posted by Dark Byte

Sometimes when you've found a address and the code to change that address is also used to change other addresses (like that of the enemy) the following function will be usefull: 

When you've found the code that accesses the address you've found you can save that and use it to find the address you are looking for, so you don't have to go through the slow scanning routine again. (unless of course scanning for it is a lot faster than this, like finding a piece of text and then recalculating the rest) 

Go to the advanced window, rightclick the code and choose "Find out what addresses this code writes to" (or reads from depending on what kind of code it is, and can sometimes be a write instead of a read but that doesn't matter) and play the game. after a while the list will be filled up with all the addresses that that code used. (enemy's energy including if it is also used to handle the enemy) 

Only downside is that this (currently) only works for instructions that have a [...] part. So instructions like "rep movsb" won't work, but that is a instruction thats useless to cheating anyhow)
----- SHM ---- page 26 ---- 
Originally posted by Dark Byte + addition by Smidge204

Most people think assembler is very difficult, but in fact it's very easy. 
In this tutorial i'll try to explain how some basic assembler works 

The processor works with memory and registers. The registers are like memory but a lot faster than memory. Registers are EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI, and the segment registers. (There's also EIP, wich is the Instruction Pointer. It points to the instruction that is about to be executed) 

Some examples: 

<u>sub ebx,eax</u> (ebx=00000005,eax=00000002) 
Lets take it apart in it's most basic elements: 
opcode param1,param2 

The opcode is the instruction telling the processor what to do, in this case decrease the value stored in register ebx with the value stored in register eax. 

In this case ebx=5 and eax=2 so ebx would be after this instruction 3. (5-3) 

Also note that whever you see a opcode with 2 parameters: The first parameter is the target of the instruction. The 2nd is the source 

<u>sub [esi+13],ebx</u> (ebx=00000003,esi=008AB100) 
In this case you see the first parameter is between brackets. This indicates that instead of registers a memorylocation is being used. 
The memorylocation is pointed at by whats in between the brackets, in this case esi+13 (Note that the 13 is in hexadecimal) 

ESI=008AB100 so the address pointed at is 008AB113. 
This instruction would decrease the value stored at location 008AB113 with the value stored in ebx(wich is 3). 

If the value at location 008AB113 was 100 then the value stored at 008AB113 after this instruction would be 97. 

<u>sub [esi+13],63</u> (esi=008AB100) 
This is almost the same as above but instead of using a register it uses a direct value. 

Note that 63 is actually 99 because the instruction is always written using hexadecimal. 

Lets say the value at 008ab113 is 100 (wich is 64 in hexadecimal) then the value at 008ab113 after execution would be 1 (100-99) 

<u>sub ebx,[esi+13]</u> (ebx=00000064 esi=008ab100) 
This instruction decreases the value stored in ebx with the value stored at location 008ab113. (esi+13=008ab100+13=008ab113, in case you forgot) 


Up until now i've only used SUB as instruction, but there are lots and lots of other instructions the procesor knows. 

Lets take a look at MOV, one of the most often used instructions 
although it's name sugests that it moves data, it just COPYs data from one spot to another. 

MOV works exactly the same as sub. first parameter is the destination, and second parameter is the source. 

examples: 
<u>MOV eax,ebx</u> eax=5,ebx=12 
Copies the value stored in ebx into eax 

So, if this instruction would be executed eax would be 12. (and ebx would stay 12) 

<u>MOV [edi+16],eax</u> eax=00000064, edi=008cd200) 
This instruction will place the value of eax(64hex=100 decimal) at the location of edi+16 (008cd200+16=008cd216). 
So after instruction the value stored at 008cd216 will be 100 (64 hex) 

As you see, it works just like the SUB instruction. 

Then there are also those instructions that only have 1 parameter like inc and dec. 
example: 
inc eax :increase the value at eax with 1 
dec ecx: decrease the value of ecx with 1 
dec [ebp]: Decrease the value stored at the address pointed to by ebp with 1. 

Right now i've only shown the 32-bit registers (eax, ebx ecx....) but there are also 16-bit register and 8-bit registers that can be used. 
the 16 bit registers are: AX,BX,CX,DX,SP,BP,SI,DI 
the 8 bit register are: AH,AL,BH,BL,CH,CL,DH,DL 

Note that when changing ah or al you'll also change AX, and if you change AX you'll also change EAX, same goes for bl+bh+bx+ebx,ch+cl+cx+ecx,dh+dl+dx+edx 

You can use them almost the same with the instructions for 32 bit but they will only change 1 (8 bit) or 2(16-bit) bytes, instead of 4 (32-bit) bytes. 

example: 
dec al :decreases the 8 bit register al 
sub [esi+12],al :decreases the 1-byte value stored at the location esi+12 points at with the value of al 
mov al,[esi+13]:places the 1-byte value stored at the location esi+13 points in the al register. 

Note that it is IMPOSSIBLE to use a 16 or 8 bit register for instructions that point to an address. eg: mov [al+12],0 will NOT work. 

There are also 64 and 128 bit registers, but I wont discuss them since they are hardly ever used, and cant be used with the other instructions that also work with 32 bit) 


Then there are the JUMPS, LOOPS, and CALLS: 
JMP: 
The JMP instruction is the easiest it changes the Instruction Pointer (EIP) to the location the JMP instruction points at and continues from there. 

There are also conditional jumps that will only change the instruction pointer if a special condition has met. (for example set using the compare instruncion (CMP)) 

JA=Jump if Above 
JNA=Ju,p if not above 
JB=Jump if below 
JE=Jump if equal 
JC=Jump if carry 
and LOTS of other conditional jump 

LOOP: 
The loop instruction also points just like the JMP to a memory location, but only jumps to that location if the ECX register is not 0. 

and of course, there are also special contitional loops: 
LOOPE:Loop while ecx is not 0 AND the zero flag is not set 
LOOPZ:same as LOOPE. 
LOOPNE:Loop while ECX is not 0 AND the zero flag is set. 
LOOPNZ:Same as LOOPNE 

I gues I should also explain what flags are, they are bits in the processor that can be used to check the condition of a previous instruction like 'cmp al,12' if al=12 then the zero flag (ZF) will be set to true, else the Zero flag(ZF) will be set to false. 

CALL: 
Call is the same as JMP except it uses the stack to go back. 

Explenation of the stack: 
The stack is a location on memory pointed at by the ESP register. 
You can put values in it using the PUSH command, and take out it using the POP command. If you use PUSH it will decrease the ESP register and place the value at the location of ESP. If you use POP it will place the value pointed at by pop into the location pointed at by the parameter of POP and increase the value of ESP. In short: The last thing you push in the stack will be the first thing you pop from the stack, the 2nd last item in will be the 2nd item out. 

RET: 
After CALL has pushed the location of the next instruction onto the stack it jumps to that location. (sets the instruction pointer to that location) 

After a while it will encounter a RET instruction, and will then jump to the location that is stored in the stack. (Call pushed the location in the stack, ret pops it out again and jumps to that location) 

And thats the tutorial on the basics of assembler, if you have questions about assembler and stuff just ask and I'll try to answer. 

Nice file to check out if you want more info: 
http://podgoretsky.com/ftp/Docs/Hardware/Processors/Intel/24547111.pdf 

note: It's really usefull to understand how those values between brackets work, because then you can make the most use of the pointer stuff in CE 4.1 (It will remove for most games the Dynamic Memory Allocation problem for most games, if you know how how to look at the assembler code that accesses the values you found)

------------------------------------------------------------------

The "flags" are a set of bits stored in a special register. If the bit is "1" the flag is said to be set, and if it's "0" then the flag said to be "clear". Collectively, the flags tell you all about the processor's internal status and gives more information about the results of previous instructions. 

There are three types of flags: Status flags that tell you about the results of the last instruction, Control flags that tell you how the processor will behave, and System flags that tell you about the environment your program is executing it. 

The flag register is 32 bits: (S=Status flag, C=Control flag, X=System flag) 


Code: 
 0   S   Carry 
 1      (Reserved) 
 2   S   Parity 
 3      (Reserved) 
 4   S   Auxiliary Carry 
 5      (Reserved) 
 6   S   Zero 
 7   S   Sign 
 8   X   Trap 
 9   X   Interrupt Enable 
10   C   Direction 
11   S   Overflow 
12   X   I/O Privilage (bits 12&13) 
13   X    
14   X   Nested Task 
15      (Reserved) 
16   X   Resume 
17   X   Virtual 8086 
18   X   Alignment Check 
19   X   Virtual Interrupt 
20   X   Virtual Interrupt Pending 
21   X   Identification 
22   \ 
23    | 
24    | 
25    | 
26    |_ (Reserved) 
27    | 
28    | 
29    | 
30    | 
31   / 


Let's go over the status flags, since those are used most often. 

Overflow: 
When an operation (Addition, subtraction, multiplication, etc) produces a result that is too big to fit in the register (or memory location) used, the Carry flag is set. (If not, it's cleared automatically) For example, if you're using a 16 bit register and your operation produces a value that won't fit in 16 bits, the carry flag is set. 

Sign: 
Set if the result is negative, cleared if positive. This is typically a mirror of MSB (most significant bit) of a value. 

Zero: 
Set if result is 0. 

Auxiliary Carry: 
Similar to Carry, but it will treat the register/memory location as 3-bits instead of 8, 16 or 32. This is used for BCD (Binary coded decimal) stuff and it generally pretty useless otherwise. 

Carry: 
The carry flag is set if the bit one past the lmit of the register/memory location would have been set. For example, mov al, 0xFF then add al, 1 will cause a carry because the 9th bit would have been set. Also note that the overflow and zero flags would be set and sign flag cleared, too! 



















----- SHM ---- page 27 ---- 
Originally posted by scribly:

Lets say you've found the code that decreases your health 
Problem is that it seems to also affect the health of your opponents, and somehow you can't seem to find the basepointer. 
In those cases doing some code injection using CE's auto assembler is the easiest solution 

There are several ways code injection can help solve this problem. 
One method is finding another code that accesses your health, but does it only for your own health. (e.g the code that is used to display your current health) 
There inject some code that stores the address of your health to a address you can find back again (more on that later) 
Then in the code that decreases your health inject some code that checks if the address changes is the address stored by the other routine, if it is, skip the code, otherwhise, just decrease the health, or even create a instant kill cheat by decreasing the health of opponents by a really big value. 

Now for the auto assemble script part: 
lets say that at 00405000 is the code that reads your health: mov eax,[esi+ecx*4] 
and at 00421000 is the code that decreases the health of enemies: mov [esi+ecx*4],edx 

First allocate some memory to place your code in, and to allocate space for variables, use alloc(name,size) for that. 
Alloc allocates a region of memory with read,write and execute access. (be aware, this wont work in windows me, 98 or 95 so please upgrade if you are using those ancient os's) 
So: 
Code: 

alloc(injectHealthReader,1024) //creates a identifier called injecthealthreader that points to a block of 1024 bytes 
alloc(injectHealthWriter,1024) //2nd code cave to handle the code of the decrease health code, for easy management 
alloc(playerhealthaddress,4) //this will hold the address of health, a 4 byte value (pointer, in 64 bit this'll have to be 8 bytes) 
 



Now, write your injecthealthreader routine to store the address, and place a jump to your original code as well. dont forget that when placing a jump to your code cave keep in mind that if the instruction was larger than a jump to nop the remaining bytes, and in case of the jump being bigger than the instruction also save the other instruction, AND nop incomplete bytes. Jumps are 5 bytes. 
So in the case of "mov eax,[esi+ecx*4]" the bytecode is 8b 04 8e (3 bytes) so you'll also need to save the instruction after it. Let's say it's followed by a "mov ecx,[esi+edx*4+4]" , bytecode=8b 4c 8e 04 (4 bytes), so now we have 7 bytes to place our jump, thats more than enough. So we'll have to place 2 nops after the jump (7-5=2) 


Code: 

00405000: 
jmp InjectHealthAddress  //jump to the codecave 
nop  //nops for the lost space 
nop 
returnHealthReader:  //this is the label that is used to return to the address (so you dont have to write down 00405007 when jumping back, just to make it easy....) 


injectHealthReader: 
push eax //save eax, not really needed here since eax gets changed anyhow, but it's a good habbit to save and restore registers 
lea eax,[esi+ecx*4] //this instruction places the result of esi+ecx*4 into eax 
mov [playerhealthaddress],eax 
pop eax //restore the register, again, not needed here, but good habbit to do 

originalhealthreadercode: //label defining the original code, can be used to jump into or just skip, not needed here 
mov eax,[esi+ecx*4]  //read health 
mov ecx,[esi+edx*4+4] //read something else, my gues, armor 

jmp returnHealthReader //jump back to the original game code, when done successfull, it wont crash... 
 


As you see to specify a exact address just type it in ended with a ':' . Everything you type in after that will get assembled on and after that address (the jump and nops in this case, and the definition of the returnHealthReader:, which is in it's own turn also a address specifier, but doesn't change the current address) 

This code introduces labels, they are basicly identifiers specifying a address where thay have been placed. 
you can't just use a label though, you'll first have to declare it using the label(labelname) function. I usually declare labels right after the part where I alloc memory. 

so, right after the alloc I have this code to get the code above working: 
Code: 

label(returnHealthReader) //tell the assembler than returnHealthReader is a valid identifier, so dont bug out 
label(originalhealthreadercode) //same as above 
 


now when you run the game the address of your health will get stored into the location of playerhealthaddress. 
You can already use this with cheat engine, because the auto assembler will tell you the address, but the allocation will change each time, so making a table for other people won't work, they'd have to fill in the address each time themselves. (I dont find that a problem but somehow some people do....) 



So, let's automate it a little further and use the knowledge of your healthaddress to make yourself invulnerable, but not your oponents. 
Just like the injection for the code that reads your health you can do the same for that that decreases health. 
And you can put it in the same script as the injection for the reader, as you saw in the alloc part where I already allocated space for the injection for the health decreaser (so you dont have to edit the address the other script allocated) 

so, write scriptcode that places a jump over the code that decreases your health, in this case "mov [esi+ecx*4],edx" which has bytecode 89 14 8e (3 bytes), too small, so find a instruction before or after thats also suitable, in this case there's a sub edx,eax just before this instruction, its bytecode is 29 c2 (2 bytes) so a perfect fit (5 bytes, so no need to nop), and even easier to make a code injection for (else I'd have to use a label between the 2 instructions to just skip the original line, but this sub edx,eax line is used to decrease as well, and doesn't change any of the locator addresses, and useless for the rest, so it doesn't hurt to skip it as well) 

so to inject your routine that checks if this is your health or not and if so, dont decrease do: 
Code: 

00421000: 
jmp injectHealthWriter 
returnHealthWriter: //just declare it here, it'll get address 00421005, so a jmp returnHealthWriter will get converted to jmp 00421005 


injectHealthWriter: 
//do a check if esi+ecx*4 matches the address stored in playerhealthaddress 
//if it matches, skip the original code, if it doesn't just execute it 

//save the registers we use, and before I forget, do not touch esp between saving and restoring the registers unless 
//it's to read something(like parameters), in which case you'll have to adjust the offset 
//also, dont change the registers that you use to find the address 
push eax 
push ebx 
mov eax,[playerhealthaddress] 
lea ebx,[esi+ecx*4] 
cmp eax,ebx 

je itstheplayer 

//not the player 
pop ebx //I think I could have doen this before the je, but better safe than sorry 
pop eax 
jmp originaldecreasehealthcode 


itstheplayer: 
pop ebx //restore the registers, keep in mind to restore the registers in reverse order 
pop eax 
jmp returnHealthWriter //dont execute the original code, return imeadiatly 

originaldecreasehealthcode: 
sub edx,eax 
mov [esi+ecx*4],edx 
jmp returnHealthWriter 
 


again, I used a few labels to make it easier for me 
but, that also means I'd have to declare them, else the assembler will complain it doesn't recognize them 
so: 
Code: 

label(returnHealthWriter) 
label(itstheplayer) 
label(originaldecreasehealthcode) 
 


and I prefer adding declarations at the top. 
















So, the complete auto assembler script would look like: 
Code: 

alloc(injectHealthReader,1024) //creates a identifier called injecthealthreader that points to a block of 1024 bytes 
alloc(injectHealthWriter,1024) //2nd code cave to handle the code of the decrease health code, for easy management 
alloc(playerhealthaddress,4) //this will hold the address of health, a 4 byte value (pointer, in 64 bit this'll have to be 8 bytes) 
label(returnHealthReader) //tell the assembler than returnHealthReader is a valid identifier, so dont bug out 
label(originalhealthreadercode) //same as above 
label(returnHealthWriter) 
label(itstheplayer) 
label(originaldecreasehealthcode) 


//---------------------------------------- 
//              Healthreader 
//---------------------------------------- 
00405000: 
jmp InjectHealthAddress  //jump to the codecave 
nop  //nops for the lost space 
nop 
returnHealthReader:  //this is the label that is used to return to the address (so you dont have to write down 00405007 when jumping back, just to make it easy....) 


injectHealthReader: 
push eax //save eax, not really needed here since eax gets changed anyhow, but it's a good habbit to save and restore registers 
lea eax,[esi+ecx*4] //this instruction places the result of esi+ecx*4 into eax 
mov [playerhealthaddress],eax 
pop eax //restore the register, again, not needed here, but good habbit to do 

originalhealthreadercode: //label defining the original code, can be used to jump into or just skip, not needed here 
mov eax,[esi+ecx*4]  //read health 
mov ecx,[esi+edx*4+4] //read something else, my gues, armor 

jmp returnHealthReader //jump back to the original game code, when done successfull, it wont crash... 



//---------------------------------------- 
//           Health decreaser 
//---------------------------------------- 



00421000: 
jmp injectHealthWriter  //overwrite the original code with a jump. 
returnHealthWriter: //just declare it here, it'll get address 00421005, so a jmp returnHealthWriter will get converted to jmp 00421005 


injectHealthWriter: 
//do a check if esi+ecx*4 matches the address stored in playerhealthaddress 
//if it matches, skip the original code, if it doesn't just execute it 

//save the registers we use, and before I forget, do not touch esp between saving and restoring the registers unless 
//it's to read something(like parameters), in which case you'll have to adjust the offset 
//also, dont change the registers that you use to find the address 
push eax 
push ebx 
mov eax,[playerhealthaddress] 
lea ebx,[esi+ecx*4] 
cmp eax,ebx 

je itstheplayer 

//not the player 
pop ebx //I think I could have doen this before the je, but better safe than sorry 
pop eax 
jmp originaldecreasehealthcode 


itstheplayer: 
pop ebx //restore the registers, keep in mind to restore the registers in reverse order 
pop eax 
jmp returnHealthWriter //dont execute the original code, return imeadiatly 

originaldecreasehealthcode: 
sub edx,eax 
mov [esi+ecx*4],edx 
jmp returnHealthWriter 


 


Please be aware that I havn't tested this in ce yet, I've been writing this in notepad on a pc that doesnt have ce installed, so there may be a few syntax errors, and some of the code I've written can surely be optimised, but I hope you get the general idea. 

Also, there's a bug in ce 5.0 where you can't use small identiers that can apear in the name of another identifier. (e.g weirdmemlocxxx and memloc can't be used at the same time, because memloc fits in weirdmemlocxxx) 
But if you use normal names for identifiers this wont couse a problem, and I recommend identifiers of more than 4 characters, else it may happen you get the name of a assembler instruction and accidentally overwrite that when used. 

_____________________
 
The other method of using code injection is finding if there are differences between the player data and opponent data. 
Lets say that if it's the player [esi+ecx*4+14] contains a 1 otherwhise a 0. you can then do a check if that is set or not, if so, skip, otherwhise, decrease health 

Code: 

alloc(injectHealthWriter,1024) //2nd code cave to handle the code of the decrease health code, for easy management 
label(returnHealthWriter) 
label(itstheplayer) 
label(originaldecreasehealthcode) 


//---------------------------------------- 
//           Health decreaser 
//---------------------------------------- 



00421000: 
jmp injectHealthWriter  //overwrite the original code with a jump. 
returnHealthWriter: //just declare it here, it'll get address 00421005, so a jmp returnHealthWriter will get converted to jmp 00421005 


injectHealthWriter: 
push eax 
mov eax,[esi+ecx*4+14] 
cmp eax,1 
je itstheplayer 

//not the player 
pop eax 
jmp originaldecreasehealthcode 


itstheplayer: 
pop eax //restore the register 
jmp returnHealthWriter //dont execute the original code, return imeadiatly 

originaldecreasehealthcode: 
sub edx,eax 
mov [esi+ecx*4],edx 
jmp returnHealthWriter 
 
 
 
----- SHM ---- page 28 ---- 
Originally posted by Smidge204

When searching for a value in memory using the scan, here are a few pointers to find the value quickly: 

1) If the value is known, but the format is not (ie: Byte, 2 Bytes, 4 Bytes...) search for the smallest type that will hold the data. 

For example, if the value you want is 60, search for bytes. If the value is 1224, search for 2 Byte values, etc. The idea being that if the actual format is larger (You searched for 2 byte values but it's actually a 4 byte values) then the other bytes would be 0 anyway and the value would still be found. 

But if you search for a 4 byte value when it's really less, you might never find it because you're reading nearby bytes as well that might screw up your search! 


2) If the value is unknown, use the "Unknown initial value" scan along with method 1 (ie: always use bytes unless you happen to know it's size). Then do something that changes it's value. 

Once the value has changed, repeat the scan using "Changed values". This will filter out all the crap. 

Now go back into the game and do a bunch of stuff that DOESN'T change the value, if possible. Now repeat the scan for "Unchanged values". This will filter out stuff like position values, timers and counters. 

Keep repeating until you've widdled down the searches to a managable amount, then add all the results to your list and keep an eye on them as the game runs. Remove anything that changes when it logically shouldn't. Anything that's left, try plugging in random values and see if something happens! 


3) If you've found a bunch of good values, and youre looking for information that is somewhat related (Such as Lives and money, or whatever) , try restricting your search range to within a few kilobytes of the known value either way. This is especially powerful when looking for values in tables (High score list, for example) since they tend to be right next to eachother. 


4) Use "Bigger than" and "Smaller than" as often as possible, especially after scans for changed or unchanged values. This can generally wittle down the results pretty fast. 


5) Use arrays to peek at multiple byte values at once. Useful for detecing patterns! 



6) Sometimes string values are not stored as ASCII strings, so the "Text" search doesn't work. For example, "A" might be stored as 0x01 instead of 41. If that's the case, and you have control over the value in-game (character name?) then try these steps: 

-Set the character name 
-Search for "Unknown initial value" 
-Change name 
-Search for "Changed values" 
(Repeat above two steps to eliminate as much junk as possible. See also tip #2) 
-Change name to all the same characters. ie: "AAAAAAA". Try to max out the space you're given. 
-Search one more time for changed values. If you've increased the number of displayed results enough to get a list, scroll down and see if you have a bunch of consecutive memory locations that have the same value. (Should be the same as the length of the string!) 
-Add the first address to your list as an array equal to the length of the string you entered. 
-Change name to an easily identifiable pattern. ie: "ABCDEFG" 
-See if the bytes in your array changed to a similar pattern. If so, start mapping the characters to their values and you're done! 

Once you have the character map, you can use it to "translate" other text you couldn't find before. Simply search for an array of bytes and enter in the expected values of each letter in order. 


Hope that helps! 
=SMidge=
----- SHM ---- page 29 ---- 
Originally posted by Zhoul:

*Pre-Req!!! Windows XP Professional - (Not Home) - Upgraded to SP2. Worry not, hacked TCPIP DLL's are talked about below.* 

When I first started using cheat engine, I thought it was fantastic! I hated to have to alt+tab, and am usually using 2 PC's anyhow, so I loved the fact that it came with a network client. 

The problem(s)? The network client didn't do as good a job, because when I tried to do things like 'See what writes to this value', It would usually end up crashing my game, mostly the very first time I tried doing it. The network client also had more bugs and lacked the newer features. 

I fiddled with the settings *a lot*, trying to see if it was something I was doing wrong, or a config option that wasn't set properly. To no avail. 

I then launched a massive search for another software/debugger that had a network client, but stumbled upon something I think is a lot better. 

Basically, Microsoft messed around with giving us concurrent remote desktop + console sessions. Meaning: The ability to be logged into the console, and still connect remotely, without logging the console session out. They scrapped the idea later, because of licensing. They had released termserv.dll in a beta version of SP2, and of course, it was preserved by techies everywhere. 

I quickly installed the new termserv.dll, grinning from ear to ear, rebooted my PC, then tried to login remotely. 

Ack! Console session was logged out! Ahh!!! I get it... the same user cannot login twice. So I created a 2nd admin account, and that solved *that* problem. 

I then loaded up a game on my main PC and remote desktop'd to it, and loaded up cheat engine on the other. 

ACK!! User wasn't allowed to debug?! 

I quickly loaded up gpedit.msc and navigated its non-logical tree structure and finally found an option that lets you specify who has rights to debug programs (Computer Configuration > Windows Settings > Security Settings > Local Policies > User Rights Access > Debug programs). Gave my new user rights to debug then tried again. 

ACK! I still wasn't allowed to 'connect' to my game, as microsoft does not allow us to 'peek' into a process that was run by another user. 

Yet another hurdle I soon passed over, by using a command known as "RunAs". I had to run Cheat Engine.exe AS the console user. I figured this out quite quickly, because I already use it to run internet explorer as a 'guest' account (I'll tell ya, doing that beats out any spyware/virus scanner I've ever used.) 

--------------------------------------------------------------------- 
To sum up what is needed: 

- Windows XP PROFESSIONAL with SP2 installed (this is a must. I didn't want to go to SP2, but had to. This termserv.dll will *NOT* work with XPSP1). 
- Install the termserv.dll which is linked at the bottom of this post, or find an installer version of it via google. 
- Make sure the service "Fast User Switching" is enabled. Usually is by default, but some of us like to slim down XP to essential processes, and this is notoriously disabled by folks like us (and notoriously the reason people can't get concurrent terminal services working). 
- Create a 2nd administrator account and MAKE SURE to login as that user locally, before you try to do it via remote desktop. New users aren't entirely 'created' until their first login. 
- Load gpedit.msc (from start>run), and give your new user access to debug programs. (Computer Configuration > Windows Settings > Security Settings > Local Policies > User Rights Access > Debug programs). 
- Login via remote desktop, as your new user. 
- Create an icon for cheat engine, that does something like this... 
runas.exe /savecred /profile /user:"MyConsoleSession" "J:\Games\Cheat Engine\Cheat Engine.exe" 
--------------------------------------------------------------------- 

Of course, replace "MyConsoleSession" with the username that you use to login to the console with. In my case, Zoultan was the console/original username, Zoultan2 was the remote desktop session, so I would put Zoultan where MyConsoleSession is. 

Also, change the path to cheat engine.exe  

The good thing about runas, is the /savecred switch. The first time you run it, you will be prompted for the password. This will be saved and not asked for again. 


I run things as other users a lot, so I created a batch file to do so, then placed it in C:\Windows\System32. You don't need this to use cheat engine, but I'll pass it out for those who are interested in it. 

------------ START - Cut below this line but not the line itself ------------ 
@echo off 
set Uname=Zoultan 

set Arg=%1 
SHIFT 

:parseArgs 
if "%1" == "" goto RunAz 
set Arg=%Arg% %1 
SHIFT 
goto parseArgs 


:RunAz 
If NOT DEFINED Arg ( 
echo. 
echo No program or paramaters were specified. 
echo. 
goto End 
) 

rem The following 2 lines were placed here, to handle .msc's as if they were EXE's. I was tired of having to run mmc.exe <whatever.msc>. 
set ArgPart=%Arg:"=% 
set ArgPart=%ArgPart:~-3% 
if "%ArgPart%" == "msc" set Arg=%windir%\system32\MMC.exe %Arg% 

echo. 
echo. 
echo. 
echo Running [ %Arg% ] As [ %Uname% ] 
echo Command: runas.exe /savecred /profile /user:"%Uname%" "%Arg%" 
runas.exe /savecred /profile /user:"%Uname%" "%Arg%"|rem 
echo. 
echo. 
if NOT "%errorlevel%" == "0" echo There has been an error while trying to run %Arg% as %UName% 
goto End 


:END 
set Arg= 
set ArgPart= 
set Uname= 
ping -n 5 127.0.0.1|rem 
------------ END - Cut above this line but not the line itself ------------ 

Of course, you would change the set Uname=Zoultan line to match the user you want to runas. It could even be changed to accept the username via command line, but this was written specifically to launch as 1 user (and I created 2 other batch files for my other users). 

All my CE icons are setup like so... 
Z.bat "J:\Games\Cheat Engine 1\Cheat engine.exe" 
Z.bat "J:\Games\Cheat Engine 2\Cheat engine.exe" 
etc... etc... etc... 

Another reason I setup this .bat is so I could run things like task manager from my remote desktop session. Even though a remote admin can kill another admins processes, they can't do things like "Set Affinity", etc. So when I'm disallowed the ability to do something, I just use z <command> to launch the program, and voila' 

You can also run things like regedit.exe , from console, as your remote desktop user, if you're g33ky enough to want to change other users settings without having to login as that user. 

Lastly: If you're curious why the .bat file pings 127.0.0.1 (local host)... XP didn't come with a wait or sleep command. Therefore, in my batch files, I use ping and re-direct its output to rem (null essentially). What this does, is leaves the dos window up for 5 seconds, so I can catch the success/error messages, without having to use pause. 

Remote Desktop Terminal Services Hack: 
http://sig9.com/articles/concurrent-remote-desktop 

If this link doesn't work in the future, then use google, and search for... 
xp sp2 terminal services hack 
There is hella-documentation on this ... undocumented feature =) 

- Zhoul
