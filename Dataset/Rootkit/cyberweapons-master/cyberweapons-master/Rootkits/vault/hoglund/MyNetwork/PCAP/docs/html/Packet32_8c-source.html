<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Packet32.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Packet32.c</h1><a href="Packet32_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999, 2000</span>
00003 <span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the Politecnico</span>
00013 <span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> */</span>
00021 
<a name="l00022"></a><a class="code" href="Packet32_8c.html#a0">00022</a> <span class="preprocessor">#define UNICODE 1</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;packet32.h&gt;</span>
00025 
00026 <span class="preprocessor">#include &lt;windows.h&gt;</span>
00027 <span class="preprocessor">#include &lt;windowsx.h&gt;</span>
00028 
00029 <span class="preprocessor">#include &lt;ntddndis.h&gt;</span>
00030 
00031 
<a name="l00033"></a><a class="code" href="Packet32_8c.html#a3">00033</a> TCHAR   <a class="code" href="Packet32_8c.html#a3">szWindowTitle</a>[] = TEXT(<span class="stringliteral">"PACKET.DLL"</span>);
00034 
00035 <span class="preprocessor">#if _DBG</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define ODS(_x) OutputDebugString(TEXT(_x))</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define ODSEx(_x, _y)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#ifdef _DEBUG_TO_FILE</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00044"></a><a class="code" href="Packet32_8c.html#a1">00044</a> <span class="preprocessor">#define ODS(_x) { \</span>
00045 <span class="preprocessor">    FILE *f; \</span>
00046 <span class="preprocessor">    f = fopen("winpcap_debug.txt", "a"); \</span>
00047 <span class="preprocessor">    fprintf(f, "%s", _x); \</span>
00048 <span class="preprocessor">    fclose(f); \</span>
00049 <span class="preprocessor">}</span>
00050 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="Packet32_8c.html#a2">00054</a> <span class="preprocessor">#define ODSEx(_x, _y) { \</span>
00055 <span class="preprocessor">    FILE *f; \</span>
00056 <span class="preprocessor">    f = fopen("winpcap_debug.txt", "a"); \</span>
00057 <span class="preprocessor">    fprintf(f, _x, _y); \</span>
00058 <span class="preprocessor">    fclose(f); \</span>
00059 <span class="preprocessor">}</span>
00060 <span class="preprocessor"></span>
00061 
00062 
00063 LONG <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(PCHAR KeyName, PCHAR FileName);
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#define ODS(_x)     </span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define ODSEx(_x, _y)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00069 <span class="preprocessor"></span>
00070 <span class="comment">//service handles</span>
<a name="l00071"></a><a class="code" href="Packet32_8c.html#a4">00071</a> SC_HANDLE <a class="code" href="Packet32_8c.html#a4">scmHandle</a> = NULL;
<a name="l00072"></a><a class="code" href="Packet32_8c.html#a5">00072</a> SC_HANDLE <a class="code" href="Packet32_8c.html#a5">srvHandle</a> = NULL;
<a name="l00073"></a><a class="code" href="Packet32_8c.html#a6">00073</a> LPCTSTR <a class="code" href="Packet32_8c.html#a6">NPFServiceName</a> = TEXT(<span class="stringliteral">"NPF"</span>);
<a name="l00074"></a><a class="code" href="Packet32_8c.html#a7">00074</a> LPCTSTR <a class="code" href="Packet32_8c.html#a7">NPFServiceDesc</a> = TEXT(<span class="stringliteral">"Netgroup Packet Filter"</span>);
<a name="l00075"></a><a class="code" href="Packet32_8c.html#a8">00075</a> LPCTSTR <a class="code" href="Packet32_8c.html#a8">NPFRegistryLocation</a> = TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Services\\NPF"</span>);
<a name="l00076"></a><a class="code" href="Packet32_8c.html#a9">00076</a> LPCTSTR <a class="code" href="Packet32_8c.html#a9">NPFDriverPath</a> = TEXT(<span class="stringliteral">"system32\\drivers\\npf.sys"</span>);
00077 
00078 <span class="comment">//---------------------------------------------------------------------------</span>
00079 
<a name="l00084"></a><a class="code" href="Packet32_8c.html#a12">00084</a> BOOL APIENTRY <a class="code" href="Packet32_8c.html#a12">DllMain</a> (HANDLE DllHandle,DWORD Reason,LPVOID lpReserved)
00085 {
00086     BOOLEAN Status=TRUE;
00087 
00088     <span class="keywordflow">switch</span> ( Reason )
00089     {
00090     <span class="keywordflow">case</span> DLL_PROCESS_ATTACH:
00091         
00092         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"************Packet32: DllMain************\n"</span>);
00093         
00094 <span class="preprocessor">#ifdef _DEBUG_TO_FILE</span>
00095 <span class="preprocessor"></span>        <span class="comment">// dump a bunch of registry keys useful for debug to file</span>
00096         <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(<span class="stringliteral">"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"</span>,
00097             <span class="stringliteral">"adapters.reg"</span>);
00098         <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(<span class="stringliteral">"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip"</span>,
00099             <span class="stringliteral">"tcpip.reg"</span>);
00100         <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(<span class="stringliteral">"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NPF"</span>,
00101             <span class="stringliteral">"npf.reg"</span>);
00102         <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(<span class="stringliteral">"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services"</span>,
00103             <span class="stringliteral">"services.reg"</span>);
00104 <span class="preprocessor">#endif</span>
00105 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00106 
00107         <span class="keywordflow">case</span> DLL_PROCESS_DETACH:
00108             <span class="keywordflow">break</span>;
00109 
00110         <span class="keywordflow">default</span>:
00111             <span class="keywordflow">break</span>;
00112     }
00113 
00114     <span class="keywordflow">return</span> Status;
00115 }
00116 
<a name="l00123"></a><a class="code" href="Packet32_8c.html#a13">00123</a> WCHAR* <a class="code" href="Packet32_8c.html#a13">SChar2WChar</a>(<span class="keywordtype">char</span>* string)
00124 {
00125     WCHAR* TmpStr;
00126     TmpStr=(WCHAR*) malloc ((strlen(string)+2)*<span class="keyword">sizeof</span>(WCHAR));
00127 
00128     MultiByteToWideChar(CP_ACP, 0, string, -1, TmpStr, (strlen(string)+2));
00129 
00130     <span class="keywordflow">return</span> TmpStr;
00131 }
00132 
<a name="l00142"></a><a class="code" href="Packet32_8c.html#a14">00142</a> BOOLEAN <a class="code" href="Packet32_8c.html#a14">PacketSetMaxLookaheadsize</a> (<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject)
00143 {
00144     BOOLEAN    Status;
00145     ULONG      IoCtlBufferLength=(<span class="keyword">sizeof</span>(PACKET_OID_DATA)+<span class="keyword">sizeof</span>(ULONG)-1);
00146     <a class="code" href="group__packet32h.html#a5">PPACKET_OID_DATA</a>  OidData;
00147 
00148     OidData=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,IoCtlBufferLength);
00149     <span class="keywordflow">if</span> (OidData == NULL) {
00150         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketSetMaxLookaheadsize failed\n"</span>);
00151         <span class="keywordflow">return</span> FALSE;
00152     }
00153 
00154     <span class="comment">//set the size of the lookahead buffer to the maximum available by the the NIC driver</span>
00155     OidData-&gt;Oid=OID_GEN_MAXIMUM_LOOKAHEAD;
00156     OidData-&gt;Length=<span class="keyword">sizeof</span>(ULONG);
00157     Status=<a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(AdapterObject,FALSE,OidData);
00158     OidData-&gt;Oid=OID_GEN_CURRENT_LOOKAHEAD;
00159     Status=<a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(AdapterObject,TRUE,OidData);
00160     GlobalFreePtr(OidData);
00161     <span class="keywordflow">return</span> Status;
00162 }
00163 
<a name="l00174"></a><a class="code" href="Packet32_8c.html#a15">00174</a> BOOLEAN <a class="code" href="Packet32_8c.html#a15">PacketSetReadEvt</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject)
00175 {
00176     DWORD BytesReturned;
00177     TCHAR EventName[39];
00178 
00179     <span class="comment">// this tells the terminal service to retrieve the event from the global namespace</span>
00180     wcsncpy(EventName,L<span class="stringliteral">"Global\\"</span>,<span class="keyword">sizeof</span>(L<span class="stringliteral">"Global\\"</span>));
00181 
00182     <span class="comment">// retrieve the name of the shared event from the driver</span>
00183     <span class="keywordflow">if</span>(DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCEVNAME,NULL,0,EventName+7,13*<span class="keyword">sizeof</span>(TCHAR),&amp;BytesReturned,NULL)==FALSE) <span class="keywordflow">return</span> FALSE;
00184 
00185     EventName[20]=0; <span class="comment">// terminate the string</span>
00186 
00187     <span class="comment">// open the shared event</span>
00188     AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>=CreateEvent(NULL,
00189                                          TRUE,
00190                                          FALSE,
00191                                          EventName);
00192 
00193     <span class="comment">// in NT4 "Global\" is not automatically ignored: try to use simply the event name</span>
00194     <span class="keywordflow">if</span>(GetLastError()!=ERROR_ALREADY_EXISTS){
00195         <span class="keywordflow">if</span>(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a> != NULL)
00196             CloseHandle(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>);
00197         
00198         <span class="comment">// open the shared event</span>
00199         AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>=CreateEvent(NULL,
00200             TRUE,
00201             FALSE,
00202             EventName+7);
00203     }   
00204 
00205     <span class="keywordflow">if</span>(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>==NULL || GetLastError()!=ERROR_ALREADY_EXISTS){
00206         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketSetReadEvt: error retrieving the event from the kernel\n"</span>);
00207         <span class="keywordflow">return</span> FALSE;
00208     }
00209 
00210     AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m4">ReadTimeOut</a>=0;
00211 
00212     <span class="keywordflow">return</span> TRUE;
00213 }
00214 
<a name="l00224"></a><a class="code" href="Packet32_8c.html#a16">00224</a> BOOL <a class="code" href="Packet32_8c.html#a16">PacketInstallDriver</a>(SC_HANDLE ascmHandle,SC_HANDLE *srvHandle)
00225 {
00226     BOOL result = FALSE;
00227     ULONG err;
00228     
00229     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"installdriver\n"</span>);
00230     
00231     *<a class="code" href="Packet32_8c.html#a5">srvHandle</a> = CreateService(ascmHandle, 
00232         NPFServiceName,
00233         NPFServiceDesc,
00234         SERVICE_ALL_ACCESS,
00235         SERVICE_KERNEL_DRIVER,
00236         SERVICE_DEMAND_START,
00237         SERVICE_ERROR_NORMAL,
00238         NPFDriverPath,
00239         NULL, NULL, NULL, NULL, NULL);
00240     <span class="keywordflow">if</span> (*<a class="code" href="Packet32_8c.html#a5">srvHandle</a> == NULL) 
00241     {
00242         <span class="keywordflow">if</span> (GetLastError() == ERROR_SERVICE_EXISTS) 
00243         {
00244             <span class="comment">//npf.sys already existed</span>
00245             result = TRUE;
00246         }
00247     }
00248     <span class="keywordflow">else</span> 
00249     {
00250         <span class="comment">//Created service for npf.sys</span>
00251         result = TRUE;
00252     }
00253     <span class="keywordflow">if</span> (result == TRUE) 
00254         <span class="keywordflow">if</span> (*<a class="code" href="Packet32_8c.html#a5">srvHandle</a> != NULL)
00255             CloseServiceHandle(*srvHandle);
00256 
00257     <span class="keywordflow">if</span>(result == FALSE){
00258         err = GetLastError();
00259         <span class="keywordflow">if</span>(err != 2)
00260             <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketInstallDriver failed, Error=%d\n"</span>,err);
00261     }
00262     <span class="keywordflow">return</span> result;
00263     
00264 }
00265 
<a name="l00275"></a><a class="code" href="Packet32_8c.html#a17">00275</a> ULONG <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(<span class="keyword">const</span> WCHAR *cp)
00276 {
00277     ULONG <a class="code" href="gencode_8c.html#a63">val</a>, part;
00278     WCHAR c;
00279     <span class="keywordtype">int</span> i;
00280 
00281     <a class="code" href="gencode_8c.html#a63">val</a> = 0;
00282     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
00283         part = 0;
00284         <span class="keywordflow">while</span> ((c = *cp++) != <span class="charliteral">'\0'</span> &amp;&amp; c != <span class="charliteral">'.'</span>) {
00285             <span class="keywordflow">if</span> (c &lt; '0' || c &gt; <span class="charliteral">'9'</span>)
00286                 <span class="keywordflow">return</span> -1;
00287             part = part*10 + (c - <span class="charliteral">'0'</span>);
00288         }
00289         <span class="keywordflow">if</span> (part &gt; 255)
00290             <span class="keywordflow">return</span> -1;  
00291         <a class="code" href="gencode_8c.html#a63">val</a> = <a class="code" href="gencode_8c.html#a63">val</a> | (part &lt;&lt; i*8);
00292         <span class="keywordflow">if</span> (i == 3) {
00293             <span class="keywordflow">if</span> (c != <span class="charliteral">'\0'</span>)
00294                 <span class="keywordflow">return</span> -1;  <span class="comment">// extra gunk at end of string </span>
00295         } <span class="keywordflow">else</span> {
00296             <span class="keywordflow">if</span> (c == <span class="charliteral">'\0'</span>)
00297                 <span class="keywordflow">return</span> -1;  <span class="comment">// string ends early </span>
00298         }
00299     }
00300     <span class="keywordflow">return</span> <a class="code" href="gencode_8c.html#a63">val</a>;
00301 }
00302 
00312 <span class="preprocessor">#ifdef _DEBUG_TO_FILE</span>
00313 <span class="preprocessor"></span>
<a name="l00314"></a><a class="code" href="Packet32_8c.html#a11">00314</a> LONG <a class="code" href="Packet32_8c.html#a11">PacketDumpRegistryKey</a>(PCHAR KeyName, PCHAR FileName)
00315 {
00316     CHAR Command[256];
00317 
00318     strcpy(Command, <span class="stringliteral">"regedit /e "</span>);
00319     strcat(Command, FileName);
00320     strcat(Command, <span class="stringliteral">" "</span>);
00321     strcat(Command, KeyName);
00322 
00324     system(Command);
00325 
00326     <span class="keywordflow">return</span> TRUE;
00327 }
00328 <span class="preprocessor">#endif</span>
00329 <span class="preprocessor"></span>
00330 <span class="comment">//---------------------------------------------------------------------------</span>
00331 <span class="comment">// PUBLIC API</span>
00332 <span class="comment">//---------------------------------------------------------------------------</span>
00333 
00342 
<a name="l00343"></a><a class="code" href="group__packet32.html#a0">00343</a> <span class="keywordtype">char</span> <a class="code" href="group__packet32.html#a0">PacketLibraryVersion</a>[] = <span class="stringliteral">"3.0 alpha3"</span>; 
00344 
<a name="l00349"></a><a class="code" href="Packet32_8c.html#a18">00349</a> PCHAR <a class="code" href="group__packet32.html#a18">PacketGetVersion</a>(){
00350     <span class="keywordflow">return</span> <a class="code" href="group__packet32.html#a0">PacketLibraryVersion</a>;
00351 }
00352 
<a name="l00369"></a><a class="code" href="Packet32_8c.html#a19">00369</a> BOOLEAN <a class="code" href="Packet32_8c.html#a19">PacketGetNetType</a> (<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<a class="code" href="structNetType.html">NetType</a> *type)
00370 {
00371     BOOLEAN    Status;
00372     ULONG      IoCtlBufferLength=(<span class="keyword">sizeof</span>(PACKET_OID_DATA)+<span class="keyword">sizeof</span>(ULONG)-1);
00373     <a class="code" href="group__packet32h.html#a5">PPACKET_OID_DATA</a>  OidData;
00374 
00375     OidData=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,IoCtlBufferLength);
00376     <span class="keywordflow">if</span> (OidData == NULL) {
00377         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetNetType failed\n"</span>);
00378         <span class="keywordflow">return</span> FALSE;
00379     }
00380     <span class="comment">//get the link-layer type</span>
00381     OidData-&gt;Oid = OID_GEN_MEDIA_IN_USE;
00382     OidData-&gt;Length = <span class="keyword">sizeof</span> (ULONG);
00383     Status = <a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(AdapterObject,FALSE,OidData);
00384     type-&gt;<a class="code" href="structNetType.html#m0">LinkType</a>=*((UINT*)OidData-&gt;Data);
00385 
00386     <span class="comment">//get the link-layer speed</span>
00387     OidData-&gt;Oid = OID_GEN_LINK_SPEED;
00388     OidData-&gt;Length = <span class="keyword">sizeof</span> (ULONG);
00389     Status = <a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(AdapterObject,FALSE,OidData);
00390     type-&gt;<a class="code" href="structNetType.html#m1">LinkSpeed</a>=*((UINT*)OidData-&gt;Data)*100;
00391     GlobalFreePtr (OidData);
00392 
00393     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Media:%d "</span>,type-&gt;<a class="code" href="structNetType.html#m0">LinkType</a>);
00394     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Speed=%d\n"</span>,type-&gt;<a class="code" href="structNetType.html#m1">LinkSpeed</a>);
00395 
00396     <span class="keywordflow">return</span> Status;
00397 }
00398 
<a name="l00407"></a><a class="code" href="Packet32_8c.html#a20">00407</a> BOOL <a class="code" href="group__packet32.html#a20">PacketStopDriver</a>()
00408 {
00409     SC_HANDLE       <a class="code" href="Packet32_8c.html#a4">scmHandle</a>;
00410     SC_HANDLE       schService;
00411     BOOL            ret;
00412     SERVICE_STATUS  serviceStatus;
00413 
00414     <a class="code" href="Packet32_8c.html#a4">scmHandle</a> = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
00415     
00416     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a4">scmHandle</a> != NULL){
00417         
00418         schService = OpenService (scmHandle,
00419             NPFServiceName,
00420             SERVICE_ALL_ACCESS
00421             );
00422         
00423         <span class="keywordflow">if</span> (schService != NULL)
00424         {
00425             
00426             ret = ControlService (schService,
00427                 SERVICE_CONTROL_STOP,
00428                 &amp;serviceStatus
00429                 );
00430             <span class="keywordflow">if</span> (!ret)
00431             {
00432             }
00433             
00434             CloseServiceHandle (schService);
00435             
00436             CloseServiceHandle(scmHandle);
00437             
00438             <span class="keywordflow">return</span> ret;
00439         }
00440     }
00441     
00442     <span class="keywordflow">return</span> FALSE;
00443 
00444 }
00445 
<a name="l00468"></a><a class="code" href="Packet32_8c.html#a21">00468</a> <a class="code" href="struct__ADAPTER.html">LPADAPTER</a> <a class="code" href="Packet32_8c.html#a21">PacketOpenAdapter</a>(LPTSTR AdapterName)
00469 {
00470     <a class="code" href="struct__ADAPTER.html">LPADAPTER</a> lpAdapter;
00471     BOOLEAN Result;
00472     <span class="keywordtype">char</span> *AdapterNameA;
00473     WCHAR *AdapterNameU;
00474     DWORD error;
00475     SC_HANDLE svcHandle = NULL;
00476     LONG KeyRes;
00477     HKEY PathKey;
00478     SERVICE_STATUS SStat;
00479     BOOLEAN QuerySStat;
00480     WCHAR SymbolicLink[128];
00481 
00482     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketOpenAdapter: trying to open the adapter=%S\n"</span>,AdapterName)
00483 
00484     <a class="code" href="Packet32_8c.html#a4">scmHandle</a> = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
00485     
00486     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a4">scmHandle</a> == NULL){
00487         error = GetLastError();
00488         <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"OpenSCManager failed! Error=%d\n"</span>, error);
00489     }
00490     <span class="keywordflow">else</span>{
00491         <span class="comment">// check if the NPF registry key is already present</span>
00492         <span class="comment">// this means that the driver is already installed and that we don't need to call PacketInstallDriver</span>
00493         KeyRes=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
00494             NPFRegistryLocation,
00495             0,
00496             KEY_READ,
00497             &amp;PathKey);
00498         
00499         <span class="keywordflow">if</span>(KeyRes != ERROR_SUCCESS)
00500         {
00501             Result = <a class="code" href="Packet32_8c.html#a16">PacketInstallDriver</a>(scmHandle,&amp;svcHandle);
00502         }
00503         <span class="keywordflow">else</span>
00504         {
00505             Result = TRUE;
00506             RegCloseKey(PathKey);
00507         }
00508         
00509         <span class="keywordflow">if</span> (Result) 
00510         {
00511             
00512             <a class="code" href="Packet32_8c.html#a5">srvHandle</a> = OpenService(scmHandle, NPFServiceName, SERVICE_START | SERVICE_QUERY_STATUS );
00513             <span class="keywordflow">if</span> (<a class="code" href="Packet32_8c.html#a5">srvHandle</a> != NULL)
00514             {
00515                 QuerySStat = QueryServiceStatus(srvHandle, &amp;SStat);
00516                 <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"The status of the driver is:%d\n"</span>,SStat.dwCurrentState);
00517                 
00518                 <span class="keywordflow">if</span>(!QuerySStat || SStat.dwCurrentState != SERVICE_RUNNING)
00519                 {
00520                     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Calling startservice\n"</span>);
00521                     <span class="keywordflow">if</span> (StartService(srvHandle, 0, NULL)==0)
00522                     { 
00523                         error = GetLastError();
00524                         <span class="keywordflow">if</span>(error!=ERROR_SERVICE_ALREADY_RUNNING &amp;&amp; error!=ERROR_ALREADY_EXISTS)
00525                         {
00526                             SetLastError(error);
00527                             <span class="keywordflow">if</span> (<a class="code" href="Packet32_8c.html#a4">scmHandle</a> != NULL) 
00528                                 CloseServiceHandle(scmHandle);
00529                             error = GetLastError();
00530                             <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketOpenAdapter: StartService failed, Error=%d\n"</span>,error);
00531                             <span class="keywordflow">return</span> NULL;
00532                         }
00533                     }               
00534                 }
00535 
00536                 CloseServiceHandle( srvHandle );
00537                 <a class="code" href="Packet32_8c.html#a5">srvHandle</a> = NULL;
00538 
00539             }
00540             <span class="keywordflow">else</span>
00541             {
00542                 error = GetLastError();
00543                 <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"OpenService failed! Error=%d"</span>, error);
00544             }
00545         }
00546         <span class="keywordflow">else</span>
00547         {
00548             <span class="keywordflow">if</span>(KeyRes != ERROR_SUCCESS)
00549                 Result = <a class="code" href="Packet32_8c.html#a16">PacketInstallDriver</a>(scmHandle,&amp;svcHandle);
00550             <span class="keywordflow">else</span>
00551                 Result = TRUE;
00552             
00553             <span class="keywordflow">if</span> (Result) {
00554                 
00555                 <a class="code" href="Packet32_8c.html#a5">srvHandle</a> = OpenService(scmHandle,NPFServiceName,SERVICE_START);
00556                 <span class="keywordflow">if</span> (<a class="code" href="Packet32_8c.html#a5">srvHandle</a> != NULL){
00557                     
00558                     QuerySStat = QueryServiceStatus(srvHandle, &amp;SStat);
00559                     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"The status of the driver is:%d\n"</span>,SStat.dwCurrentState);
00560                     
00561                     <span class="keywordflow">if</span>(!QuerySStat || SStat.dwCurrentState != SERVICE_RUNNING){
00562                         
00563                         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Calling startservice\n"</span>);
00564                         
00565                         <span class="keywordflow">if</span> (StartService(srvHandle, 0, NULL)==0){ 
00566                             error = GetLastError();
00567                             <span class="keywordflow">if</span>(error!=ERROR_SERVICE_ALREADY_RUNNING &amp;&amp; error!=ERROR_ALREADY_EXISTS){
00568                                 SetLastError(error);
00569                                 <span class="keywordflow">if</span> (<a class="code" href="Packet32_8c.html#a4">scmHandle</a> != NULL) CloseServiceHandle(scmHandle);
00570                                 <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketOpenAdapter: StartService failed, Error=%d\n"</span>,error);
00571                                 <span class="keywordflow">return</span> NULL;
00572                             }
00573                         }
00574                     }
00575                     
00576                     CloseServiceHandle( srvHandle );
00577                     <a class="code" href="Packet32_8c.html#a5">srvHandle</a> = NULL;
00578 
00579                 }
00580                 <span class="keywordflow">else</span>{
00581                     error = GetLastError();
00582                     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"OpenService failed! Error=%d"</span>, error);
00583                 }
00584             }
00585         }
00586     }
00587 
00588     <span class="keywordflow">if</span> (<a class="code" href="Packet32_8c.html#a4">scmHandle</a> != NULL) CloseServiceHandle(scmHandle);
00589 
00590     AdapterNameA=(<span class="keywordtype">char</span>*)AdapterName;
00591     <span class="keywordflow">if</span>(AdapterNameA[1]!=0){ <span class="comment">//ASCII</span>
00592         AdapterNameU=<a class="code" href="Packet32_8c.html#a13">SChar2WChar</a>(AdapterNameA);
00593         AdapterName=AdapterNameU;
00594     } <span class="keywordflow">else</span> {            <span class="comment">//Unicode</span>
00595         AdapterNameU=NULL;
00596     }
00597     
00598     lpAdapter=(LPADAPTER)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,<span class="keyword">sizeof</span>(<a class="code" href="struct__ADAPTER.html">ADAPTER</a>));
00599     <span class="keywordflow">if</span> (lpAdapter==NULL)
00600     {
00601         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketOpenAdapter: GlobalAlloc Failed\n"</span>);
00602         error=GetLastError();
00603         <span class="keywordflow">if</span> (AdapterNameU != NULL) free(AdapterNameU);
00604         <span class="comment">//set the error to the one on which we failed</span>
00605         SetLastError(error);
00606         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketOpenAdapter: Failed to allocate the adapter structure\n"</span>);
00607         <span class="keywordflow">return</span> NULL;
00608     }
00609     lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m2">NumWrites</a>=1;
00610 
00611 
00612 
00613     <span class="keywordflow">if</span> (LOWORD(GetVersion()) == 4)
00614         wsprintf(SymbolicLink,TEXT(<span class="stringliteral">"\\\\.\\%s"</span>),&amp;AdapterName[8]);
00615     <span class="keywordflow">else</span>
00616         wsprintf(SymbolicLink,TEXT(<span class="stringliteral">"\\\\.\\Global\\%s"</span>),&amp;AdapterName[8]);
00617     
00618     <span class="comment">// Copy  only the bytes that fit in the adapter structure.</span>
00619     <span class="comment">// Note that lpAdapter-&gt;SymbolicLink is present for backward compatibility but will</span>
00620     <span class="comment">// never be used by the apps</span>
00621     memcpy(lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m1">SymbolicLink</a>, (PCHAR)SymbolicLink, MAX_LINK_NAME_LENGTH);
00622 
00623     <span class="comment">//try if it is possible to open the adapter immediately</span>
00624     lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>=CreateFile(SymbolicLink,GENERIC_WRITE | GENERIC_READ,
00625         0,NULL,OPEN_EXISTING,0,0);
00626     
00627     <span class="keywordflow">if</span> (lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a> != INVALID_HANDLE_VALUE) 
00628     {
00629 
00630         <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a15">PacketSetReadEvt</a>(lpAdapter)==FALSE){
00631             error=GetLastError();
00632             <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketOpenAdapter: Unable to open the read event\n"</span>);
00633             <span class="keywordflow">if</span> (AdapterNameU != NULL)
00634                 free(AdapterNameU);
00635             GlobalFreePtr(lpAdapter);
00636             <span class="comment">//set the error to the one on which we failed</span>
00637             SetLastError(error);
00638             <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketOpenAdapter: PacketSetReadEvt failed, Error=%d\n"</span>,error);
00639             <span class="keywordflow">return</span> NULL;
00640         }       
00641         
00642         <a class="code" href="Packet32_8c.html#a14">PacketSetMaxLookaheadsize</a>(lpAdapter);
00643         <span class="keywordflow">if</span> (AdapterNameU != NULL)
00644             free(AdapterNameU);
00645         <span class="keywordflow">return</span> lpAdapter;
00646     }
00647 
00648 
00649     error=GetLastError();
00650     <span class="keywordflow">if</span> (AdapterNameU != NULL)
00651         free(AdapterNameU);
00652     GlobalFreePtr(lpAdapter);
00653     <span class="comment">//set the error to the one on which we failed</span>
00654     SetLastError(error);
00655     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketOpenAdapter: CreateFile failed, Error=2,%d\n"</span>,error);
00656     <span class="keywordflow">return</span> NULL;
00657 
00658 }
00659 
<a name="l00666"></a><a class="code" href="Packet32_8c.html#a22">00666</a> VOID <a class="code" href="Packet32_8c.html#a22">PacketCloseAdapter</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> lpAdapter)
00667 {
00668     CloseHandle(lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>);
00669     SetEvent(lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>);
00670     CloseHandle(lpAdapter-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>);
00671     GlobalFreePtr(lpAdapter);
00672 }
00673 
<a name="l00686"></a><a class="code" href="Packet32_8c.html#a23">00686</a> <a class="code" href="struct__PACKET.html">LPPACKET</a> <a class="code" href="group__packet32.html#a23">PacketAllocatePacket</a>(<span class="keywordtype">void</span>)
00687 {
00688 
00689     <a class="code" href="struct__PACKET.html">LPPACKET</a>    lpPacket;
00690     lpPacket=(LPPACKET)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,<span class="keyword">sizeof</span>(<a class="code" href="struct__PACKET.html">PACKET</a>));
00691     <span class="keywordflow">if</span> (lpPacket==NULL)
00692     {
00693         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketAllocatePacket: GlobalAlloc Failed\n"</span>);
00694         <span class="keywordflow">return</span> NULL;
00695     }
00696     <span class="keywordflow">return</span> lpPacket;
00697 }
00698 
<a name="l00707"></a><a class="code" href="Packet32_8c.html#a24">00707</a> VOID <a class="code" href="Packet32_8c.html#a24">PacketFreePacket</a>(<a class="code" href="struct__PACKET.html">LPPACKET</a> lpPacket)
00708 
00709 {
00710     GlobalFreePtr(lpPacket);
00711 }
00712 
<a name="l00729"></a><a class="code" href="Packet32_8c.html#a25">00729</a> VOID <a class="code" href="Packet32_8c.html#a25">PacketInitPacket</a>(<a class="code" href="struct__PACKET.html">LPPACKET</a> lpPacket,PVOID Buffer,UINT Length)
00730 
00731 {
00732     lpPacket-&gt;<a class="code" href="struct__PACKET.html#m2">Buffer</a> = Buffer;
00733     lpPacket-&gt;<a class="code" href="struct__PACKET.html#m3">Length</a> = Length;
00734     lpPacket-&gt;<a class="code" href="struct__PACKET.html#m4">ulBytesReceived</a> = 0;
00735     lpPacket-&gt;<a class="code" href="struct__PACKET.html#m5">bIoComplete</a> = FALSE;
00736 }
00737 
<a name="l00768"></a><a class="code" href="Packet32_8c.html#a26">00768</a> BOOLEAN <a class="code" href="Packet32_8c.html#a26">PacketReceivePacket</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<a class="code" href="struct__PACKET.html">LPPACKET</a> lpPacket,BOOLEAN Sync)
00769 {
00770     BOOLEAN res;
00771 
00772     <span class="keywordflow">if</span>((int)AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m4">ReadTimeOut</a> != -1)
00773         WaitForSingleObject(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>, (AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m4">ReadTimeOut</a>==0)?INFINITE:AdapterObject-&gt;ReadTimeOut);
00774 
00775     res = ReadFile(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>, lpPacket-&gt;<a class="code" href="struct__PACKET.html#m2">Buffer</a>, lpPacket-&gt;<a class="code" href="struct__PACKET.html#m3">Length</a>, &amp;lpPacket-&gt;<a class="code" href="struct__PACKET.html#m4">ulBytesReceived</a>,NULL);
00776 
00777     <span class="keywordflow">return</span> res;
00778 }
00779 
<a name="l00809"></a><a class="code" href="Packet32_8c.html#a27">00809</a> BOOLEAN <a class="code" href="Packet32_8c.html#a27">PacketSendPacket</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<a class="code" href="struct__PACKET.html">LPPACKET</a> lpPacket,BOOLEAN Sync)
00810 
00811 {
00812     DWORD        BytesTransfered;
00813     
00814     <span class="keywordflow">return</span> WriteFile(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,lpPacket-&gt;<a class="code" href="struct__PACKET.html#m2">Buffer</a>,lpPacket-&gt;<a class="code" href="struct__PACKET.html#m3">Length</a>,&amp;BytesTransfered,NULL);
00815 }
00816 
00817 
<a name="l00845"></a><a class="code" href="Packet32_8c.html#a28">00845</a> INT <a class="code" href="Packet32_8c.html#a28">PacketSendPackets</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject, PVOID PacketBuff, ULONG Size, BOOLEAN Sync)
00846 {
00847     BOOLEAN         Res;
00848     DWORD           BytesTransfered, TotBytesTransfered=0;
00849     <span class="keyword">struct </span>timeval  BufStartTime;
00850     LARGE_INTEGER   StartTicks, CurTicks, TargetTicks, TimeFreq;
00851 
00852 
00853     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketSendPackets"</span>);
00854 
00855     <span class="comment">// Obtain starting timestamp of the buffer</span>
00856     BufStartTime.tv_sec = ((<span class="keyword">struct </span>timeval*)(PacketBuff))-&gt;tv_sec;
00857     BufStartTime.tv_usec = ((<span class="keyword">struct </span>timeval*)(PacketBuff))-&gt;tv_usec;
00858 
00859     <span class="comment">// Retrieve the reference time counters</span>
00860     QueryPerformanceCounter(&amp;StartTicks);
00861     QueryPerformanceFrequency(&amp;TimeFreq);
00862 
00863     CurTicks.QuadPart = StartTicks.QuadPart;
00864 
00865     <span class="keywordflow">do</span>{
00866         <span class="comment">// Send the data to the driver</span>
00867         Res = DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,
00868             (Sync)?pBIOCSENDPACKETSSYNC:pBIOCSENDPACKETSNOSYNC,
00869             (PCHAR)PacketBuff + TotBytesTransfered,
00870             Size - TotBytesTransfered,
00871             NULL,
00872             0,
00873             &amp;BytesTransfered,
00874             NULL);
00875 
00876         TotBytesTransfered += BytesTransfered;
00877 
00878         <span class="comment">// calculate the time interval to wait before sending the next packet</span>
00879         TargetTicks.QuadPart = StartTicks.QuadPart +
00880         (LONGLONG)
00881         ((((<span class="keyword">struct </span>timeval*)((PCHAR)PacketBuff + TotBytesTransfered))-&gt;tv_sec - BufStartTime.tv_sec) * 1000000 +
00882         (((struct timeval*)((PCHAR)PacketBuff + TotBytesTransfered))-&gt;tv_usec - BufStartTime.tv_usec)) *
00883         (TimeFreq.QuadPart) / 1000000;
00884 
00885         <span class="comment">// Exit from the loop on termination or error</span>
00886         <span class="keywordflow">if</span>(TotBytesTransfered &gt;= Size || Res != TRUE)
00887             <span class="keywordflow">break</span>;
00888         
00889         <span class="comment">// Wait until the time interval has elapsed</span>
00890         <span class="keywordflow">while</span>( CurTicks.QuadPart &lt;= TargetTicks.QuadPart )
00891             QueryPerformanceCounter(&amp;CurTicks);
00892 
00893     }
00894     <span class="keywordflow">while</span>(TRUE);
00895 
00896     <span class="keywordflow">return</span> TotBytesTransfered;
00897 }
00898 
<a name="l00917"></a><a class="code" href="Packet32_8c.html#a29">00917</a> BOOLEAN <a class="code" href="Packet32_8c.html#a29">PacketSetMinToCopy</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keywordtype">int</span> nbytes)
00918 {
00919     DWORD BytesReturned;
00920     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSMINTOCOPY,&amp;nbytes,4,NULL,0,&amp;BytesReturned,NULL);
00921 }
00922 
<a name="l00959"></a><a class="code" href="Packet32_8c.html#a30">00959</a> BOOLEAN <a class="code" href="Packet32_8c.html#a30">PacketSetMode</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keywordtype">int</span> mode)
00960 {
00961     DWORD BytesReturned;
00962 
00963     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSMODE,&amp;mode,4,NULL,0,&amp;BytesReturned,NULL);
00964 }
00965 
<a name="l00980"></a><a class="code" href="Packet32_8c.html#a31">00980</a> BOOLEAN <a class="code" href="Packet32_8c.html#a31">PacketSetDumpName</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject, <span class="keywordtype">void</span> *name, <span class="keywordtype">int</span> len)
00981 {
00982     DWORD       BytesReturned;
00983     WCHAR   *FileName;
00984     BOOLEAN res;
00985     WCHAR   NameWithPath[1024];
00986     <span class="keywordtype">int</span>     TStrLen;
00987     WCHAR   *NamePos;
00988 
00989     <span class="keywordflow">if</span>(((PUCHAR)name)[1]!=0 &amp;&amp; len&gt;1){ <span class="comment">//ASCII</span>
00990         FileName=<a class="code" href="Packet32_8c.html#a13">SChar2WChar</a>(name);
00991         len*=2;
00992     } 
00993     <span class="keywordflow">else</span> {  <span class="comment">//Unicode</span>
00994         FileName=name;
00995     }
00996 
00997     TStrLen=GetFullPathName(FileName,1024,NameWithPath,&amp;NamePos);
00998 
00999     len=TStrLen*2+2;  <span class="comment">//add the terminating null character</span>
01000 
01001     <span class="comment">// Try to catch malformed strings</span>
01002     <span class="keywordflow">if</span>(len&gt;2048){
01003         <span class="keywordflow">if</span>(((PUCHAR)name)[1]!=0 &amp;&amp; len&gt;1) free(FileName);
01004         <span class="keywordflow">return</span> FALSE;
01005     }
01006 
01007     res = DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSETDUMPFILENAME,NameWithPath,len,NULL,0,&amp;BytesReturned,NULL);
01008     free(FileName);
01009     <span class="keywordflow">return</span> res;
01010 }
01011 
<a name="l01027"></a><a class="code" href="Packet32_8c.html#a32">01027</a> BOOLEAN <a class="code" href="Packet32_8c.html#a32">PacketSetDumpLimits</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject, UINT maxfilesize, UINT maxnpacks)
01028 {
01029     DWORD       BytesReturned;
01030     UINT valbuff[2];
01031 
01032     valbuff[0] = maxfilesize;
01033     valbuff[1] = maxnpacks;
01034 
01035     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,
01036         pBIOCSETDUMPLIMITS,
01037         valbuff,
01038         <span class="keyword">sizeof</span> valbuff,
01039         NULL,
01040         0,
01041         &amp;BytesReturned,
01042         NULL);  
01043 }
01044 
<a name="l01058"></a><a class="code" href="Packet32_8c.html#a33">01058</a> BOOLEAN <a class="code" href="Packet32_8c.html#a33">PacketIsDumpEnded</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject, BOOLEAN sync)
01059 {
01060     DWORD       BytesReturned;
01061     <span class="keywordtype">int</span>     IsDumpEnded;
01062     BOOLEAN res;
01063 
01064     <span class="keywordflow">if</span>(sync)
01065         WaitForSingleObject(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>, INFINITE);
01066 
01067     res = DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,
01068         pBIOCISDUMPENDED,
01069         NULL,
01070         0,
01071         &amp;IsDumpEnded,
01072         4,
01073         &amp;BytesReturned,
01074         NULL);
01075 
01076     <span class="keywordflow">if</span>(res == FALSE) <span class="keywordflow">return</span> TRUE; <span class="comment">// If the IOCTL returns an error we consider the dump finished</span>
01077 
01078     <span class="keywordflow">return</span> (BOOLEAN)IsDumpEnded;
01079 }
01080 
<a name="l01100"></a><a class="code" href="Packet32_8c.html#a34">01100</a> HANDLE <a class="code" href="Packet32_8c.html#a34">PacketGetReadEvent</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject)
01101 {
01102     <span class="keywordflow">return</span> AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m3">ReadEvent</a>;
01103 }
01104 
<a name="l01113"></a><a class="code" href="Packet32_8c.html#a35">01113</a> BOOLEAN <a class="code" href="Packet32_8c.html#a35">PacketSetNumWrites</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keywordtype">int</span> nwrites)
01114 {
01115     DWORD BytesReturned;
01116     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSWRITEREP,&amp;nwrites,4,NULL,0,&amp;BytesReturned,NULL);
01117 }
01118 
<a name="l01131"></a><a class="code" href="Packet32_8c.html#a36">01131</a> BOOLEAN <a class="code" href="Packet32_8c.html#a36">PacketSetReadTimeout</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keywordtype">int</span> timeout)
01132 {
01133     DWORD BytesReturned;
01134     <span class="keywordtype">int</span> DriverTimeOut=-1;
01135 
01136     AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m4">ReadTimeOut</a>=timeout;
01137 
01138     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSRTIMEOUT,&amp;DriverTimeOut,4,NULL,0,&amp;BytesReturned,NULL);
01139 }
01140 
<a name="l01157"></a><a class="code" href="Packet32_8c.html#a37">01157</a> BOOLEAN <a class="code" href="Packet32_8c.html#a37">PacketSetBuff</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keywordtype">int</span> dim)
01158 {
01159     DWORD BytesReturned;
01160     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSETBUFFERSIZE,&amp;dim,4,NULL,0,&amp;BytesReturned,NULL);
01161 }
01162 
<a name="l01183"></a><a class="code" href="Packet32_8c.html#a38">01183</a> BOOLEAN <a class="code" href="Packet32_8c.html#a38">PacketSetBpf</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *fp)
01184 {
01185     DWORD BytesReturned;
01186     <span class="keywordflow">return</span> DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,pBIOCSETF,(<span class="keywordtype">char</span>*)fp-&gt;<a class="code" href="structbpf__program.html#m1">bf_insns</a>,fp-&gt;<a class="code" href="structbpf__program.html#m0">bf_len</a>*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbpf__insn.html">bpf_insn</a>),NULL,0,&amp;BytesReturned,NULL);
01187 }
01188 
<a name="l01202"></a><a class="code" href="Packet32_8c.html#a39">01202</a> BOOLEAN <a class="code" href="Packet32_8c.html#a39">PacketGetStats</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a> *s)
01203 {
01204     BOOLEAN Res;
01205     DWORD BytesReturned;
01206     <span class="keyword">struct </span><a class="code" href="structbpf__stat.html">bpf_stat</a> tmpstat;    <span class="comment">// We use a support structure to avoid kernel-level inconsistencies with old or malicious applications</span>
01207 
01208     Res = DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,
01209         pBIOCGSTATS,
01210         NULL,
01211         0,
01212         &amp;tmpstat,
01213         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a>),
01214         &amp;BytesReturned,
01215         NULL);
01216 
01217     <span class="comment">// Copy only the first two values retrieved from the driver</span>
01218     s-&gt;<a class="code" href="structbpf__stat.html#m0">bs_recv</a> = tmpstat.<a class="code" href="structbpf__stat.html#m0">bs_recv</a>;
01219     s-&gt;<a class="code" href="structbpf__stat.html#m1">bs_drop</a> = tmpstat.<a class="code" href="structbpf__stat.html#m1">bs_drop</a>;
01220 
01221     <span class="keywordflow">return</span> Res;
01222 }
01223 
<a name="l01236"></a><a class="code" href="Packet32_8c.html#a40">01236</a> BOOLEAN <a class="code" href="Packet32_8c.html#a40">PacketGetStatsEx</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a> AdapterObject,<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a> *s)
01237 {
01238     BOOLEAN Res;
01239     DWORD BytesReturned;
01240     <span class="keyword">struct </span><a class="code" href="structbpf__stat.html">bpf_stat</a> tmpstat;    <span class="comment">// We use a support structure to avoid kernel-level inconsistencies with old or malicious applications</span>
01241 
01242     Res = DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,
01243         pBIOCGSTATS,
01244         NULL,
01245         0,
01246         &amp;tmpstat,
01247         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a>),
01248         &amp;BytesReturned,
01249         NULL);
01250 
01251     s-&gt;<a class="code" href="structbpf__stat.html#m0">bs_recv</a> = tmpstat.<a class="code" href="structbpf__stat.html#m0">bs_recv</a>;
01252     s-&gt;<a class="code" href="structbpf__stat.html#m1">bs_drop</a> = tmpstat.<a class="code" href="structbpf__stat.html#m1">bs_drop</a>;
01253     s-&gt;<a class="code" href="structbpf__stat.html#m2">ps_ifdrop</a> = tmpstat.<a class="code" href="structbpf__stat.html#m2">ps_ifdrop</a>;
01254     s-&gt;<a class="code" href="structbpf__stat.html#m3">bs_capt</a> = tmpstat.<a class="code" href="structbpf__stat.html#m3">bs_capt</a>;
01255 
01256     <span class="keywordflow">return</span> Res;
01257 }
01258 
<a name="l01271"></a><a class="code" href="Packet32_8c.html#a41">01271</a> BOOLEAN <a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a>  AdapterObject,BOOLEAN Set,PPACKET_OID_DATA  OidData)
01272 {
01273     DWORD       BytesReturned;
01274     BOOLEAN     Result;
01275 
01276     Result=DeviceIoControl(AdapterObject-&gt;<a class="code" href="struct__ADAPTER.html#m0">hFile</a>,(DWORD) Set ? (DWORD)pBIOCSETOID : (DWORD)pBIOCQUERYOID,
01277                            OidData,<span class="keyword">sizeof</span>(PACKET_OID_DATA)-1+OidData-&gt;Length,OidData,
01278                            <span class="keyword">sizeof</span>(PACKET_OID_DATA)-1+OidData-&gt;Length,&amp;BytesReturned,NULL);
01279     
01280     <span class="comment">// output some debug info</span>
01281     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketRequest, OID=%d "</span>, OidData-&gt;Oid);
01282     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Length=%d "</span>, OidData-&gt;Length);
01283     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Set=%d "</span>, Set);
01284     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Res=%d\n"</span>, Result);
01285 
01286     <span class="keywordflow">return</span> Result;
01287 }
01288 
<a name="l01305"></a><a class="code" href="Packet32_8c.html#a42">01305</a> BOOLEAN <a class="code" href="Packet32_8c.html#a42">PacketSetHwFilter</a>(<a class="code" href="struct__ADAPTER.html">LPADAPTER</a>  AdapterObject,ULONG Filter)
01306 {
01307     BOOLEAN    Status;
01308     ULONG      IoCtlBufferLength=(<span class="keyword">sizeof</span>(PACKET_OID_DATA)+<span class="keyword">sizeof</span>(ULONG)-1);
01309     <a class="code" href="group__packet32h.html#a5">PPACKET_OID_DATA</a>  OidData;
01310 
01311     OidData=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,IoCtlBufferLength);
01312     <span class="keywordflow">if</span> (OidData == NULL) {
01313         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketSetHwFilter: GlobalAlloc Failed\n"</span>);
01314         <span class="keywordflow">return</span> FALSE;
01315     }
01316     OidData-&gt;Oid=OID_GEN_CURRENT_PACKET_FILTER;
01317     OidData-&gt;Length=<span class="keyword">sizeof</span>(ULONG);
01318     *((PULONG)OidData-&gt;Data)=Filter;
01319     Status=<a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(AdapterObject,TRUE,OidData);
01320     GlobalFreePtr(OidData);
01321     <span class="keywordflow">return</span> Status;
01322 }
01323 
<a name="l01353"></a><a class="code" href="Packet32_8c.html#a43">01353</a> BOOLEAN <a class="code" href="Packet32_8c.html#a43">PacketGetAdapterNames</a>(PTSTR pStr,PULONG  BufferSize)
01354 {
01355   HKEY      LinkageKey,AdapKey, OneAdapKey;
01356     DWORD       RegKeySize=0;
01357   LONG      Status;
01358     ULONG       Result;
01359     PTSTR       BpStr;
01360     <span class="keywordtype">char</span>        *TTpStr,*DpStr,*DescBuf;
01361     <a class="code" href="struct__ADAPTER.html">LPADAPTER</a>   adapter;
01362   <a class="code" href="group__packet32h.html#a5">PPACKET_OID_DATA</a>  OidData;
01363     <span class="keywordtype">int</span>         i=0,k,rewind;
01364     DWORD       dim;
01365     TCHAR       AdapName[256];
01366 
01367   <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"PacketGetAdapterNames: BufferSize=%d\n"</span>,*BufferSize);
01368 
01369   OidData = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,512);
01370   <span class="keywordflow">if</span> (OidData == NULL) {
01371       <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: GlobalAlloc Failed\n"</span>);
01372       <span class="keywordflow">return</span> FALSE;
01373   }
01374 
01375   Status=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
01376                       TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"</span>),
01377                         0,
01378                         KEY_READ,
01379                         &amp;AdapKey);
01380   <span class="keywordflow">if</span> ( Status != ERROR_SUCCESS ){
01381     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: RegOpenKeyEx ( Class\{networkclassguid} ) Failed\n"</span>);
01382     <span class="keywordflow">return</span> FALSE;
01383   }
01384 
01385     <span class="comment">// Get the size to allocate for the original device names</span>
01386     <span class="keywordflow">while</span>((Result=RegEnumKey(AdapKey,i,AdapName,<span class="keyword">sizeof</span>(AdapName)/2))==ERROR_SUCCESS)
01387     {
01388         Status=RegOpenKeyEx(AdapKey,AdapName,0,KEY_READ,&amp;OneAdapKey);
01389     <span class="keywordflow">if</span> ( Status != ERROR_SUCCESS ){
01390         RegCloseKey(AdapKey);
01391       <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: RegOpenKeyEx ( OneAdapKey ) Failed\n"</span>);
01392       <span class="keywordflow">return</span> FALSE;
01393     }
01394     
01395         Status=RegOpenKeyEx(OneAdapKey,L<span class="stringliteral">"Linkage"</span>,0,KEY_READ,&amp;LinkageKey);
01396     <span class="keywordflow">if</span> ( Status != ERROR_SUCCESS ){
01397       RegCloseKey( OneAdapKey );
01398         RegCloseKey(AdapKey);
01399       <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: RegOpenKeyEx ( LinkageKey ) Failed\n"</span>);
01400       <span class="keywordflow">return</span> FALSE;
01401     }
01402 
01403     Status=RegQueryValueEx(LinkageKey,L<span class="stringliteral">"Export"</span>,NULL,NULL,NULL,&amp;dim);
01404 
01405     RegCloseKey( OneAdapKey );
01406     RegCloseKey( LinkageKey );
01407 
01408         i++;
01409         <span class="keywordflow">if</span>(Status!=ERROR_SUCCESS) <span class="keywordflow">continue</span>;
01410         RegKeySize+=dim;
01411   } <span class="comment">// while enum reg key still find keys</span>
01412     
01413     <span class="comment">// Allocate the memory for the original device names</span>
01414     <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Need %d bytes for the names\n"</span>, RegKeySize+2);
01415     BpStr=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,RegKeySize+2);
01416     <span class="keywordflow">if</span> (BpStr == NULL || RegKeySize &gt; *BufferSize) {
01417         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: GlobalAlloc Failed\n"</span>);
01418         GlobalFreePtr(OidData);
01419         <span class="keywordflow">return</span> FALSE;
01420     }
01421 
01422     k=0;
01423     i=0;
01424 
01425   <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: Cycling through the adapters:\n"</span>);
01426 
01427     <span class="comment">// Copy the names to the buffer</span>
01428     <span class="keywordflow">while</span>((Result=RegEnumKey(AdapKey,i,AdapName,<span class="keyword">sizeof</span>(AdapName)/2))==ERROR_SUCCESS)
01429     {
01430         WCHAR UpperBindStr[64];
01431 
01432         i++;
01433         <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">" %d) "</span>, i);
01434 
01435         Status=RegOpenKeyEx(AdapKey,AdapName,0,KEY_READ,&amp;OneAdapKey);
01436     <span class="keywordflow">if</span> ( Status != ERROR_SUCCESS ){
01437         RegCloseKey(AdapKey);
01438       <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: RegOpenKeyEx ( OneAdapKey ) Failed\n"</span>);
01439       <span class="keywordflow">return</span> FALSE;
01440     }
01441         Status=RegOpenKeyEx(OneAdapKey,L<span class="stringliteral">"Linkage"</span>,0,KEY_READ,&amp;LinkageKey);
01442     <span class="keywordflow">if</span> ( Status != ERROR_SUCCESS ){
01443       RegCloseKey( OneAdapKey );
01444         RegCloseKey(AdapKey);
01445       <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: RegOpenKeyEx ( LinkageKey ) Failed\n"</span>);
01446       <span class="keywordflow">return</span> FALSE;
01447     }
01448 
01449         dim=<span class="keyword">sizeof</span>(UpperBindStr);
01450         Status=RegQueryValueEx(LinkageKey,L<span class="stringliteral">"UpperBind"</span>,NULL,NULL,(PUCHAR)UpperBindStr,&amp;dim);
01451         
01452         <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"UpperBind=%S "</span>, UpperBindStr);
01453 
01454         dim=RegKeySize-k;
01455         Status=RegQueryValueEx(LinkageKey,L<span class="stringliteral">"Export"</span>,NULL,NULL,(LPBYTE)BpStr+k,&amp;dim);
01456         <span class="keywordflow">if</span>(Status!=ERROR_SUCCESS){
01457       RegCloseKey( OneAdapKey );
01458       RegCloseKey( LinkageKey );
01459             <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Name = SKIPPED (error reading the key)\n"</span>);
01460             <span class="keywordflow">continue</span>;
01461         }
01462 
01463     RegCloseKey( OneAdapKey );
01464     RegCloseKey( LinkageKey );
01465         <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Name = %S\n"</span>, (LPBYTE)BpStr+k);
01466 
01467         k+=dim-2;
01468   } <span class="comment">// while enum reg keys</span>
01469 
01470     RegCloseKey(AdapKey);
01471 
01472 <span class="preprocessor">#ifdef _DEBUG_TO_FILE</span>
01473 <span class="preprocessor"></span>    <span class="comment">//dump BpStr for debug purposes</span>
01474     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Dumping BpStr:"</span>);
01475     {
01476         FILE *f;
01477         f = fopen(<span class="stringliteral">"winpcap_debug.txt"</span>, <span class="stringliteral">"a"</span>);
01478         <span class="keywordflow">for</span>(i=0;i&lt;k;i++){
01479             <span class="keywordflow">if</span>(!(i%32))fprintf(f, <span class="stringliteral">"\n "</span>);
01480             fprintf(f, <span class="stringliteral">"%c "</span> , *((LPBYTE)BpStr+i));
01481         }
01482         fclose(f);
01483     }
01484     <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"\n"</span>);
01485 <span class="preprocessor">#endif</span>
01486 <span class="preprocessor"></span>
01487     
01488     <span class="keywordflow">if</span> (k != 0)
01489   {
01490     DescBuf=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, 4096);
01491 
01492         <span class="keywordflow">if</span> (DescBuf == NULL) {
01493             GlobalFreePtr (BpStr);
01494           GlobalFreePtr(OidData);
01495             <span class="keywordflow">return</span> FALSE;
01496         }
01497         DpStr=DescBuf;
01498                 
01499         <span class="keywordflow">for</span>(i=0,k=0;BpStr[i]!=0 || BpStr[i+1]!=0;)
01500     {
01501             
01502             <span class="keywordflow">if</span>(k+wcslen(BpStr+i)+30 &gt; *BufferSize){
01503                 <span class="comment">// Input buffer too small</span>
01504                 GlobalFreePtr(OidData);
01505                 GlobalFreePtr (BpStr);
01506                 GlobalFreePtr (DescBuf);
01507                 <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"PacketGetAdapterNames: Input buffer too small!\n"</span>);
01508                 <span class="keywordflow">return</span> FALSE;
01509             }
01510 
01511             <span class="comment">// Create the device name</span>
01512             rewind=k;
01513             memcpy(pStr+k,BpStr+i,16);
01514             memcpy(pStr+k+8,TEXT(<span class="stringliteral">"NPF_"</span>),8);
01515             i+=8;
01516             k+=12;
01517             <span class="keywordflow">while</span>(BpStr[i-1]!=0){
01518                 pStr[k++]=BpStr[i++];
01519             }
01520 
01521             <span class="comment">// Open the adapter</span>
01522             adapter=<a class="code" href="Packet32_8c.html#a21">PacketOpenAdapter</a>(pStr+rewind);
01523             <span class="keywordflow">if</span>(adapter==NULL){
01524                 k=rewind;
01525                 <span class="keywordflow">continue</span>;
01526             }
01527 
01528             <span class="comment">// Retrieve the description</span>
01529             OidData-&gt;Oid = OID_GEN_VENDOR_DESCRIPTION;
01530             OidData-&gt;Length = 256;
01531             ZeroMemory(OidData-&gt;Data,256);
01532             Status = <a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(adapter,FALSE,OidData);
01533             <span class="keywordflow">if</span>(Status==0 || ((<span class="keywordtype">char</span>*)OidData-&gt;Data)[0]==0){
01534                 k=rewind;
01535                 <span class="keywordflow">continue</span>;
01536             }
01537 
01538             <a class="code" href="Packet32_8c.html#a2">ODSEx</a>(<span class="stringliteral">"Adapter Description=%s\n\n"</span>,OidData-&gt;Data);
01539 
01540             <span class="comment">// Copy the description</span>
01541             TTpStr=(<span class="keywordtype">char</span>*)(OidData-&gt;Data);
01542             <span class="keywordflow">while</span>(*TTpStr!=0){
01543                 *DpStr++=*TTpStr++;
01544             }
01545             *DpStr++=*TTpStr++;
01546             
01547             <span class="comment">// Close the adapter</span>
01548             <a class="code" href="Packet32_8c.html#a22">PacketCloseAdapter</a>(adapter);
01549             
01550     } <span class="comment">// for end - parse through string</span>
01551         *DpStr=0;
01552 
01553         pStr[k++]=0;
01554         pStr[k]=0;
01555 
01556         <span class="keywordflow">if</span>((ULONG)(DpStr-DescBuf+k) &lt; *BufferSize)
01557             memcpy(pStr+k,DescBuf,DpStr-DescBuf);
01558         <span class="keywordflow">else</span>{
01559           GlobalFreePtr(OidData);
01560             GlobalFreePtr (BpStr);
01561             GlobalFreePtr (DescBuf);
01562             <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"\nPacketGetAdapterNames: ended with failure\n"</span>);
01563             <span class="keywordflow">return</span> FALSE;
01564         }
01565 
01566       GlobalFreePtr(OidData);
01567         GlobalFreePtr (BpStr);
01568         GlobalFreePtr (DescBuf);
01569         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"\nPacketGetAdapterNames: ended correctly\n"</span>);
01570         <span class="keywordflow">return</span> TRUE;
01571   } <span class="comment">// if k != 0</span>
01572     <span class="keywordflow">else</span>{
01573       DWORD      RegType;
01574 
01575         <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Adapters not found under SYSTEM\\CurrentControlSet\\Control\\Class. Using the TCP/IP bindings.\n"</span>);
01576 
01577         GlobalFreePtr (BpStr);
01578 
01579         Status=RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Linkage"</span>),0,KEY_READ,&amp;LinkageKey);
01580         <span class="keywordflow">if</span> (Status == ERROR_SUCCESS)
01581         {
01582             <span class="comment">// Retrieve the length of the key</span>
01583             Status=RegQueryValueEx(LinkageKey,TEXT(<span class="stringliteral">"bind"</span>),NULL,&amp;RegType,NULL,&amp;RegKeySize);
01584             <span class="comment">// Allocate the buffer</span>
01585             BpStr=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT,RegKeySize+2);
01586             <span class="keywordflow">if</span> (BpStr == NULL || RegKeySize &gt; *BufferSize) {
01587                 GlobalFreePtr(OidData);
01588                 <span class="keywordflow">return</span> FALSE;
01589             }
01590             Status=RegQueryValueEx(LinkageKey,TEXT(<span class="stringliteral">"bind"</span>),NULL,&amp;RegType,(LPBYTE)BpStr,&amp;RegKeySize);
01591             RegCloseKey(LinkageKey);
01592         }
01593         
01594         <span class="keywordflow">if</span> (Status==ERROR_SUCCESS){
01595             
01596             DescBuf=GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, 4096);
01597             <span class="keywordflow">if</span> (DescBuf == NULL) {
01598                 GlobalFreePtr (BpStr);
01599                 GlobalFreePtr(OidData);
01600                 <span class="keywordflow">return</span> FALSE;
01601             }
01602             DpStr=DescBuf;
01603             
01604             <span class="keywordflow">for</span>(i=0,k=0;BpStr[i]!=0 || BpStr[i+1]!=0;){
01605                 
01606                 <span class="keywordflow">if</span>(k+wcslen(BpStr+i)+30 &gt; *BufferSize){
01607                     <span class="comment">// Input buffer too small</span>
01608                     GlobalFreePtr(OidData);
01609                     GlobalFreePtr (BpStr);
01610                     GlobalFreePtr (DescBuf);
01611                     <span class="keywordflow">return</span> FALSE;
01612                 }
01613                 
01614                 <span class="comment">// Create the device name</span>
01615                 rewind=k;
01616                 memcpy(pStr+k,BpStr+i,16);
01617                 memcpy(pStr+k+8,TEXT(<span class="stringliteral">"NPF_"</span>),8);
01618                 i+=8;
01619                 k+=12;
01620                 <span class="keywordflow">while</span>(BpStr[i-1]!=0){
01621                     pStr[k++]=BpStr[i++];
01622                 }
01623                 
01624                 <span class="comment">// Open the adapter</span>
01625                 adapter=<a class="code" href="Packet32_8c.html#a21">PacketOpenAdapter</a>(pStr+rewind);
01626                 <span class="keywordflow">if</span>(adapter==NULL){
01627                     k=rewind;
01628                     <span class="keywordflow">continue</span>;
01629                 }
01630                 
01631                 <span class="comment">// Retrieve the description</span>
01632                 OidData-&gt;Oid = OID_GEN_VENDOR_DESCRIPTION;
01633                 OidData-&gt;Length = 256;
01634                 Status = <a class="code" href="Packet32_8c.html#a41">PacketRequest</a>(adapter,FALSE,OidData);
01635                 <span class="keywordflow">if</span>(Status==0 || ((<span class="keywordtype">char</span>*)OidData-&gt;Data)[0]==0){
01636                     k=rewind;
01637                     <span class="keywordflow">continue</span>;
01638                 }
01639                 
01640                 <span class="comment">// Copy the description</span>
01641                 TTpStr=(<span class="keywordtype">char</span>*)(OidData-&gt;Data);
01642                 <span class="keywordflow">while</span>(*TTpStr!=0){
01643                     *DpStr++=*TTpStr++;
01644                 }
01645                 *DpStr++=*TTpStr++;
01646                 
01647                 <span class="comment">// Close the adapter</span>
01648                 <a class="code" href="Packet32_8c.html#a22">PacketCloseAdapter</a>(adapter);
01649                 
01650       } <span class="comment">// for end - parse string</span>
01651             *DpStr=0;
01652             
01653             pStr[k++]=0;
01654             pStr[k]=0;
01655             
01656             <span class="keywordflow">if</span>((ULONG)(DpStr-DescBuf+k) &lt; *BufferSize)
01657                 memcpy(pStr+k,DescBuf,DpStr-DescBuf);
01658             <span class="keywordflow">else</span>{
01659                 GlobalFreePtr(OidData);
01660                 GlobalFreePtr (BpStr);
01661                 GlobalFreePtr (DescBuf);
01662                 <span class="keywordflow">return</span> FALSE;
01663             }
01664             
01665             GlobalFreePtr(OidData);
01666             GlobalFreePtr (BpStr);
01667             GlobalFreePtr (DescBuf);
01668             <span class="keywordflow">return</span> TRUE;
01669     } <span class="comment">// if key 'bind' was successfully opened</span>
01670         <span class="keywordflow">else</span>{
01671             MessageBox(NULL,TEXT(<span class="stringliteral">"Can not find TCP/IP bindings.\nIn order to run the packet capture driver you must install TCP/IP."</span>),szWindowTitle,MB_OK);
01672             <a class="code" href="Packet32_8c.html#a1">ODS</a>(<span class="stringliteral">"Cannot find the TCP/IP bindings"</span>);
01673             <span class="keywordflow">return</span> FALSE;
01674         }
01675     }
01676 }
<a name="l01690"></a><a class="code" href="Packet32_8c.html#a44">01690</a> BOOLEAN <a class="code" href="Packet32_8c.html#a44">PacketGetNetInfoEx</a>(LPTSTR AdapterName, <a class="code" href="structnpf__if__addr.html">npf_if_addr</a>* buffer, PLONG NEntries)
01691 {
01692     <span class="keywordtype">char</span>    *AdapterNameA;
01693     WCHAR   *AdapterNameU;
01694     WCHAR   *ifname;
01695     HKEY    SystemKey;
01696     HKEY    InterfaceKey;
01697     HKEY    ParametersKey;
01698     HKEY    TcpIpKey;
01699     HKEY    UnderTcpKey;
01700     LONG    status;
01701     WCHAR   String[1024+1];
01702     DWORD   RegType;
01703     ULONG   BufLen;
01704     DWORD   DHCPEnabled;
01705     <span class="keyword">struct  </span>sockaddr_in *TmpAddr, *TmpBroad;
01706     LONG    naddrs,nmasks,StringPos;
01707     DWORD   ZeroBroadcast;
01708 
01709     AdapterNameA = (<span class="keywordtype">char</span>*)AdapterName;
01710     <span class="keywordflow">if</span>(AdapterNameA[1] != 0) {  <span class="comment">//ASCII</span>
01711         AdapterNameU = <a class="code" href="Packet32_8c.html#a13">SChar2WChar</a>(AdapterNameA);
01712         AdapterName = AdapterNameU;
01713     } <span class="keywordflow">else</span> {                <span class="comment">//Unicode</span>
01714         AdapterNameU = NULL;
01715     }
01716     ifname = wcsrchr(AdapterName, <span class="charliteral">'\\'</span>);
01717     <span class="keywordflow">if</span> (ifname == NULL)
01718         ifname = AdapterName;
01719     <span class="keywordflow">else</span>
01720         ifname++;
01721     <span class="keywordflow">if</span> (wcsncmp(ifname, L<span class="stringliteral">"NPF_"</span>, 4) == 0)
01722         ifname += 4;
01723 
01724     <span class="keywordflow">if</span>( RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"</span>), 0, KEY_READ, &amp;UnderTcpKey) == ERROR_SUCCESS)
01725     {
01726         status = RegOpenKeyEx(UnderTcpKey,ifname,0,KEY_READ,&amp;TcpIpKey);
01727         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01728             RegCloseKey(UnderTcpKey);
01729             <span class="keywordflow">goto</span> fail;
01730         }
01731     }
01732     <span class="keywordflow">else</span>
01733     {
01734         
01735         <span class="comment">// Query the registry key with the interface's adresses</span>
01736         status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Services"</span>),0,KEY_READ,&amp;SystemKey);
01737         <span class="keywordflow">if</span> (status != ERROR_SUCCESS)
01738             <span class="keywordflow">goto</span> fail;
01739         status = RegOpenKeyEx(SystemKey,ifname,0,KEY_READ,&amp;InterfaceKey);
01740         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01741             RegCloseKey(SystemKey);
01742             <span class="keywordflow">goto</span> fail;
01743         }
01744         RegCloseKey(SystemKey);
01745         status = RegOpenKeyEx(InterfaceKey,TEXT(<span class="stringliteral">"Parameters"</span>),0,KEY_READ,&amp;ParametersKey);
01746         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01747             RegCloseKey(InterfaceKey);
01748             <span class="keywordflow">goto</span> fail;
01749         }
01750         RegCloseKey(InterfaceKey);
01751         status = RegOpenKeyEx(ParametersKey,TEXT(<span class="stringliteral">"TcpIp"</span>),0,KEY_READ,&amp;TcpIpKey);
01752         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01753             RegCloseKey(ParametersKey);
01754             <span class="keywordflow">goto</span> fail;
01755         }
01756         RegCloseKey(ParametersKey);
01757         BufLen = <span class="keyword">sizeof</span> String;
01758     }
01759 
01760     BufLen = 4;
01761     <span class="comment">/* Try to detect if the interface has a zero broadcast addr */</span>
01762     status=RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"UseZeroBroadcast"</span>),NULL,&amp;RegType,(LPBYTE)&amp;ZeroBroadcast,&amp;BufLen);
01763     <span class="keywordflow">if</span> (status != ERROR_SUCCESS)
01764         ZeroBroadcast=0;
01765     
01766     BufLen = 4;
01767     <span class="comment">/* See if DHCP is used by this system */</span>
01768     status=RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"EnableDHCP"</span>),NULL,&amp;RegType,(LPBYTE)&amp;DHCPEnabled,&amp;BufLen);
01769     <span class="keywordflow">if</span> (status != ERROR_SUCCESS)
01770         DHCPEnabled=0;
01771     
01772     
01773     <span class="comment">/* Retrieve the adrresses */</span>
01774     <span class="keywordflow">if</span>(DHCPEnabled){
01775         
01776         BufLen = <span class="keyword">sizeof</span> String;
01777         <span class="comment">// Open the key with the addresses</span>
01778         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"DhcpIPAddress"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
01779         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01780             RegCloseKey(TcpIpKey);
01781             <span class="keywordflow">goto</span> fail;
01782         }
01783 
01784         <span class="comment">// scan the key to obtain the addresses</span>
01785         StringPos = 0;
01786         <span class="keywordflow">for</span>(naddrs = 0;naddrs &lt;* NEntries;naddrs++){
01787             TmpAddr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[naddrs].IPAddress);
01788             
01789             <span class="keywordflow">if</span>((TmpAddr-&gt;sin_addr.S_un.S_addr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String + StringPos))!= -1){
01790                 TmpAddr-&gt;sin_family = AF_INET;
01791                 
01792                 TmpBroad = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[naddrs].Broadcast);
01793                 TmpBroad-&gt;sin_family = AF_INET;
01794                 <span class="keywordflow">if</span>(ZeroBroadcast==0)
01795                     TmpBroad-&gt;sin_addr.S_un.S_addr = 0xffffffff; <span class="comment">// 255.255.255.255</span>
01796                 <span class="keywordflow">else</span>
01797                     TmpBroad-&gt;sin_addr.S_un.S_addr = 0; <span class="comment">// 0.0.0.0</span>
01798 
01799                 <span class="keywordflow">while</span>(*(String + StringPos) != 0)StringPos++;
01800                 StringPos++;
01801                 
01802                 <span class="keywordflow">if</span>(*(String + StringPos) == 0 || (StringPos * <span class="keyword">sizeof</span> (WCHAR)) &gt;= BufLen)
01803                     <span class="keywordflow">break</span>;              
01804             }
01805             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
01806         }       
01807         
01808         BufLen = <span class="keyword">sizeof</span> String;
01809         <span class="comment">// Open the key with the netmasks</span>
01810         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"DhcpSubnetMask"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
01811         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01812             RegCloseKey(TcpIpKey);
01813             <span class="keywordflow">goto</span> fail;
01814         }
01815         
01816         <span class="comment">// scan the key to obtain the masks</span>
01817         StringPos = 0;
01818         <span class="keywordflow">for</span>(nmasks = 0;nmasks &lt; *NEntries;nmasks++){
01819             TmpAddr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[nmasks].SubnetMask);
01820             
01821             <span class="keywordflow">if</span>((TmpAddr-&gt;sin_addr.S_un.S_addr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String + StringPos))!= -1){
01822                 TmpAddr-&gt;sin_family = AF_INET;
01823                 
01824                 <span class="keywordflow">while</span>(*(String + StringPos) != 0)StringPos++;
01825                 StringPos++;
01826                                 
01827                 <span class="keywordflow">if</span>(*(String + StringPos) == 0 || (StringPos * <span class="keyword">sizeof</span> (WCHAR)) &gt;= BufLen)
01828                     <span class="keywordflow">break</span>;
01829             }
01830             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
01831         }       
01832         
01833         <span class="comment">// The number of masks MUST be equal to the number of adresses</span>
01834         <span class="keywordflow">if</span>(nmasks != naddrs){
01835             RegCloseKey(TcpIpKey);
01836             <span class="keywordflow">goto</span> fail;
01837         }
01838                 
01839     }
01840     <span class="keywordflow">else</span>{
01841         
01842         BufLen = <span class="keyword">sizeof</span> String;
01843         <span class="comment">// Open the key with the addresses</span>
01844         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"IPAddress"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
01845         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01846             RegCloseKey(TcpIpKey);
01847             <span class="keywordflow">goto</span> fail;
01848         }
01849         
01850         <span class="comment">// scan the key to obtain the addresses</span>
01851         StringPos = 0;
01852         <span class="keywordflow">for</span>(naddrs = 0;naddrs &lt; *NEntries;naddrs++){
01853             TmpAddr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[naddrs].IPAddress);
01854             
01855             <span class="keywordflow">if</span>((TmpAddr-&gt;sin_addr.S_un.S_addr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String + StringPos))!= -1){
01856                 TmpAddr-&gt;sin_family = AF_INET;
01857 
01858                 TmpBroad = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[naddrs].Broadcast);
01859                 TmpBroad-&gt;sin_family = AF_INET;
01860                 <span class="keywordflow">if</span>(ZeroBroadcast==0)
01861                     TmpBroad-&gt;sin_addr.S_un.S_addr = 0xffffffff; <span class="comment">// 255.255.255.255</span>
01862                 <span class="keywordflow">else</span>
01863                     TmpBroad-&gt;sin_addr.S_un.S_addr = 0; <span class="comment">// 0.0.0.0</span>
01864                 
01865                 <span class="keywordflow">while</span>(*(String + StringPos) != 0)StringPos++;
01866                 StringPos++;
01867                 
01868                 <span class="keywordflow">if</span>(*(String + StringPos) == 0 || (StringPos * <span class="keyword">sizeof</span> (WCHAR)) &gt;= BufLen)
01869                     <span class="keywordflow">break</span>;
01870             }
01871             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
01872         }       
01873         
01874         BufLen = <span class="keyword">sizeof</span> String;
01875         <span class="comment">// Open the key with the netmasks</span>
01876         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"SubnetMask"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
01877         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01878             RegCloseKey(TcpIpKey);
01879             <span class="keywordflow">goto</span> fail;
01880         }
01881         
01882         <span class="comment">// scan the key to obtain the masks</span>
01883         StringPos = 0;
01884         <span class="keywordflow">for</span>(nmasks = 0;nmasks &lt;* NEntries;nmasks++){
01885             TmpAddr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(buffer[nmasks].SubnetMask);
01886             
01887             <span class="keywordflow">if</span>((TmpAddr-&gt;sin_addr.S_un.S_addr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String + StringPos))!= -1){
01888                 TmpAddr-&gt;sin_family = AF_INET;
01889                 
01890                 <span class="keywordflow">while</span>(*(String + StringPos) != 0)StringPos++;
01891                 StringPos++;
01892                 
01893                 <span class="keywordflow">if</span>(*(String + StringPos) == 0 || (StringPos * <span class="keyword">sizeof</span> (WCHAR)) &gt;= BufLen)
01894                     <span class="keywordflow">break</span>;
01895             }
01896             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
01897         }       
01898         
01899         <span class="comment">// The number of masks MUST be equal to the number of adresses</span>
01900         <span class="keywordflow">if</span>(nmasks != naddrs){
01901             RegCloseKey(TcpIpKey);
01902             <span class="keywordflow">goto</span> fail;
01903         }
01904                 
01905     }
01906     
01907     *NEntries = naddrs + 1;
01908 
01909     RegCloseKey(TcpIpKey);
01910     
01911     <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01912         <span class="keywordflow">goto</span> fail;
01913     }
01914     
01915     
01916     <span class="keywordflow">if</span> (AdapterNameU != NULL)
01917         free(AdapterNameU);
01918     <span class="keywordflow">return</span> TRUE;
01919     
01920 fail:
01921     <span class="keywordflow">if</span> (AdapterNameU != NULL)
01922         free(AdapterNameU);
01923     <span class="keywordflow">return</span> FALSE;
01924 }
01925 
<a name="l01936"></a><a class="code" href="Packet32_8c.html#a45">01936</a> BOOLEAN <a class="code" href="Packet32_8c.html#a45">PacketGetNetInfo</a>(LPTSTR AdapterName, PULONG netp, PULONG maskp)
01937 {
01938     <span class="keywordtype">char</span>    *AdapterNameA;
01939     WCHAR   *AdapterNameU;
01940     WCHAR   *ifname;
01941     HKEY    SystemKey;
01942     HKEY    InterfaceKey;
01943     HKEY    ParametersKey;
01944     HKEY    TcpIpKey;
01945     LONG    status;
01946     WCHAR   String[1024+1];
01947     DWORD   RegType;
01948     ULONG   BufLen;
01949     DWORD   DHCPEnabled;
01950     ULONG   TAddr,i;
01951 
01952     AdapterNameA = (<span class="keywordtype">char</span>*)AdapterName;
01953     <span class="keywordflow">if</span>(AdapterNameA[1] != 0) {  <span class="comment">//ASCII</span>
01954         AdapterNameU = <a class="code" href="Packet32_8c.html#a13">SChar2WChar</a>(AdapterNameA);
01955         AdapterName = AdapterNameU;
01956     } <span class="keywordflow">else</span> {                <span class="comment">//Unicode</span>
01957         AdapterNameU = NULL;
01958     }
01959     ifname = wcsrchr(AdapterName, <span class="charliteral">'\\'</span>);
01960     <span class="keywordflow">if</span> (ifname == NULL)
01961         ifname = AdapterName;
01962     <span class="keywordflow">else</span>
01963         ifname++;
01964     <span class="keywordflow">if</span> (wcsncmp(ifname, L<span class="stringliteral">"NPF_"</span>, 4) == 0)
01965         ifname += 4;
01966     status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT(<span class="stringliteral">"SYSTEM\\CurrentControlSet\\Services"</span>),0,KEY_READ,&amp;SystemKey);
01967     <span class="keywordflow">if</span> (status != ERROR_SUCCESS)
01968         <span class="keywordflow">goto</span> fail;
01969     status = RegOpenKeyEx(SystemKey,ifname,0,KEY_READ,&amp;InterfaceKey);
01970     <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01971         RegCloseKey(SystemKey);
01972         <span class="keywordflow">goto</span> fail;
01973     }
01974     RegCloseKey(SystemKey);
01975     status = RegOpenKeyEx(InterfaceKey,TEXT(<span class="stringliteral">"Parameters"</span>),0,KEY_READ,&amp;ParametersKey);
01976     <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01977         RegCloseKey(InterfaceKey);
01978         <span class="keywordflow">goto</span> fail;
01979     }
01980     RegCloseKey(InterfaceKey);
01981     status = RegOpenKeyEx(ParametersKey,TEXT(<span class="stringliteral">"TcpIp"</span>),0,KEY_READ,&amp;TcpIpKey);
01982     <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
01983         RegCloseKey(ParametersKey);
01984         <span class="keywordflow">goto</span> fail;
01985     }
01986     RegCloseKey(ParametersKey);
01987         
01988     BufLen = 4;
01989     <span class="comment">/* See if DHCP is used by this system */</span>
01990     status=RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"EnableDHCP"</span>),NULL,&amp;RegType,(LPBYTE)&amp;DHCPEnabled,&amp;BufLen);
01991     <span class="keywordflow">if</span> (status != ERROR_SUCCESS)
01992         DHCPEnabled=0;
01993 
01994     
01995     <span class="comment">/* Retrieve the netmask */</span>
01996     <span class="keywordflow">if</span>(DHCPEnabled){
01997         
01998         BufLen = <span class="keyword">sizeof</span> String;
01999         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"DhcpIPAddress"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
02000         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
02001             RegCloseKey(TcpIpKey);
02002             <span class="keywordflow">goto</span> fail;
02003         }
02004 
02005         TAddr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String);
02006         <span class="comment">// swap bytes for backward compatibility</span>
02007         <span class="keywordflow">for</span>(i=0;i&lt;4;i++){
02008             *((<span class="keywordtype">char</span>*)<a class="code" href="inet_8c.html#a3">netp</a>+i) = *((<span class="keywordtype">char</span>*)&amp;TAddr+3-i);
02009         }
02010         
02011         BufLen = <span class="keyword">sizeof</span> String;
02012         status=RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"DHCPSubnetMask"</span>),NULL,&amp;RegType,
02013             (LPBYTE)String,&amp;BufLen);
02014         
02015         TAddr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String);
02016         <span class="comment">// swap bytes for backward compatibility</span>
02017         <span class="keywordflow">for</span>(i=0;i&lt;4;i++){
02018             *((<span class="keywordtype">char</span>*)<a class="code" href="inet_8c.html#a4">maskp</a>+i) = *((<span class="keywordtype">char</span>*)&amp;TAddr+3-i);
02019         }
02020     }
02021     <span class="keywordflow">else</span>{
02022 
02023         BufLen = <span class="keyword">sizeof</span> String;
02024         status = RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"IPAddress"</span>),NULL,&amp;RegType,(LPBYTE)String,&amp;BufLen);
02025         <span class="keywordflow">if</span> (status != ERROR_SUCCESS) {
02026             RegCloseKey(TcpIpKey);
02027             <span class="keywordflow">goto</span> fail;
02028         }
02029 
02030         TAddr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String);
02031         <span class="comment">// swap bytes for backward compatibility</span>
02032         <span class="keywordflow">for</span>(i=0;i&lt;4;i++){
02033             *((<span class="keywordtype">char</span>*)<a class="code" href="inet_8c.html#a3">netp</a>+i) = *((<span class="keywordtype">char</span>*)&amp;TAddr+3-i);
02034         }
02035         
02036         BufLen = <span class="keyword">sizeof</span> String;
02037         status=RegQueryValueEx(TcpIpKey,TEXT(<span class="stringliteral">"SubnetMask"</span>),NULL,&amp;RegType,
02038             (LPBYTE)String,&amp;BufLen);
02039         
02040         TAddr = <a class="code" href="Packet32_8c.html#a17">inet_addrU</a>(String);
02041         <span class="comment">// swap bytes for backward compatibility</span>
02042         <span class="keywordflow">for</span>(i=0;i&lt;4;i++){
02043             *((<span class="keywordtype">char</span>*)<a class="code" href="inet_8c.html#a4">maskp</a>+i) = *((<span class="keywordtype">char</span>*)&amp;TAddr+3-i);
02044         }
02045 
02046 
02047     }
02048     
02049     RegCloseKey(TcpIpKey);  
02050         
02051     <span class="keywordflow">if</span> (AdapterNameU != NULL)
02052         free(AdapterNameU);
02053     <span class="keywordflow">return</span> TRUE;
02054     
02055 fail:
02056     <span class="keywordflow">if</span> (AdapterNameU != NULL)
02057         free(AdapterNameU);
02058     <span class="keywordflow">return</span> FALSE;
02059 }
02060 
02061 
02062 <span class="comment">/* @} */</span>
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
