<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pcap-win32.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Pcap-win32.c</h1><a href="Pcap-win32_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999, 2000</span>
00003 <span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the Politecnico</span>
00013 <span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="preprocessor">#ifndef lint</span>
<a name="l00023"></a><a class="code" href="Pcap-win32_8c.html#a3">00023</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="Pcap-win32_8c.html#a3">rcsid</a>[] =
00024     <span class="stringliteral">"@(#) $Header: /tcpdump/master/libpcap/pcap-win32.c,v 1.6 2003/01/23 09:40:09 guy Exp $ (LBL)"</span>;
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;pcap-int.h&gt;</span>
00028 <span class="preprocessor">#include &lt;packet32.h&gt;</span>
00029 <span class="preprocessor">#include &lt;Ntddndis.h&gt;</span>
00030 <span class="preprocessor">#ifdef __MINGW32__</span>
00031 <span class="preprocessor"></span><span class="keywordtype">int</span>* _errno();
00032 <span class="preprocessor">#define errno (*_errno())</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* __MINGW32__ */</span>
00034 
00035 <span class="preprocessor">#ifdef REMOTE</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
<a name="l00039"></a><a class="code" href="Pcap-win32_8c.html#a0">00039</a> <span class="preprocessor">#define PcapBufSize 256000  </span><span class="comment">/*dimension of the buffer in the pcap_t structure*/</span>
<a name="l00040"></a><a class="code" href="Pcap-win32_8c.html#a1">00040</a> <span class="preprocessor">#define SIZE_BUF 1000000</span>
00041 <span class="preprocessor"></span>
00042 <span class="comment">/*start winsock*/</span>
00043 <span class="keywordtype">int</span> 
<a name="l00044"></a><a class="code" href="Pcap-win32_8c.html#a4">00044</a> <a class="code" href="Pcap-win32_8c.html#a4">wsockinit</a>()
00045 {
00046     WORD wVersionRequested;
00047     WSADATA wsaData;
00048     <span class="keywordtype">int</span> err;
00049     wVersionRequested = MAKEWORD( 1, 1); 
00050     err = WSAStartup( wVersionRequested, &amp;wsaData );
00051     <span class="keywordflow">if</span> ( err != 0 )
00052     {
00053         <span class="keywordflow">return</span> -1;
00054     }
00055     <span class="keywordflow">return</span> 0;
00056 }
00057 
00058 
00059 <span class="keywordtype">int</span>
<a name="l00060"></a><a class="code" href="Pcap-win32_8c.html#a5">00060</a> <a class="code" href="Pcap-win32_8c.html#a5">pcap_stats</a>(pcap_t *p, <span class="keyword">struct</span> <a class="code" href="structpcap__stat.html">pcap_stat</a> *ps)
00061 {
00062 <span class="preprocessor">#ifdef REMOTE</span>
00063 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (p-&gt;rmt_clientside)
00064     {
00065         <span class="comment">/* We are on an remote capture */</span>
00066         <span class="keywordflow">return</span> <a class="code" href="pcap-remote_8c.html#a13">pcap_stats_remote</a>(p, ps);
00067     }
00068 <span class="preprocessor">#endif</span>
00069 <span class="preprocessor"></span>
00070     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a39">PacketGetStats</a>(p-&gt;adapter, (<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a>*)ps) != TRUE){
00071         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"PacketGetStats error: %s"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00072         <span class="keywordflow">return</span> -1;
00073     }
00074 
00075     <span class="keywordflow">return</span> 0;
00076 }
00077 
00078 <span class="keywordtype">int</span>
<a name="l00079"></a><a class="code" href="Pcap-win32_8c.html#a6">00079</a> <a class="code" href="Pcap-win32_8c.html#a6">pcap_read</a>(pcap_t *p, <span class="keywordtype">int</span> cnt, pcap_handler callback, u_char *user)
00080 {
00081     <span class="keywordtype">int</span> cc;
00082     <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00083     <span class="keyword">register</span> u_char *bp, *ep;
00084 
00085 <span class="preprocessor">#ifdef REMOTE</span>
00086 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (p-&gt;rmt_clientside)
00087     {
00088         <span class="comment">/* We are on an remote capture */</span>
00089         <span class="keywordflow">if</span> (!p-&gt;rmt_capstarted)
00090         {
00091             <span class="comment">// if the capture has not started yet, please start it</span>
00092             <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a16">pcap_startcapture_remote</a>(p) )
00093                 <span class="keywordflow">return</span> -1;
00094             p-&gt;rmt_capstarted= 1;
00095         }
00096         <span class="keywordflow">return</span> <a class="code" href="pcap-remote_8c.html#a11">pcap_read_remote</a>(p, cnt, callback, user);
00097     }
00098 <span class="preprocessor">#endif</span>
00099 <span class="preprocessor"></span>
00100     cc = p-&gt;cc;
00101     <span class="keywordflow">if</span> (p-&gt;cc == 0) {
00102 
00103         <span class="comment">/* capture the packets */</span>
00104         <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a26">PacketReceivePacket</a>(p-&gt;adapter,p-&gt;Packet,TRUE)==FALSE){
00105             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"read error: PacketReceivePacket failed"</span>);
00106             <span class="keywordflow">return</span> (-1);
00107         }
00108             
00109         cc = p-&gt;Packet-&gt;ulBytesReceived;
00110 
00111         bp = p-&gt;Packet-&gt;Buffer;
00112     } 
00113     <span class="keywordflow">else</span>
00114         bp = p-&gt;bp;
00115 
00116     <span class="comment">/*</span>
00117 <span class="comment">     * Loop through each packet.</span>
00118 <span class="comment">     */</span>
00119 <span class="preprocessor">#define bhp ((struct bpf_hdr *)bp)</span>
00120 <span class="preprocessor"></span>    ep = bp + cc;
00121     <span class="keywordflow">while</span> (bp &lt; ep) {
00122         <span class="keyword">register</span> <span class="keywordtype">int</span> caplen, hdrlen;
00123         caplen = bhp-&gt;bh_caplen;
00124         hdrlen = bhp-&gt;bh_hdrlen;
00125 
00126         <span class="comment">/*</span>
00127 <span class="comment">         * XXX A bpf_hdr matches a pcap_pkthdr.</span>
00128 <span class="comment">         */</span>
00129         (*callback)(user, (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>*)bp, bp + hdrlen);
00130         bp += BPF_WORDALIGN(caplen + hdrlen);
00131         <span class="keywordflow">if</span> (++<a class="code" href="bpf__image_8c.html#a1">n</a> &gt;= cnt &amp;&amp; cnt &gt; 0) {
00132             p-&gt;bp = bp;
00133             p-&gt;cc = ep - bp;
00134             <span class="keywordflow">return</span> (n);
00135         }
00136     }
00137 <span class="preprocessor">#undef bhp</span>
00138 <span class="preprocessor"></span>    p-&gt;cc = 0;
00139     <span class="keywordflow">return</span> (n);
00140 }
00141 
00142 
00143 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *
<a name="l00144"></a><a class="code" href="Pcap-win32_8c.html#a7">00144</a> <a class="code" href="Pcap-win32_8c.html#a7">pcap_open_live</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *device, <span class="keywordtype">int</span> snaplen, <span class="keywordtype">int</span> promisc, <span class="keywordtype">int</span> to_ms,
00145     <span class="keywordtype">char</span> *ebuf)
00146 {
00147     <span class="keyword">register</span> <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p;
00148     <a class="code" href="structNetType.html">NetType</a> type;
00149 
00150 <span class="preprocessor">#ifdef REMOTE</span>
00151 <span class="preprocessor"></span>    <span class="comment">/*</span>
00152 <span class="comment">        Retrofit; we have to make older applications compatible with the remote capture</span>
00153 <span class="comment">        So, we're calling the pcap_open_remote() from here, that is a very dirty thing.</span>
00154 <span class="comment">        Obviously, we cannot exploit all the new features; for instance, we cannot</span>
00155 <span class="comment">        send authentication, we cannot use a UDP data connection, and so on.</span>
00156 <span class="comment">    */</span>
00157 
00158     <span class="keywordtype">char</span> <a class="code" href="wpcap__remote_8htm.html#a3">host</a>[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a> + 1];
00159     <span class="keywordtype">char</span> <a class="code" href="rpcapd_8c.html#a8">port</a>[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a> + 1];
00160     <span class="keywordtype">char</span> name[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a> + 1];
00161     <span class="keywordtype">int</span> srctype;
00162 
00163     <span class="keywordflow">if</span> (<a class="code" href="pcap-new_8c.html#a5">pcap_parsesrcstr</a>(device, &amp;srctype, host, port, name, ebuf) )
00164         <span class="keywordflow">return</span> NULL;
00165 
00166     <span class="keywordflow">if</span> (srctype == <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>)
00167     {
00168         p= <a class="code" href="pcap-remote_8c.html#a15">pcap_opensource_remote</a>(device, NULL, ebuf);
00169 
00170         <span class="keywordflow">if</span> (p == NULL) 
00171             <span class="keywordflow">return</span> NULL;
00172 
00173         p-&gt;snapshot= snaplen;
00174         p-&gt;timeout= to_ms;
00175         p-&gt;rmt_flags= (promisc) ? <a class="code" href="group__remote__struct.html#a6">PCAP_OPENFLAG_PROMISCUOUS</a> : 0;
00176 
00177         <span class="keywordflow">return</span> p;
00178     }
00179 <span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>
00181     <span class="comment">/* Init WinSock */</span>
00182     <a class="code" href="Pcap-win32_8c.html#a4">wsockinit</a>();
00183 
00184     p = (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *)malloc(<span class="keyword">sizeof</span>(*p));
00185     <span class="keywordflow">if</span> (p == NULL) {
00186         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00187         <span class="keywordflow">return</span> (NULL);
00188     }
00189     memset(p, 0, <span class="keyword">sizeof</span>(*p));
00190     p-&gt;adapter=NULL;
00191 
00192     p-&gt;adapter=<a class="code" href="Packet32_8c.html#a21">PacketOpenAdapter</a>(device);
00193     <span class="keywordflow">if</span> (p-&gt;adapter==NULL) {
00194         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error opening adapter: %s"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00195         <span class="keywordflow">return</span> NULL;
00196     }
00197 
00198     <span class="comment">/*get network type*/</span>
00199     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a19">PacketGetNetType</a> (p-&gt;adapter,&amp;type)==FALSE)
00200     {
00201         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Cannot determine the network type: %s"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00202         <span class="keywordflow">goto</span> bad;
00203     }
00204     
00205     <span class="comment">/*Set the linktype*/</span>
00206     <span class="keywordflow">switch</span> (type.<a class="code" href="structNetType.html#m0">LinkType</a>) {
00207 
00208     <span class="keywordflow">case</span> NdisMediumWan:
00209         p-&gt;linktype = DLT_EN10MB;
00210     <span class="keywordflow">break</span>;
00211 
00212     <span class="keywordflow">case</span> NdisMedium802_3:
00213         p-&gt;linktype = DLT_EN10MB;
00214     <span class="keywordflow">break</span>;
00215 
00216     <span class="keywordflow">case</span> NdisMediumFddi:
00217         p-&gt;linktype = DLT_FDDI;
00218     <span class="keywordflow">break</span>;
00219 
00220     <span class="keywordflow">case</span> NdisMedium802_5:           
00221         p-&gt;linktype = DLT_IEEE802;  
00222     <span class="keywordflow">break</span>;
00223 
00224     <span class="keywordflow">case</span> NdisMediumArcnetRaw:
00225         p-&gt;linktype = DLT_ARCNET;
00226     <span class="keywordflow">break</span>;
00227 
00228     <span class="keywordflow">case</span> NdisMediumArcnet878_2:
00229         p-&gt;linktype = DLT_ARCNET;
00230     <span class="keywordflow">break</span>;
00231 
00232     <span class="keywordflow">case</span> NdisMediumAtm:
00233         p-&gt;linktype = DLT_ATM_RFC1483;
00234     <span class="keywordflow">break</span>;
00235 
00236     <span class="keywordflow">default</span>:
00237         p-&gt;linktype = DLT_EN10MB;           <span class="comment">/*an unknown adapter is assumed to be ethernet*/</span>
00238     <span class="keywordflow">break</span>;
00239     }
00240 
00241     <span class="comment">/* Set promisquous mode */</span>
00242     <span class="keywordflow">if</span> (promisc) <a class="code" href="Packet32_8c.html#a42">PacketSetHwFilter</a>(p-&gt;adapter,NDIS_PACKET_TYPE_PROMISCUOUS);
00243      <span class="keywordflow">else</span> <a class="code" href="Packet32_8c.html#a42">PacketSetHwFilter</a>(p-&gt;adapter,NDIS_PACKET_TYPE_ALL_LOCAL);
00244 
00245     <span class="comment">/* Set the buffer size */</span>
00246     p-&gt;bufsize = <a class="code" href="Pcap-win32_8c.html#a0">PcapBufSize</a>;
00247 
00248     p-&gt;buffer = (u_char *)malloc(PcapBufSize);
00249     <span class="keywordflow">if</span> (p-&gt;buffer == NULL) {
00250         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00251         <span class="keywordflow">goto</span> bad;
00252     }
00253 
00254     p-&gt;snapshot = snaplen;
00255 
00256     <span class="comment">/* allocate Packet structure used during the capture */</span>
00257     <span class="keywordflow">if</span>((p-&gt;Packet = <a class="code" href="group__packet32.html#a23">PacketAllocatePacket</a>())==NULL){
00258         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"failed to allocate the PACKET structure"</span>);
00259         <span class="keywordflow">goto</span> bad;
00260     }
00261 
00262     <a class="code" href="Packet32_8c.html#a25">PacketInitPacket</a>(p-&gt;Packet,(BYTE*)p-&gt;buffer,p-&gt;bufsize);
00263 
00264     <span class="comment">/* allocate the standard buffer in the driver */</span>
00265     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a37">PacketSetBuff</a>( p-&gt;adapter, SIZE_BUF)==FALSE)
00266     {
00267         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE,<span class="stringliteral">"driver error: not enough memory to allocate the kernel buffer\n"</span>);
00268         <span class="keywordflow">goto</span> bad;
00269     }
00270 
00271     <span class="comment">/* tell the driver to copy the buffer only if it contains at least 16K */</span>
00272     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a29">PacketSetMinToCopy</a>(p-&gt;adapter,16000)==FALSE)
00273     {
00274         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(ebuf, PCAP_ERRBUF_SIZE,<span class="stringliteral">"Error calling PacketSetMinToCopy: %s\n"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00275         <span class="keywordflow">goto</span> bad;
00276     }
00277 
00278     <a class="code" href="Packet32_8c.html#a36">PacketSetReadTimeout</a>(p-&gt;adapter, to_ms);
00279 
00280     <span class="keywordflow">return</span> (p);
00281 bad:
00282     <span class="keywordflow">if</span> (p-&gt;adapter)
00283         <a class="code" href="Packet32_8c.html#a22">PacketCloseAdapter</a>(p-&gt;adapter);
00284     <span class="keywordflow">if</span> (p-&gt;buffer != NULL)
00285         free(p-&gt;buffer);
00286     free(p);
00287     <span class="keywordflow">return</span> (NULL);
00288 }
00289 
00290 
00291 <span class="keywordtype">int</span>
<a name="l00292"></a><a class="code" href="Pcap-win32_8c.html#a8">00292</a> <a class="code" href="Pcap-win32_8c.html#a8">pcap_setfilter</a>(pcap_t *p, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *fp)
00293 {
00294 <span class="preprocessor">#ifdef REMOTE</span>
00295 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (p-&gt;rmt_clientside)
00296     {
00297         <span class="comment">/* We are on an remote capture */</span>
00298         <span class="keywordflow">return</span> <a class="code" href="pcap-remote_8c.html#a18">pcap_setfilter_remote</a>(p, fp);
00299     }
00300 <span class="preprocessor">#endif</span>
00301 <span class="preprocessor"></span>
00302     <span class="keywordflow">if</span>(p-&gt;adapter==NULL){
00303         <span class="comment">/* Offline capture: make our own copy of the filter */</span>
00304         <span class="keywordflow">if</span> (install_bpf_program(p, fp) &lt; 0)
00305             <span class="keywordflow">return</span> (-1);
00306     }
00307     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a38">PacketSetBpf</a>(p-&gt;adapter,fp)==FALSE){
00308         <span class="comment">/* kernel filter not installed. */</span>
00309         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Driver error: cannot set bpf filter: %s"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00310         <span class="keywordflow">return</span> (-1);
00311     }
00312     <span class="keywordflow">return</span> (0);
00313 }
00314 
00315 
00316 <span class="comment">/* Set the driver working mode */</span>
00317 <span class="keywordtype">int</span> 
<a name="l00318"></a><a class="code" href="Pcap-win32_8c.html#a9">00318</a> <a class="code" href="Pcap-win32_8c.html#a9">pcap_setmode</a>(pcap_t *p, <span class="keywordtype">int</span> mode){
00319     
00320     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00321     {
00322         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"impossible to set mode while reading from a file"</span>);
00323         <span class="keywordflow">return</span> -1;
00324     }
00325 
00326     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a30">PacketSetMode</a>(p-&gt;adapter,mode)==FALSE)
00327     {
00328         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"driver error: working mode not recognized"</span>);
00329         <span class="keywordflow">return</span> -1;
00330     }
00331 
00332     <span class="keywordflow">return</span> 0;
00333 }
00334 
00335 <span class="comment">/* Send a packet to the network */</span>
00336 <span class="keywordtype">int</span> 
<a name="l00337"></a><a class="code" href="Pcap-win32_8c.html#a10">00337</a> <a class="code" href="Pcap-win32_8c.html#a10">pcap_sendpacket</a>(pcap_t *p, u_char *buf, <span class="keywordtype">int</span> size){
00338     <a class="code" href="struct__PACKET.html">LPPACKET</a> PacketToSend;
00339 
00340     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00341     {
00342         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Writing a packet is allowed only on a physical adapter"</span>);
00343         <span class="keywordflow">return</span> -1;
00344     }
00345 
00346     PacketToSend=<a class="code" href="group__packet32.html#a23">PacketAllocatePacket</a>();
00347     <a class="code" href="Packet32_8c.html#a25">PacketInitPacket</a>(PacketToSend,buf,size);
00348     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a27">PacketSendPacket</a>(p-&gt;adapter,PacketToSend,TRUE) == FALSE){
00349         <a class="code" href="Packet32_8c.html#a24">PacketFreePacket</a>(PacketToSend);
00350         <span class="keywordflow">return</span> -1;
00351     }
00352 
00353     <a class="code" href="Packet32_8c.html#a24">PacketFreePacket</a>(PacketToSend);
00354     <span class="keywordflow">return</span> 0;
00355 }
00356 
00357 <span class="comment">/* Set the dimension of the kernel-level capture buffer */</span>
00358 <span class="keywordtype">int</span> 
<a name="l00359"></a><a class="code" href="Pcap-win32_8c.html#a11">00359</a> <a class="code" href="Pcap-win32_8c.html#a11">pcap_setbuff</a>(pcap_t *p, <span class="keywordtype">int</span> dim)
00360 {
00361     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00362     {
00363         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The kernel buffer size cannot be set while reading from a file"</span>);
00364         <span class="keywordflow">return</span> -1;
00365     }
00366     
00367     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a37">PacketSetBuff</a>(p-&gt;adapter,dim)==FALSE)
00368     {
00369         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"driver error: not enough memory to allocate the kernel buffer"</span>);
00370         <span class="keywordflow">return</span> -1;
00371     }
00372     <span class="keywordflow">return</span> 0;
00373 }
00374 
00375 <span class="comment">/*set the minimum amount of data that will release a read call*/</span>
00376 <span class="keywordtype">int</span> 
<a name="l00377"></a><a class="code" href="Pcap-win32_8c.html#a12">00377</a> <a class="code" href="Pcap-win32_8c.html#a12">pcap_setmintocopy</a>(pcap_t *p, <span class="keywordtype">int</span> size)
00378 {
00379     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00380     {
00381         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Impossible to set the mintocopy parameter on an offline capture"</span>);
00382         <span class="keywordflow">return</span> -1;
00383     }   
00384 
00385     <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a29">PacketSetMinToCopy</a>(p-&gt;adapter, size)==FALSE)
00386     {
00387         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"driver error: unable to set the requested mintocopy size"</span>);
00388         <span class="keywordflow">return</span> -1;
00389     }
00390     <span class="keywordflow">return</span> 0;
00391 }
00392 
00393 <span class="keywordtype">int</span>
<a name="l00394"></a><a class="code" href="Pcap-win32_8c.html#a13">00394</a> <a class="code" href="Pcap-win32_8c.html#a13">pcap_set_datalink_platform</a>(pcap_t *p, <span class="keywordtype">int</span> dlt)
00395 {
00396     <span class="keywordflow">return</span> (0);
00397 }
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
