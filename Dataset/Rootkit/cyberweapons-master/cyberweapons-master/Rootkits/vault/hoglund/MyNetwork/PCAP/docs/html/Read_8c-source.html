<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Read.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Read.c</h1><a href="Read_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999, 2000</span>
00003 <span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the Politecnico</span>
00013 <span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00023 <span class="preprocessor">#include "ntddk.h"</span>
00024 <span class="preprocessor">#include &lt;ntiologc.h&gt;</span>
00025 <span class="preprocessor">#include &lt;ndis.h&gt;</span>
00026 <span class="preprocessor">#include "debug.h"</span>
00027 <span class="preprocessor">#include "packet.h"</span>
00028 <span class="preprocessor">#include "win_bpf.h"</span>
00029 
00030 <span class="preprocessor">#include "tme.h"</span>
00031 <span class="preprocessor">#include "time_calls.h"</span>
00032 
<a name="l00033"></a><a class="code" href="Read_8c.html#a0">00033</a> <span class="keyword">extern</span> <span class="keyword">struct </span>time_conv <a class="code" href="Openclos_8c.html#a3">G_Start_Time</a>; <span class="comment">// from openclos.c</span>
00034 
<a name="l00035"></a><a class="code" href="Read_8c.html#a1">00035</a> <span class="keyword">extern</span> ULONG <a class="code" href="Packet_8c.html#a10">NCpu</a>; <span class="comment">//from packet.c</span>
00036 
<a name="l00037"></a><a class="code" href="Read_8c.html#a2">00037</a> NTSTATUS <a class="code" href="Read_8c.html#a2">NPF_Read</a>(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
00038 {
00039     <a class="code" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>      Open;
00040     PIO_STACK_LOCATION  IrpSp;
00041     PUCHAR              packp;
00042     ULONG               Input_Buffer_Length;
00043     UINT                Thead;
00044     UINT                Ttail;
00045     UINT                TLastByte;
00046     PUCHAR              CurrBuff;
00047     LARGE_INTEGER       CapTime;
00048     LARGE_INTEGER       TimeFreq;
00049     <span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>      *header;
00050     KIRQL               Irql;
00051     PUCHAR              UserPointer;
00052     ULONG               bytecopy;
00053     UINT                SizeToCopy;
00054     UINT                PktLen;
00055     ULONG               copied,count,current_cpu,av,plen,increment,ToCopy,available;
00056     <a class="code" href="struct____CPU__Private__Data.html">CpuPrivateData</a>      *LocalData;
00057     ULONG               i;
00058     ULONG               Occupation;
00059     IF_LOUD(DbgPrint(<span class="stringliteral">"NPF: Read\n"</span>);)
00060         
00061     IrpSp = IoGetCurrentIrpStackLocation(Irp);
00062     Open=IrpSp-&gt;FileObject-&gt;FsContext;
00063 
00064     <span class="keywordflow">if</span>( Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m26">Bound</a> == FALSE ){
00065         <span class="comment">// The Network adapter was removed.</span>
00066         <a class="code" href="group__NPF__include.html#a43">EXIT_FAILURE</a>(0);
00067     }
00068     
00069     <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> == 0)    
00070     {
00071         <a class="code" href="group__NPF__include.html#a43">EXIT_FAILURE</a>(0);
00072     }
00073 
00074     <span class="keywordflow">if</span>( Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a> &amp;&amp; Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m27">DumpFileHandle</a> == NULL ){  
00075         <span class="comment">// this instance is in dump mode, but the dump file has still not been opened</span>
00076         <a class="code" href="group__NPF__include.html#a43">EXIT_FAILURE</a>(0);
00077     }
00078     
00079     Occupation=0;
00080 
00081     <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="Packet_8c.html#a10">NCpu</a>;i++)
00082         Occupation += (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[i].<a class="code" href="struct____CPU__Private__Data.html#m2">Free</a>);
00083     
00084     <span class="comment">//See if the buffer is full enough to be copied</span>
00085     <span class="keywordflow">if</span>( Occupation &lt;= Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m15">MinToCopy</a>*<a class="code" href="Packet_8c.html#a10">NCpu</a> || Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a> )
00086     {
00087         <span class="comment">//wait until some packets arrive or the timeout expires     </span>
00088         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m16">TimeOut</a>.QuadPart != (LONGLONG)<a class="code" href="group__NPF__include.html#a36">IMMEDIATE</a>)
00089             KeWaitForSingleObject(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,
00090                 UserRequest,
00091                 KernelMode,
00092                 TRUE,
00093                 (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m16">TimeOut</a>.QuadPart == (LONGLONG)0)? NULL: &amp;(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m16">TimeOut</a>));
00094 
00095         KeClearEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>);
00096         
00097         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a33">MODE_STAT</a>){   <span class="comment">//this capture instance is in statistics mode</span>
00098             CurrBuff=(PUCHAR)MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);
00099             
00100             <span class="comment">//fill the bpf header for this packet</span>
00101             header=(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>*)CurrBuff;
00102             GET_TIME(&amp;header-&gt;<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>,&amp;G_Start_Time);
00103 
00104             <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>){
00105                 *(LONGLONG*)(CurrBuff+<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>)+16)=Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m32">DumpOffset</a>.QuadPart;
00106                 header-&gt;<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a>=24;
00107                 header-&gt;<a class="code" href="structbpf__hdr.html#m2">bh_datalen</a>=24;
00108                 Irp-&gt;IoStatus.Information = 24 + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00109             }
00110             <span class="keywordflow">else</span>{
00111                 header-&gt;<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a>=16;
00112                 header-&gt;<a class="code" href="structbpf__hdr.html#m2">bh_datalen</a>=16;
00113                 header-&gt;<a class="code" href="structbpf__hdr.html#m3">bh_hdrlen</a>=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00114                 Irp-&gt;IoStatus.Information = 16 + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00115             }
00116 
00117             *(LONGLONG*)(CurrBuff+<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>))=Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m19">Npackets</a>.QuadPart;
00118             *(LONGLONG*)(CurrBuff+<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>)+8)=Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m18">Nbytes</a>.QuadPart;
00119             
00120             <span class="comment">//reset the countetrs</span>
00121             NdisAcquireSpinLock( &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m20">CountersLock</a> );
00122             Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m19">Npackets</a>.QuadPart=0;
00123             Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m18">Nbytes</a>.QuadPart=0;
00124             NdisReleaseSpinLock( &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m20">CountersLock</a> );
00125             
00126             Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
00127             IoCompleteRequest(Irp, IO_NO_INCREMENT);
00128             
00129             <span class="keywordflow">return</span> STATUS_SUCCESS;
00130         }
00131         
00132         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a>==<a class="code" href="group__NPF__include.html#a34">MODE_MON</a>)   <span class="comment">//this capture instance is in monitor mode</span>
00133         {   
00134             PTME_DATA data;
00135             ULONG cnt;
00136             ULONG block_size;
00137             PUCHAR tmp;
00138 
00139             UserPointer=MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);
00140             
00141             <span class="keywordflow">if</span> ((!IS_VALIDATED(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>.validated_blocks,Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>.active_read))||(IrpSp-&gt;Parameters.Read.Length&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>)))
00142             {   
00143                 <a class="code" href="group__NPF__include.html#a43">EXIT_FAILURE</a>(0);
00144             }
00145             
00146             header=(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>*)UserPointer;
00147     
00148             GET_TIME(&amp;header-&gt;<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>,&amp;G_Start_Time);
00149 
00150             
00151             header-&gt;<a class="code" href="structbpf__hdr.html#m3">bh_hdrlen</a>=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00152             
00153 
00154             <span class="comment">//moves user memory pointer</span>
00155             UserPointer+=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00156             
00157             <span class="comment">//calculus of data to be copied</span>
00158             <span class="comment">//if the user buffer is smaller than data to be copied,</span>
00159             <span class="comment">//only some data will be copied</span>
00160             data=&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>.block_data[Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>.active_read];
00161 
00162             <span class="keywordflow">if</span> (data-&gt;last_read.tv_sec!=0)
00163                 data-&gt;last_read=header-&gt;<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>;
00164             
00165 
00166             bytecopy=data-&gt;block_size*data-&gt;filled_blocks;
00167             
00168             <span class="keywordflow">if</span> ((IrpSp-&gt;Parameters.Read.Length-<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>))&lt;bytecopy)
00169                 bytecopy=(IrpSp-&gt;Parameters.Read.Length-<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>))/ data-&gt;block_size;
00170             <span class="keywordflow">else</span> 
00171                 bytecopy=data-&gt;filled_blocks;
00172 
00173             tmp=data-&gt;shared_memory_base_address;
00174             block_size=data-&gt;block_size;
00175             
00176             <span class="keywordflow">for</span> (cnt=0;cnt&lt;bytecopy;cnt++)
00177             {
00178                 NdisAcquireSpinLock(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m39">MachineLock</a>);
00179                 RtlCopyMemory(UserPointer,tmp,block_size);
00180                 NdisReleaseSpinLock(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m39">MachineLock</a>);
00181                 tmp+=block_size;
00182                 UserPointer+=block_size;
00183             }
00184                         
00185             bytecopy*=block_size;
00186 
00187             header-&gt;<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a>=bytecopy;
00188             header-&gt;<a class="code" href="structbpf__hdr.html#m2">bh_datalen</a>=header-&gt;<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a>;
00189 
00190             <a class="code" href="group__NPF__include.html#a42">EXIT_SUCCESS</a>(bytecopy+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbpf__hdr.html">bpf_hdr</a>));
00191         }
00192 
00193         Occupation=0;
00194 
00195         <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="Packet_8c.html#a10">NCpu</a>;i++)
00196             Occupation += (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[i].<a class="code" href="struct____CPU__Private__Data.html#m2">Free</a>);
00197 
00198 
00199         <span class="keywordflow">if</span> ( Occupation == 0 || Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>)
00200             <span class="comment">// The timeout has expired, but the buffer is still empty (or the packets must be written to file).</span>
00201             <span class="comment">// We must awake the application, returning an empty buffer.</span>
00202         {
00203             <a class="code" href="group__NPF__include.html#a42">EXIT_SUCCESS</a>(0);
00204         }
00205                 
00206     }
00207 
00208 
00209 
00210 
00211 <span class="comment">//------------------------------------------------------------------------------</span>
00212     copied=0;
00213     count=0;
00214     current_cpu=0;
00215     available = IrpSp-&gt;Parameters.Read.Length;
00216     packp=(PUCHAR)MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);
00217 
00218     <span class="keywordflow">while</span> (count &lt; <a class="code" href="Packet_8c.html#a10">NCpu</a>) <span class="comment">//round robin on the CPUs, if count = NCpu there are no packets left to be copied</span>
00219     {
00220         <span class="keywordflow">if</span> (available == copied)
00221         {
00222             <a class="code" href="group__NPF__include.html#a42">EXIT_SUCCESS</a>(copied);
00223         }
00224         
00225         LocalData = &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[current_cpu];
00226 
00227         <span class="keywordflow">if</span> (LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m2">Free</a> &lt; Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)  
00228         {  <span class="comment">//there are some packets in the selected (aka LocalData) buffer</span>
00229             <span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a> *Header = (<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>*)(LocalData-&gt;Buffer + LocalData-&gt;C);
00230 
00231             <span class="keywordflow">if</span> ( Header-&gt;<a class="code" href="structPacketHeader.html#m0">SN</a> == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m42">ReaderSN</a>)
00232             {   <span class="comment">//check if it the next one to be copied</span>
00233                 plen = Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a>;
00234                 <span class="keywordflow">if</span> (plen + <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>) &gt; available-copied)  
00235                 {  <span class="comment">//if the packet does not fit into the user buffer, we've ended copying packets</span>
00236                     <a class="code" href="group__NPF__include.html#a42">EXIT_SUCCESS</a>(copied);
00237                 }
00238                 
00239                 *((<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>*)(&amp;packp[copied]))=Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>;
00240                 
00241                 copied += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00242                 LocalData-&gt;C += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00243 
00244                 <span class="keywordflow">if</span> (LocalData-&gt;C == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00245                     LocalData-&gt;C = 0;
00246 
00247                 <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;C &lt; plen)
00248                 {
00249                     <span class="comment">//the packet is fragmented in the buffer (i.e. it skips the buffer boundary)</span>
00250                     ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;C;
00251                     RtlCopyMemory(packp + copied,LocalData-&gt;Buffer + LocalData-&gt;C,ToCopy);
00252                     RtlCopyMemory(packp + copied + ToCopy,LocalData-&gt;Buffer,plen-ToCopy);
00253                     LocalData-&gt;C = plen-ToCopy;
00254                 }
00255                 <span class="keywordflow">else</span>
00256                 {
00257                     <span class="comment">//the packet is not fragmented</span>
00258                     RtlCopyMemory(packp + copied ,LocalData-&gt;Buffer + LocalData-&gt;C ,plen);
00259                     LocalData-&gt;C += plen;
00260             <span class="comment">//      if (c==size)  inutile, contemplato nell "header atomico"</span>
00261             <span class="comment">//          c=0;</span>
00262                 }
00263 
00264                 Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m42">ReaderSN</a>++;
00265                 copied+=<a class="code" href="group__packet32h.html#a38">Packet_WORDALIGN</a>(plen);
00266 
00267                 increment = plen + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00268                 <span class="keywordflow">if</span> ( Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;C &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>))
00269                 {   <span class="comment">//the next packet would be saved at the end of the buffer, but the NewHeader struct would be fragmented</span>
00270                     <span class="comment">//so the producer (--&gt; the consumer) skips to the beginning of the buffer</span>
00271                     increment += Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;C;
00272                     LocalData-&gt;C=0;
00273                 }
00274                 InterlockedExchangeAdd(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[current_cpu].<a class="code" href="struct____CPU__Private__Data.html#m2">Free</a>,increment);
00275                 count=0;
00276             }
00277             <span class="keywordflow">else</span>
00278             {
00279                 current_cpu=(current_cpu+1)%<a class="code" href="Packet_8c.html#a10">NCpu</a>;
00280                 count++;    
00281             }
00282         
00283         }
00284         <span class="keywordflow">else</span>
00285         {
00286             current_cpu=(current_cpu+1)%<a class="code" href="Packet_8c.html#a10">NCpu</a>;
00287             count++;    
00288         }
00289     }
00290         
00291     {<a class="code" href="group__NPF__include.html#a42">EXIT_SUCCESS</a>(copied);}
00292 
00293 <span class="comment">//------------------------------------------------------------------------------</span>
00294 
00295 }
00296 
<a name="l00297"></a><a class="code" href="Read_8c.html#a3">00297</a> NDIS_STATUS <a class="code" href="Read_8c.html#a3">NPF_tap</a> (IN NDIS_HANDLE ProtocolBindingContext,IN NDIS_HANDLE MacReceiveContext,
00298                         IN PVOID HeaderBuffer,IN UINT HeaderBufferSize,IN PVOID LookaheadBuffer,
00299                         IN UINT LookaheadBufferSize,IN UINT PacketSize)
00300 {
00301     <a class="code" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>      Open;
00302     PNDIS_PACKET        pPacket;
00303     ULONG               SizeToTransfer;
00304     NDIS_STATUS         Status;
00305     UINT                BytesTransfered;
00306     ULONG               BufferLength;
00307     PMDL                pMdl1,pMdl2;
00308     LARGE_INTEGER       CapTime;
00309     LARGE_INTEGER       TimeFreq;
00310     UINT                fres;
00311     USHORT              NPFHdrSize;
00312 
00313     <a class="code" href="struct____CPU__Private__Data.html">CpuPrivateData</a>      *LocalData;
00314     ULONG               Cpu;
00315     <span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a> *Header;
00316     ULONG               ToCopy;
00317     ULONG               increment;
00318     ULONG               i;
00319     BOOLEAN             Flag;
00320 
00321     IF_VERY_LOUD(DbgPrint(<span class="stringliteral">"NPF: tap\n"</span>);)
00322     IF_VERY_LOUD(DbgPrint(<span class="stringliteral">"HeaderBufferSize=%d, LookAheadBuffer=%d, LookaheadBufferSize=%d, PacketSize=%d\n"</span>, 
00323     HeaderBufferSize,
00324     LookaheadBuffer,
00325     LookaheadBufferSize,
00326     PacketSize);)
00327 
00328     Open= (POPEN_INSTANCE)ProtocolBindingContext;
00329     
00330     <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m45">SkipProcessing</a> == 1)  <span class="comment">//some IoCtl is modifying some shared structure, we must drop the packet.</span>
00331         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00332     
00333     Cpu = KeGetCurrentProcessorNumber();
00334     LocalData = &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[Cpu];
00335 
00336     LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 1;    <span class="comment">//this tells the Ioctls that we are processing a packet, they cannot modify anything</span>
00337                                   <span class="comment">//until ALL the Cpu have terminated their processing (aka, set their LocalData-&gt;processing to 0)</span>
00338     LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m5">Received</a>++;
00339     IF_LOUD(DbgPrint(<span class="stringliteral">"Received on CPU %d \t%d\n"</span>,Cpu,LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m5">Received</a>);)
00340 <span class="comment">//  Open-&gt;Received++;       // Number of packets received by filter ++</span>
00341 
00342     <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> == <a class="code" href="group__NPF__include.html#a34">MODE_MON</a>)
00343     {
00344         Flag = TRUE;
00345         NdisAcquireSpinLock(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m39">MachineLock</a>);
00346     }
00347     <span class="keywordflow">else</span>
00348         Flag = FALSE;
00349     
00350     <span class="comment">//</span>
00351     <span class="comment">//Check if the lookahead buffer follows the mac header.</span>
00352     <span class="comment">//If the data follow the header (i.e. there is only a buffer) a normal bpf_filter() is</span>
00353     <span class="comment">//executed on the packet.</span>
00354     <span class="comment">//Otherwise if there are 2 separate buffers (this could be the case of LAN emulation or</span>
00355     <span class="comment">//things like this) bpf_filter_with_2_buffers() is executed.</span>
00356     <span class="comment">//</span>
00357     <span class="keywordflow">if</span>((UINT)LookaheadBuffer-(UINT)HeaderBuffer != HeaderBufferSize)
00358         fres=<a class="code" href="group__NPF__code.html#a27">bpf_filter_with_2_buffers</a>((<span class="keyword">struct</span> <a class="code" href="structbpf__insn.html">bpf_insn</a>*)(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m13">bpfprogram</a>),
00359                                        HeaderBuffer,
00360                                        LookaheadBuffer,
00361                                        HeaderBufferSize,
00362                                        PacketSize+HeaderBufferSize,
00363                                        LookaheadBufferSize+HeaderBufferSize,
00364                                        &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m37">mem_ex</a>,
00365                                        &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>,
00366                                        &amp;G_Start_Time);
00367     
00368     
00369     <span class="keywordflow">else</span> 
00370         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m14">Filter</a> != NULL)
00371         {
00372             <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m13">bpfprogram</a> != NULL)
00373             {
00374                 fres=Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m14">Filter</a>-&gt;<a class="code" href="structJIT__BPF__Filter.html#m0">Function</a>(HeaderBuffer,
00375                                     PacketSize+HeaderBufferSize,
00376                                     LookaheadBufferSize+HeaderBufferSize);
00377         
00378                 <span class="comment">// Restore the stack. </span>
00379                 <span class="comment">// I ignore the reason, but this instruction is needed only at kernel level</span>
00380                 _asm add esp,12     
00381             }
00382             <span class="keywordflow">else</span>
00383                 fres = -1;
00384         }
00385         <span class="keywordflow">else</span>
00386             fres=<a class="code" href="group__NPF__code.html#a26">bpf_filter</a>((<span class="keyword">struct</span> bpf_insn*)(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m13">bpfprogram</a>),
00387                         HeaderBuffer,
00388                         PacketSize+HeaderBufferSize,
00389                         LookaheadBufferSize+HeaderBufferSize,
00390                         &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m37">mem_ex</a>,
00391                         &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m38">tme</a>,
00392                         &amp;G_Start_Time);
00393 
00394     <span class="keywordflow">if</span> (Flag)
00395         NdisReleaseSpinLock(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m39">MachineLock</a>);
00396     
00397     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a>==<a class="code" href="group__NPF__include.html#a34">MODE_MON</a>)
00398     <span class="comment">// we are in monitor mode</span>
00399     {
00400         <span class="keywordflow">if</span> (fres==1) 
00401             KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);
00402         LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 0;
00403         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00404 
00405     }
00406 
00407     <span class="keywordflow">if</span>(fres==0)
00408     {
00409         <span class="comment">// Packet not accepted by the filter, ignore it.</span>
00410         LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 0;
00411         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00412     }
00413 
00414     <span class="comment">//if the filter returns -1 the whole packet must be accepted</span>
00415     <span class="keywordflow">if</span>(fres==-1 || fres &gt; PacketSize+HeaderBufferSize)
00416         fres = PacketSize+HeaderBufferSize; 
00417 
00418     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a33">MODE_STAT</a>)
00419     {
00420     <span class="comment">// we are in statistics mode</span>
00421         NdisAcquireSpinLock( &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m20">CountersLock</a> );
00422 
00423         Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m19">Npackets</a>.QuadPart++;
00424         
00425         <span class="keywordflow">if</span>(PacketSize+HeaderBufferSize&lt;60)
00426             Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m18">Nbytes</a>.QuadPart+=60;
00427         <span class="keywordflow">else</span>
00428             Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m18">Nbytes</a>.QuadPart+=PacketSize+HeaderBufferSize;
00429         <span class="comment">// add preamble+SFD+FCS to the packet</span>
00430         <span class="comment">// these values must be considered because are not part of the packet received from NDIS</span>
00431         Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m18">Nbytes</a>.QuadPart+=12;
00432 
00433         NdisReleaseSpinLock( &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m20">CountersLock</a> );
00434         
00435         <span class="keywordflow">if</span>(!(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>))
00436         {
00437             LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 0;
00438             <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00439         }
00440     }
00441 
00442     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> == 0)
00443     {
00444         LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m6">Dropped</a>++;
00445         LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 0;
00446         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00447     }
00448 
00449     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a> &amp;&amp; Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m35">MaxDumpPacks</a>)
00450     {
00451         ULONG Accepted=0;
00452         <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="Packet_8c.html#a10">NCpu</a>;i++)
00453             Accepted+=Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[i].<a class="code" href="struct____CPU__Private__Data.html#m4">Accepted</a>;
00454         
00455         <span class="keywordflow">if</span>(  Accepted &gt; Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m35">MaxDumpPacks</a>)
00456         {
00457             <span class="comment">// Reached the max number of packets to save in the dump file. Discard the packet and stop the dump thread.</span>
00458             Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m36">DumpLimitReached</a> = TRUE; <span class="comment">// This stops the thread</span>
00459             <span class="comment">// Awake the dump thread</span>
00460             NdisSetEvent(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m31">DumpEvent</a>);
00461 
00462             <span class="comment">// Awake the application</span>
00463             KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);
00464 
00465             LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m7">Processing</a> = 0;
00466             <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00467         }
00468     }
00469 
00471 
00472     <span class="keywordflow">if</span> (fres + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>) &gt; LocalData-&gt;Free)
00473     {
00474         LocalData-&gt;Dropped++;
00475         LocalData-&gt;Processing = 0;
00476         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00477     }
00478 
00479     <span class="keywordflow">if</span> (LocalData-&gt;TransferMdl1 != NULL)
00480     {
00481         <span class="comment">//if TransferMdl is not NULL, there is some TransferData pending (i.e. not having called TransferDataComplete, yet)</span>
00482         <span class="comment">//in order to avoid buffer corruption, we drop the packet</span>
00483         LocalData-&gt;Dropped++;
00484         LocalData-&gt;Processing = 0;
00485         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00486     }
00487 
00488     <span class="keywordflow">if</span> (LookaheadBufferSize + HeaderBufferSize &gt;= fres)
00489     {
00490         <span class="comment">//we do not need to call NdisTransferData, either because we need only the HeaderBuffer, or because the LookaheadBuffer</span>
00491         <span class="comment">//contains what we need</span>
00492 
00493         Header = (<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>*)(LocalData-&gt;Buffer + LocalData-&gt;P);
00494         LocalData-&gt;Accepted++;
00495         GET_TIME(&amp;Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>,&amp;G_Start_Time);
00496         Header-&gt;<a class="code" href="structPacketHeader.html#m0">SN</a> = InterlockedIncrement(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m43">WriterSN</a>) - 1;
00497 
00498         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a> = fres;
00499         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m2">bh_datalen</a> = PacketSize + HeaderBufferSize;
00500         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m3">bh_hdrlen</a>=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00501 
00502         LocalData-&gt;P +=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00503         <span class="keywordflow">if</span> (LocalData-&gt;P == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00504             LocalData-&gt;P = 0;
00505 
00506         <span class="keywordflow">if</span> ( fres &lt;= HeaderBufferSize || ( (ULONG)LookaheadBuffer - (ULONG)HeaderBuffer ) == HeaderBufferSize )
00507         {
00508             <span class="comment">//we can consider the buffer contiguous, either because we use only the data </span>
00509             <span class="comment">//present in the HeaderBuffer, or because HeaderBuffer and LookaheadBuffer are contiguous</span>
00510             <span class="comment">// ;-))))))</span>
00511 
00512             <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &lt; fres)
00513             {
00514                 <span class="comment">//the packet will be fragmented in the buffer (aka, it will skip the buffer boundary)</span>
00515                 <span class="comment">//two copies!!</span>
00516                 ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P;
00517                 NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P,HeaderBuffer, ToCopy);
00518                 NdisMoveMappedMemory(LocalData-&gt;Buffer + 0 , (PUCHAR)HeaderBuffer + ToCopy, fres - ToCopy);
00519                 LocalData-&gt;P = fres-ToCopy;
00520             }
00521             <span class="keywordflow">else</span>
00522             {
00523                 <span class="comment">//the packet does not need to be fragmented in the buffer (aka, it doesn't skip the buffer boundary)</span>
00524                 <span class="comment">// ;-)))))) only ONE copy</span>
00525                 NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, HeaderBuffer, fres);
00526                 LocalData-&gt;P += fres;
00527             }
00528         }
00529         <span class="keywordflow">else</span>
00530         {
00531             <span class="comment">//HeaderBuffer and LookAhead buffer are NOT contiguous,</span>
00532             <span class="comment">//AND, we need some bytes from the LookaheadBuffer, too</span>
00533             <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &lt; fres)
00534             {
00535                 <span class="comment">//the packet will be fragmented in the buffer (aka, it will skip the buffer boundary)</span>
00536                 <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &gt;= HeaderBufferSize)
00537                 {
00538                     <span class="comment">//HeaderBuffer is NOT fragmented</span>
00539                     NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, HeaderBuffer, HeaderBufferSize);
00540                     LocalData-&gt;P += HeaderBufferSize;
00541                     
00542                     <span class="keywordflow">if</span> (LocalData-&gt;P == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00543                     {
00544                         <span class="comment">//the fragmentation of the packet in the buffer is the same fragmentation</span>
00545                         <span class="comment">//in HeaderBuffer+LookaheadBuffer</span>
00546                         LocalData-&gt;P=0; 
00547                         NdisMoveMappedMemory(LocalData-&gt;Buffer + 0, LookaheadBuffer, fres - HeaderBufferSize);
00548                         LocalData-&gt;P += (fres - HeaderBufferSize);
00549                     }
00550                     <span class="keywordflow">else</span>
00551                     {
00552                         <span class="comment">//LookAheadBuffer is fragmented, two copies</span>
00553                         ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P;
00554                         NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, LookaheadBuffer, ToCopy);
00555                         LocalData-&gt;P=0;
00556                         NdisMoveMappedMemory(LocalData-&gt;Buffer + 0, (PUCHAR)LookaheadBuffer+ ToCopy, fres - HeaderBufferSize - ToCopy);
00557                         LocalData-&gt;P = fres - HeaderBufferSize - ToCopy;
00558                     }
00559                 }
00560                 <span class="keywordflow">else</span>
00561                 {
00562                     <span class="comment">//HeaderBuffer is fragmented in the buffer (aka, it will skip the buffer boundary)</span>
00563                     <span class="comment">//two copies to copy the HeaderBuffer</span>
00564                     ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P;
00565                     NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, HeaderBuffer, ToCopy);
00566                     LocalData-&gt;P = 0;
00567                     NdisMoveMappedMemory(LocalData-&gt;Buffer + 0, (PUCHAR)HeaderBuffer + ToCopy, HeaderBufferSize - ToCopy);
00568                     LocalData-&gt;P = HeaderBufferSize - ToCopy;
00569                     
00570                     <span class="comment">//only one copy to copy the LookaheadBuffer</span>
00571                     NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, LookaheadBuffer, fres- HeaderBufferSize);
00572                     LocalData-&gt;P += (fres - HeaderBufferSize);
00573                 }
00574             }
00575             <span class="keywordflow">else</span>
00576             {   
00577                 <span class="comment">//the packet won't be fragmented in the destination buffer (aka, it won't skip the buffer boundary)</span>
00578                 <span class="comment">//two copies, the former to copy the HeaderBuffer, the latter to copy the LookaheadBuffer</span>
00579                 NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, HeaderBuffer, HeaderBufferSize);
00580                 LocalData-&gt;P += HeaderBufferSize;
00581                 NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;P, LookaheadBuffer, fres - HeaderBufferSize);
00582                 LocalData-&gt;P += (fres - HeaderBufferSize);
00583             }        
00584         }       
00585 
00586         increment = fres + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00587         <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>))  <span class="comment">//we check that the available, AND contiguous, space in the buffer will fit</span>
00588         {                                                          <span class="comment">//the NewHeader structure, at least, otherwise we skip the producer</span>
00589             increment += Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;P;                  <span class="comment">//at the beginning of the buffer (p = 0), and decrement the free bytes appropriately</span>
00590             LocalData-&gt;P = 0;
00591         }
00592 
00593         InterlockedExchangeAdd(&amp;LocalData-&gt;Free, (ULONG)(-(LONG)increment));
00594         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;Free &gt;= Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m15">MinToCopy</a>)
00595         {
00596             <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>)
00597                 NdisSetEvent(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m31">DumpEvent</a>);
00598             <span class="keywordflow">else</span>
00599                 KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);    
00600         }
00601 
00602         LocalData-&gt;Processing = 0;
00603         <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00604     }
00605     <span class="keywordflow">else</span>
00606     {
00607         IF_LOUD(DbgPrint(<span class="stringliteral">"TransferData!!\n"</span>);)
00608         <span class="comment">//ndisTransferData required</span>
00609         LocalData-&gt;NewP = LocalData-&gt;P;
00610 
00611         LocalData-&gt;NewP +=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00612         <span class="keywordflow">if</span> (LocalData-&gt;NewP == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00613             LocalData-&gt;NewP = 0;
00614 
00615         <span class="comment">//first of all, surely the header must be copied</span>
00616         <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;NewP &gt;= HeaderBufferSize)
00617         {
00618             <span class="comment">//1 copy!</span>
00619             NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;NewP, HeaderBuffer, HeaderBufferSize);
00620             LocalData-&gt;NewP += HeaderBufferSize;
00621             <span class="keywordflow">if</span> (LocalData-&gt;NewP == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00622                 LocalData-&gt;NewP = 0;
00623         }
00624         <span class="keywordflow">else</span>
00625         {
00626             ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP;
00627             NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;NewP, HeaderBuffer, ToCopy);
00628             NdisMoveMappedMemory(LocalData-&gt;Buffer + 0, (PUCHAR)HeaderBuffer + ToCopy, HeaderBufferSize - ToCopy);
00629             LocalData-&gt;NewP = HeaderBufferSize - ToCopy;
00630         }
00631 
00632         <span class="comment">//then we copy the Lookahead buffer</span>
00633 
00634         <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;NewP &gt;= LookaheadBufferSize)
00635         {
00636             <span class="comment">//1 copy!</span>
00637             NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;NewP, LookaheadBuffer, LookaheadBufferSize);
00638             LocalData-&gt;NewP += LookaheadBufferSize;
00639             <span class="keywordflow">if</span> (LocalData-&gt;NewP == Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>)
00640                 LocalData-&gt;NewP = 0;
00641         }
00642         <span class="keywordflow">else</span>
00643         {
00644             ToCopy = Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP;
00645             NdisMoveMappedMemory(LocalData-&gt;Buffer + LocalData-&gt;NewP, LookaheadBuffer, ToCopy);
00646             NdisMoveMappedMemory(LocalData-&gt;Buffer + 0, (PUCHAR)LookaheadBuffer + ToCopy, LookaheadBufferSize - ToCopy);
00647             LocalData-&gt;NewP = LookaheadBufferSize - ToCopy;
00648         }
00649 
00650         <span class="comment">//Now we must prepare the buffer(s) for the NdisTransferData</span>
00651         <span class="keywordflow">if</span> ((Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP) &gt;= (fres - HeaderBufferSize - LookaheadBufferSize))
00652         {
00653             <span class="comment">//only 1 buffer</span>
00654             pMdl1 = IoAllocateMdl(
00655                 LocalData-&gt;Buffer + LocalData-&gt;NewP, 
00656                 fres - HeaderBufferSize - LookaheadBufferSize,
00657                 FALSE,
00658                 FALSE,
00659                 NULL);
00660             
00661             <span class="keywordflow">if</span> (pMdl1 == NULL)
00662             {
00663                 IF_LOUD(DbgPrint(<span class="stringliteral">"Error allocating Mdl1\n"</span>);)
00664                 LocalData-&gt;Dropped++;
00665                 LocalData-&gt;Processing = 0;
00666                 <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00667             }
00668 
00669             MmBuildMdlForNonPagedPool(pMdl1);
00670             pMdl2=NULL;
00671             LocalData-&gt;NewP += fres - HeaderBufferSize - LookaheadBufferSize;
00672 
00673 
00674         }
00675         <span class="keywordflow">else</span>
00676         {
00677             <span class="comment">//2 buffers</span>
00678             pMdl1 = IoAllocateMdl(
00679                 LocalData-&gt;Buffer + LocalData-&gt;NewP, 
00680                 Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP,
00681                 FALSE,
00682                 FALSE,
00683                 NULL);
00684             
00685             <span class="keywordflow">if</span> (pMdl1 == NULL)
00686             {
00687                 IF_LOUD(DbgPrint(<span class="stringliteral">"Error allocating Mdl1\n"</span>);)
00688                 LocalData-&gt;Dropped++;
00689                 LocalData-&gt;Processing = 0;
00690                 <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00691             }
00692 
00693             pMdl2 = IoAllocateMdl(
00694                 LocalData-&gt;Buffer + 0, 
00695                 fres - HeaderBufferSize - LookaheadBufferSize - (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP),
00696                 FALSE,
00697                 FALSE,
00698                 NULL);
00699             
00700             <span class="keywordflow">if</span> (pMdl2 == NULL)
00701             {
00702                 IF_LOUD(DbgPrint(<span class="stringliteral">"Error allocating Mdl2\n"</span>);)
00703                 IoFreeMdl(pMdl1);
00704                 LocalData-&gt;Dropped++;
00705                 LocalData-&gt;Processing = 0;
00706                 <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00707             }
00708 
00709             LocalData-&gt;NewP = fres - HeaderBufferSize - LookaheadBufferSize - (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;NewP);
00710 
00711             MmBuildMdlForNonPagedPool(pMdl1);
00712             MmBuildMdlForNonPagedPool(pMdl2);
00713         }
00714 
00715 
00716         NdisAllocatePacket(&amp;Status, &amp;pPacket, Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m3">PacketPool</a>);
00717 
00718         <span class="keywordflow">if</span> (Status != NDIS_STATUS_SUCCESS)
00719         {
00720             IF_LOUD(DbgPrint(<span class="stringliteral">"NPF: Tap - No free packets\n"</span>);)
00721             IoFreeMdl(pMdl1);
00722             <span class="keywordflow">if</span> (pMdl2 != NULL)
00723                 IoFreeMdl(pMdl2);
00724             LocalData-&gt;Dropped++;
00725             LocalData-&gt;Processing = 0;
00726             <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00727         }
00728 
00729         <span class="keywordflow">if</span> (pMdl2 != NULL)
00730             NdisChainBufferAtFront(pPacket,pMdl2);
00731         
00732         NdisChainBufferAtFront(pPacket,pMdl1);
00733 
00734         <a class="code" href="group__NPF__include.html#a40">RESERVED</a>(pPacket)-&gt;Cpu = Cpu;
00735 
00736         LocalData-&gt;TransferMdl1 = pMdl1;    
00737         LocalData-&gt;TransferMdl2 = pMdl2;    
00738 
00739     
00740         Header = (<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>*)(LocalData-&gt;Buffer + LocalData-&gt;P);
00741         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a> = fres;
00742         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m2">bh_datalen</a> = PacketSize + HeaderBufferSize;
00743         Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m3">bh_hdrlen</a>=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a>);
00744 
00745         NdisTransferData(
00746                 &amp;Status,
00747                 Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m1">AdapterHandle</a>,
00748                 MacReceiveContext,
00749                 LookaheadBufferSize,
00750                 fres - HeaderBufferSize - LookaheadBufferSize,
00751                 pPacket,
00752                 &amp;BytesTransfered);
00753 
00754         <span class="keywordflow">if</span> (Status != NDIS_STATUS_PENDING)
00755         {
00756             IF_LOUD(DbgPrint(<span class="stringliteral">"NdisTransferData, not pending!\n"</span>);)  
00757             LocalData-&gt;TransferMdl1 = NULL;
00758             LocalData-&gt;TransferMdl2 = NULL;
00759 
00760             IoFreeMdl(pMdl1);
00761             <span class="keywordflow">if</span> ( pMdl2 != NULL )
00762                 IoFreeMdl(pMdl2);
00763 
00764             NdisReinitializePacket(pPacket);
00765             <span class="comment">// Put the packet on the free queue</span>
00766             NdisFreePacket(pPacket);
00767 
00768             LocalData-&gt;P = LocalData-&gt;NewP;
00769 
00770             LocalData-&gt;Accepted++;
00771             GET_TIME(&amp;Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>,&amp;G_Start_Time);
00772             Header-&gt;<a class="code" href="structPacketHeader.html#m0">SN</a> = InterlockedIncrement(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m43">WriterSN</a>) - 1;
00773 
00774             increment = fres + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00775             <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>))
00776             {
00777                 increment += Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;P;
00778                 LocalData-&gt;P = 0;
00779             }
00780 
00781             InterlockedExchangeAdd(&amp;LocalData-&gt;Free, (ULONG)(-(LONG)increment));
00782 
00783             <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;Free &gt;= Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m15">MinToCopy</a>)
00784             {
00785                 <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>)
00786                     NdisSetEvent(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m31">DumpEvent</a>);
00787                 <span class="keywordflow">else</span>
00788                     KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);    
00789             }
00790 
00791             LocalData-&gt;Processing = 0;
00792             <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00793         }
00794         <span class="keywordflow">else</span>
00795         {
00796             DbgPrint(<span class="stringliteral">"NdisTransferData, pending!\n"</span>);   
00797             <span class="keywordflow">return</span> NDIS_STATUS_NOT_ACCEPTED;
00798         }
00799     }
00800 
00801     <span class="keywordflow">return</span> NDIS_STATUS_SUCCESS;
00802     
00803 }
00804 
00805 <span class="comment">//-------------------------------------------------------------------</span>
00806 
<a name="l00807"></a><a class="code" href="Read_8c.html#a4">00807</a> VOID <a class="code" href="Read_8c.html#a4">NPF_TransferDataComplete</a> (IN NDIS_HANDLE ProtocolBindingContext,IN PNDIS_PACKET pPacket,
00808                                  IN NDIS_STATUS Status,IN UINT BytesTransfered)
00809 {
00810     <a class="code" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>      Open;
00811     ULONG               Cpu;
00812     <a class="code" href="struct____CPU__Private__Data.html">CpuPrivateData</a>      *LocalData;
00813     <span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>*    Header;
00814     ULONG               increment;
00815 
00816     IF_LOUD(DbgPrint(<span class="stringliteral">"NPF: TransferDataComplete\n"</span>);)
00817     
00818     Open = (POPEN_INSTANCE)ProtocolBindingContext;
00819 
00820     Cpu = <a class="code" href="group__NPF__include.html#a40">RESERVED</a>(pPacket)-&gt;Cpu;
00821 
00822     LocalData = &amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m41">CpuData</a>[Cpu];
00823 
00824     IoFreeMdl(LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m8">TransferMdl1</a>);
00825     <span class="keywordflow">if</span> ( LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m9">TransferMdl2</a> != NULL )
00826         IoFreeMdl(LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m9">TransferMdl2</a>);
00827 
00828     NdisReinitializePacket(pPacket);
00829     <span class="comment">// Put the packet on the free queue</span>
00830     NdisFreePacket(pPacket);
00831 
00832     <span class="comment">//the packet has been successfully copied to the kernel buffer, we can prepend it with the PacketHeader,</span>
00833     <span class="comment">//and obtain the sequence number and the timestamp</span>
00834 
00835     LocalData-&gt;<a class="code" href="struct____CPU__Private__Data.html#m4">Accepted</a>++;
00836     Header = (<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>*)(LocalData-&gt;Buffer + LocalData-&gt;P);
00837     GET_TIME(&amp;Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m0">bh_tstamp</a>,&amp;G_Start_Time);
00838     Header-&gt;<a class="code" href="structPacketHeader.html#m0">SN</a> = InterlockedIncrement(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m43">WriterSN</a>) - 1;
00839 
00840     LocalData-&gt;P = LocalData-&gt;NewP;
00841     
00842     increment = Header-&gt;<a class="code" href="structPacketHeader.html#m1">header</a>.<a class="code" href="structbpf__hdr.html#m1">bh_caplen</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>);
00843     <span class="keywordflow">if</span> (Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;P &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structPacketHeader.html">PacketHeader</a>))
00844     {
00845         increment += Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a>-LocalData-&gt;P;
00846         LocalData-&gt;P = 0;
00847     }
00848 
00849     InterlockedExchangeAdd(&amp;LocalData-&gt;Free, (ULONG)(-(LONG)increment));
00850 
00851     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;Free &gt;= Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m15">MinToCopy</a>)
00852     {
00853         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>)
00854             NdisSetEvent(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m31">DumpEvent</a>);
00855         <span class="keywordflow">else</span>
00856             KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);    
00857     }
00858 
00859     LocalData-&gt;TransferMdl1 = NULL;
00860     LocalData-&gt;TransferMdl2 = NULL;
00861     LocalData-&gt;Processing = 0;
00862 
00863 <span class="comment">// Unfreeze the consumer</span>
00864     <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m44">Size</a> - LocalData-&gt;Free &gt; Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m15">MinToCopy</a>)
00865     {
00866         <span class="keywordflow">if</span>(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m17">mode</a> &amp; <a class="code" href="group__NPF__include.html#a35">MODE_DUMP</a>)
00867             NdisSetEvent(&amp;Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m31">DumpEvent</a>);
00868         <span class="keywordflow">else</span>
00869             KeSetEvent(Open-&gt;<a class="code" href="struct__OPEN__INSTANCE.html#m10">ReadEvent</a>,0,FALSE);    
00870     }
00871     <span class="keywordflow">return</span>;
00872 }
00873 
00874 <span class="comment">//-------------------------------------------------------------------</span>
00875 
<a name="l00876"></a><a class="code" href="Read_8c.html#a5">00876</a> VOID <a class="code" href="Read_8c.html#a5">NPF_ReceiveComplete</a>(IN NDIS_HANDLE ProtocolBindingContext)
00877 {
00878     IF_VERY_LOUD(DbgPrint(<span class="stringliteral">"NPF: NPF_ReceiveComplete\n"</span>);)
00879     <span class="keywordflow">return</span>;
00880 }
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
