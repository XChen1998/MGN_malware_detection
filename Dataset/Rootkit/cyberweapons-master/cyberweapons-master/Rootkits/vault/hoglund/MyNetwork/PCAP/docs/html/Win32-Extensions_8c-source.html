<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Win32-Extensions.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Win32-Extensions.c</h1><a href="Win32-Extensions_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 - 2002</span>
00003 <span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the Politecnico</span>
00013 <span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="preprocessor">#include "pcap-int.h"</span>
00023 <span class="preprocessor">#include &lt;packet32.h&gt;</span>
00024 
00025 <span class="preprocessor">#ifdef REMOTE</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029 
00030 HANDLE
<a name="l00031"></a><a class="code" href="Win32-Extensions_8c.html#a0">00031</a> <a class="code" href="Win32-Extensions_8c.html#a0">pcap_getevent</a>(pcap_t *p)
00032 {
00033     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00034     {
00035         sprintf(p-&gt;errbuf, <span class="stringliteral">"The read event cannot be retrieved while reading from a file"</span>);
00036         <span class="keywordflow">return</span> NULL;
00037     }   
00038 
00039     <span class="keywordflow">return</span> <a class="code" href="Packet32_8c.html#a34">PacketGetReadEvent</a>(p-&gt;adapter);
00040 }
00041 
00042 
00043 
00044 <span class="comment">/*</span>
00045 <span class="comment">This way is definitely safer than passing the pcap_stat * from the userland. In fact, there could</span>
00046 <span class="comment">happen than the user allocates a variable which is not big enough for the new structure, and the</span>
00047 <span class="comment">library will write in a zone which is not allocated to this variable.</span>
00048 <span class="comment">In this way, we're pretty sure we are writing on memory allocated to this variable.</span>
00049 <span class="comment">*/</span>
00050 <span class="keyword">struct </span><a class="code" href="structpcap__stat.html">pcap_stat</a> *
<a name="l00051"></a><a class="code" href="Win32-Extensions_8c.html#a1">00051</a> <a class="code" href="group__wpcap__fn.html#a44">pcap_stats_ex</a>(<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p)
00052 {
00053 <span class="preprocessor">#ifdef REMOTE</span>
00054 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (p-&gt;rmt_clientside)
00055     {
00056         <span class="comment">/* We are on an remote capture */</span>
00057         <span class="keywordflow">return</span> <a class="code" href="pcap-remote_8c.html#a14">pcap_stats_ex_remote</a>(p);
00058     }
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a40">PacketGetStatsEx</a>(p-&gt;adapter, (<span class="keyword">struct</span> <a class="code" href="structbpf__stat.html">bpf_stat</a>*) (&amp;p-&gt;md.stat) ) != TRUE){
00061         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"PacketGetStatsEx error: %s"</span>, <a class="code" href="pcap_8c.html#a27">pcap_win32strerror</a>());
00062         <span class="keywordflow">return</span> NULL;
00063     }
00064     <span class="keywordflow">return</span> (&amp;p-&gt;md.stat);
00065 }
00066 
00067 
00068 <a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>* 
<a name="l00069"></a><a class="code" href="Win32-Extensions_8c.html#a2">00069</a> <a class="code" href="Win32-Extensions_8c.html#a2">pcap_sendqueue_alloc</a>(u_int memsize)
00070 {
00071 
00072     <a class="code" href="structpcap__send__queue.html">pcap_send_queue</a> *tqueue;
00073 
00074     <span class="comment">/* Allocate the queue */</span>
00075     tqueue = (<a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>));
00076     <span class="keywordflow">if</span>(tqueue == NULL){
00077         <span class="keywordflow">return</span> NULL;
00078     }
00079 
00080     <span class="comment">/* Allocate the buffer */</span>
00081     tqueue-&gt;<a class="code" href="structpcap__send__queue.html#m2">buffer</a> = (<span class="keywordtype">char</span>*)malloc(memsize);
00082     <span class="keywordflow">if</span>(tqueue-&gt;<a class="code" href="structpcap__send__queue.html#m2">buffer</a> == NULL){
00083         free(tqueue);
00084         <span class="keywordflow">return</span> NULL;
00085     }
00086 
00087     tqueue-&gt;<a class="code" href="structpcap__send__queue.html#m0">maxlen</a> = memsize;
00088     tqueue-&gt;<a class="code" href="structpcap__send__queue.html#m1">len</a> = 0;
00089 
00090     <span class="keywordflow">return</span> tqueue;
00091 }
00092 
00093 <span class="keywordtype">void</span> 
<a name="l00094"></a><a class="code" href="Win32-Extensions_8c.html#a3">00094</a> <a class="code" href="Win32-Extensions_8c.html#a3">pcap_sendqueue_destroy</a>(<a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>* queue)
00095 {
00096     free(queue-&gt;<a class="code" href="structpcap__send__queue.html#m2">buffer</a>);
00097     free(queue);
00098 }
00099 
00100 <span class="keywordtype">int</span> 
<a name="l00101"></a><a class="code" href="Win32-Extensions_8c.html#a4">00101</a> <a class="code" href="Win32-Extensions_8c.html#a4">pcap_sendqueue_queue</a>(<a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>* queue, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, <span class="keyword">const</span> u_char *pkt_data)
00102 {
00103 
00104     <span class="keywordflow">if</span>(queue-&gt;<a class="code" href="structpcap__send__queue.html#m1">len</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>) + pkt_header-&gt;caplen &gt; queue-&gt;maxlen){
00105         <span class="keywordflow">return</span> -1;
00106     }
00107 
00108     <span class="comment">/* Copy the pcap_pkthdr header*/</span>
00109     memcpy(queue-&gt;buffer + queue-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>, pkt_header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>));
00110     queue-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a> += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>);
00111 
00112     <span class="comment">/* copy the packet */</span>
00113     memcpy(queue-&gt;buffer + queue-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>, pkt_data, pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>);
00114     queue-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a> += pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>;
00115 
00116     <span class="keywordflow">return</span> 0;
00117 }
00118 
00119 u_int 
<a name="l00120"></a><a class="code" href="Win32-Extensions_8c.html#a5">00120</a> <a class="code" href="Win32-Extensions_8c.html#a5">pcap_sendqueue_transmit</a>(pcap_t *p, <a class="code" href="structpcap__send__queue.html">pcap_send_queue</a>* queue, <span class="keywordtype">int</span> sync){
00121 
00122     u_int res;
00123     DWORD error;
00124     <span class="keywordtype">int</span> errlen;
00125 
00126     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00127     {
00128         sprintf(p-&gt;errbuf, <span class="stringliteral">"Cannot transmit a queue to an offline capture"</span>);
00129         <span class="keywordflow">return</span> -1;
00130     }   
00131 
00132     res = <a class="code" href="Packet32_8c.html#a28">PacketSendPackets</a>(p-&gt;adapter,
00133         queue-&gt;<a class="code" href="structpcap__send__queue.html#m2">buffer</a>,
00134         queue-&gt;<a class="code" href="structpcap__send__queue.html#m1">len</a>,
00135         (BOOLEAN)sync);
00136 
00137     <span class="keywordflow">if</span>(res != queue-&gt;<a class="code" href="structpcap__send__queue.html#m1">len</a>){
00138         error = GetLastError();
00139         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,error,0,p-&gt;errbuf,PCAP_ERRBUF_SIZE,NULL);
00140         <span class="comment">/*</span>
00141 <span class="comment">        * "FormatMessage()" "helpfully" sticks CR/LF at the end of</span>
00142 <span class="comment">        * the message.  Get rid of it.</span>
00143 <span class="comment">        */</span>
00144         errlen = strlen(p-&gt;errbuf);
00145         <span class="keywordflow">if</span> (errlen &gt;= 2) {
00146             p-&gt;errbuf[errlen - 1] = <span class="charliteral">'\0'</span>;
00147             p-&gt;errbuf[errlen - 2] = <span class="charliteral">'\0'</span>;
00148         }
00149         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error opening adapter: %s"</span>, p-&gt;errbuf);
00150     }
00151 
00152     <span class="keywordflow">return</span> res;
00153 }
00154 
00155 
00156 <span class="preprocessor">#ifdef WE_HAVE_TO_DELETE_IT_ASAP</span>
00157 <span class="preprocessor"></span><span class="keywordtype">int</span> 
00158 <a class="code" href="pcap_8c.html#a10">pcap_next_ex</a>(pcap_t *p, <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, u_char **pkt_data)
00159 {
00160     <span class="comment">/* Check the capture type */</span>
00161 
00162 <span class="preprocessor">#ifdef REMOTE</span>
00163 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (p-&gt;rmt_clientside)
00164     {
00165         <span class="comment">/* We are on an remote capture */</span>
00166         <span class="keywordflow">if</span> (!p-&gt;rmt_capstarted)
00167         {
00168             <span class="comment">// if the capture has not started yet, please start it</span>
00169             <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a16">pcap_startcapture_remote</a>(p) )
00170                 <span class="keywordflow">return</span> -1;
00171             p-&gt;rmt_capstarted= 1;
00172         }
00173         <span class="keywordflow">return</span> pcap_next_ex_remote(p, pkt_header, pkt_data);
00174     }
00175 <span class="preprocessor">#endif</span>
00176 <span class="preprocessor"></span>
00177     <span class="keywordflow">if</span> (p-&gt;adapter!=NULL)
00178     {
00179         <span class="comment">/* We are on a live capture */</span>
00180         <span class="keywordtype">int</span> cc;
00181         <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00182         <span class="keyword">register</span> u_char *bp, *ep;
00183         
00184         cc = p-&gt;cc;
00185         <span class="keywordflow">if</span> (p-&gt;cc == 0) 
00186         {
00187             <span class="comment">/* capture the packets */</span>
00188             <span class="keywordflow">if</span>(<a class="code" href="Packet32_8c.html#a26">PacketReceivePacket</a>(p-&gt;adapter, p-&gt;Packet, TRUE) == FALSE)
00189             {
00190                 sprintf(p-&gt;errbuf, <span class="stringliteral">"read error: PacketReceivePacket failed"</span>);
00191                 <span class="keywordflow">return</span> (-1);
00192             }
00193             
00194             cc = p-&gt;Packet-&gt;ulBytesReceived;
00195             
00196             bp = p-&gt;Packet-&gt;Buffer;
00197         } 
00198         <span class="keywordflow">else</span>
00199             bp = p-&gt;bp;
00200         
00201         <span class="comment">/*</span>
00202 <span class="comment">         * Loop through each packet.</span>
00203 <span class="comment">         */</span>
00204         ep = bp + cc;
00205         <span class="keywordflow">if</span> (bp &lt; ep) 
00206         {
00207             <span class="keyword">register</span> <span class="keywordtype">int</span> caplen, hdrlen;
00208             caplen = ((<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a> *)bp)-&gt;bh_caplen;
00209             hdrlen = ((<span class="keyword">struct </span><a class="code" href="structbpf__hdr.html">bpf_hdr</a> *)bp)-&gt;bh_hdrlen;
00210             
00211             <span class="comment">/*</span>
00212 <span class="comment">             * XXX A bpf_hdr matches a pcap_pkthdr.</span>
00213 <span class="comment">             */</span>
00214             *pkt_header = (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>*)bp;
00215             *pkt_data = bp + hdrlen;
00216             bp += BPF_WORDALIGN(caplen + hdrlen);
00217             
00218             p-&gt;bp = bp;
00219             p-&gt;cc = ep - bp;
00220             <span class="keywordflow">return</span> (1);
00221         }
00222         <span class="keywordflow">else</span>{
00223             p-&gt;cc = 0;
00224             <span class="keywordflow">return</span> (0);
00225         }
00226     }   
00227     <span class="keywordflow">else</span>
00228     {
00229         <span class="comment">/* We are on an offline capture */</span>
00230         <span class="keyword">struct </span><a class="code" href="structbpf__insn.html">bpf_insn</a> *fcode = p-&gt;fcode.bf_insns;
00231         <span class="keywordtype">int</span> status;
00232         <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00233         
00234         <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h=(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>*)(p-&gt;buffer+p-&gt;bufsize-sizeof(struct pcap_pkthdr));
00235         
00236         <span class="keywordflow">while</span> (1)
00237         {
00238             status = <a class="code" href="savefile_8c.html#a58">sf_next_packet</a>(p, h, p-&gt;buffer, p-&gt;bufsize);
00239             <span class="keywordflow">if</span> (status==1)
00240                 <span class="comment">/* EOF */</span>
00241                 <span class="keywordflow">return</span> (-2);
00242             <span class="keywordflow">if</span> (status==-1)
00243                 <span class="comment">/* Error */</span>
00244                 <span class="keywordflow">return</span> (-1);
00245             
00246             <span class="keywordflow">if</span> (fcode == NULL ||
00247                 <a class="code" href="group__NPF__code.html#a26">bpf_filter</a>(fcode, p-&gt;buffer, h-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>, h-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>)) 
00248             {
00249                 *pkt_header = h;
00250                 *pkt_data = p-&gt;buffer;
00251                 <span class="keywordflow">return</span> (1);
00252             }           
00253             
00254         }
00255     }
00256 }
00257 <span class="preprocessor">#endif</span>
00258 <span class="preprocessor"></span>
00259 
00260 <span class="keywordtype">int</span>
<a name="l00261"></a><a class="code" href="Win32-Extensions_8c.html#a6">00261</a> <a class="code" href="Win32-Extensions_8c.html#a6">pcap_setuserbuffer</a>(pcap_t *p, <span class="keywordtype">int</span> size)
00262 
00263 {
00264     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *new_buff;
00265 
00266     <span class="keywordflow">if</span> (!p-&gt;adapter) {
00267         sprintf(p-&gt;errbuf,<span class="stringliteral">"Impossible to set user buffer while reading from a file"</span>);
00268         <span class="keywordflow">return</span> -1;
00269     }
00270 
00271     <span class="keywordflow">if</span> (<a class="code" href="gencode_8c.html#a27">size</a>&lt;=0) {
00272         <span class="comment">/* Bogus parameter */</span>
00273         sprintf(p-&gt;errbuf,<span class="stringliteral">"Error: invalid size %d"</span>,size);
00274         <span class="keywordflow">return</span> -1;
00275     }
00276 
00277     <span class="comment">/* Allocate the buffer */</span>
00278     new_buff=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)*size);
00279 
00280     <span class="keywordflow">if</span> (!new_buff) {
00281         sprintf(p-&gt;errbuf,<span class="stringliteral">"Error: not enough memory"</span>);
00282         <span class="keywordflow">return</span> -1;
00283     }
00284 
00285     free(p-&gt;buffer);
00286     
00287     p-&gt;buffer=new_buff;
00288     p-&gt;bufsize=<a class="code" href="gencode_8c.html#a27">size</a>;
00289 
00290     <span class="comment">/* Associate the buffer with the capture packet */</span>
00291     <a class="code" href="Packet32_8c.html#a25">PacketInitPacket</a>(p-&gt;Packet,(BYTE*)p-&gt;buffer,p-&gt;bufsize);
00292 
00293     <span class="keywordflow">return</span> 0;
00294 
00295 }
00296 
00297 <span class="keywordtype">int</span>
<a name="l00298"></a><a class="code" href="Win32-Extensions_8c.html#a7">00298</a> <a class="code" href="Win32-Extensions_8c.html#a7">pcap_live_dump</a>(pcap_t *p, <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> maxsize, <span class="keywordtype">int</span> maxpacks){
00299 
00300     BOOLEAN res;
00301 
00302     <span class="keywordflow">if</span> (p-&gt;adapter==NULL)
00303     {
00304         sprintf(p-&gt;errbuf, <span class="stringliteral">"live dump needs a physical interface"</span>);
00305         <span class="keywordflow">return</span> -1;
00306     }   
00307 
00308     <span class="comment">/* Set the packet driver in dump mode */</span>
00309     res = <a class="code" href="Packet32_8c.html#a30">PacketSetMode</a>(p-&gt;adapter, PACKET_MODE_DUMP);
00310     <span class="keywordflow">if</span>(res == FALSE){
00311         sprintf(p-&gt;errbuf, <span class="stringliteral">"Error setting dump mode"</span>);
00312         <span class="keywordflow">return</span> -1;
00313     }
00314 
00315     <span class="comment">/* Set the name of the dump file */</span>
00316     res = <a class="code" href="Packet32_8c.html#a31">PacketSetDumpName</a>(p-&gt;adapter, filename, strlen(filename));
00317     <span class="keywordflow">if</span>(res == FALSE){
00318         sprintf(p-&gt;errbuf, <span class="stringliteral">"Error setting kernel dump file name"</span>);
00319         <span class="keywordflow">return</span> -1;
00320     }
00321 
00322     <span class="comment">/* Set the limits of the dump file */</span>
00323     res = <a class="code" href="Packet32_8c.html#a32">PacketSetDumpLimits</a>(p-&gt;adapter, maxsize, maxpacks);
00324 
00325     <span class="keywordflow">return</span> 0;
00326 }
00327 
00328 <span class="keywordtype">int</span> 
<a name="l00329"></a><a class="code" href="Win32-Extensions_8c.html#a8">00329</a> <a class="code" href="Win32-Extensions_8c.html#a8">pcap_live_dump_ended</a>(pcap_t *p, <span class="keywordtype">int</span> sync){
00330 
00331     <span class="keywordflow">if</span> (p-&gt;adapter == NULL)
00332     {
00333         sprintf(p-&gt;errbuf, <span class="stringliteral">"wrong interface type. A physical interface is needed"</span>);
00334         <span class="keywordflow">return</span> -1;
00335     }   
00336 
00337     <span class="keywordflow">return</span> <a class="code" href="Packet32_8c.html#a33">PacketIsDumpEnded</a>(p-&gt;adapter, (BOOLEAN)sync);
00338 
00339 }
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
