<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>daemon.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>daemon.c</h1><a href="daemon_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2002 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 <span class="preprocessor">#include &lt;<a class="code" href="funcs_2pcap_8h.html">pcap.h</a>&gt;</span>       <span class="comment">// for libpcap/WinPcap calls</span>
00034 <span class="preprocessor">#include &lt;pcap-int.h&gt;</span>   <span class="comment">// for the pcap_t definition</span>
00035 <span class="preprocessor">#include &lt;errno.h&gt;</span>      <span class="comment">// for the errno variable</span>
00036 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>     <span class="comment">// for malloc(), free(), ...</span>
00037 <span class="preprocessor">#include &lt;string.h&gt;</span>     <span class="comment">// for strlen(), ...</span>
00038 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00039 <span class="preprocessor">#include "<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>"</span>
00040 <span class="preprocessor">#include "<a class="code" href="daemon_8h.html">daemon.h</a>"</span>
00041 <span class="preprocessor">#include "<a class="code" href="sockutils_8h.html">sockutils.h</a>"</span>  <span class="comment">// for socket calls</span>
00042 
00043 <span class="preprocessor">#ifndef WIN32           // for select() and such</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00045 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00046 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00047 <span class="preprocessor">#include &lt;pwd.h&gt;</span>        <span class="comment">// for password management</span>
00048 <span class="preprocessor">#include &lt;shadow.h&gt;</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
00051 
00052 
00053 
00054 <span class="comment">// Locally defined functions</span>
00055 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a1">daemon_checkauth</a>(SOCKET sockctrl, <span class="keywordtype">int</span> nullAuthAllowed, <span class="keywordtype">char</span> *errbuf);
00056 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a2">daemon_AuthUserPwd</a>(<span class="keywordtype">char</span> *username, <span class="keywordtype">char</span> *password, <span class="keywordtype">char</span> *errbuf);
00057 
00058 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a3">daemon_findalldevs</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *errbuf);
00059 
00060 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a4">daemon_opensource</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> srclen, uint32 plen, <span class="keywordtype">char</span> *errbuf);
00061 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *<a class="code" href="daemon_8c.html#a5">daemon_startcapture</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> active, uint32 plen, <span class="keywordtype">char</span> *errbuf);
00062 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a6">daemon_endcapture</a>(pcap_t *fp, <span class="keywordtype">char</span> *errbuf);
00063 
00064 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a7">daemon_updatefilter</a>(pcap_t *fp, uint32 plen);
00065 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a8">daemon_unpackapplyfilter</a>(pcap_t *fp, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *nread, <span class="keywordtype">int</span> *plen, <span class="keywordtype">char</span> *errbuf);
00066 
00067 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a9">daemon_getstats</a>(pcap_t *fp);
00068 <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a10">daemon_getstatsnopcap</a>(SOCKET sockctrl, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifdrops, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifrecv, 
00069                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> krnldrop, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> svrcapt, <span class="keywordtype">char</span> *errbuf);
00070 
00071 <span class="keywordtype">void</span> <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>(<span class="keyword">struct</span> sockaddr_storage *sockaddrin, <span class="keyword">struct</span> sockaddr_storage *sockaddrout);
00072 <span class="keywordtype">void</span> <a class="code" href="daemon_8c.html#a12">daemon_thrdatamain</a>(<span class="keywordtype">void</span> *ptr);
00073 
00074 
00075 
00076 <span class="comment">/*</span>
00077 <span class="comment">    \brief Global variable; needed to keep the message due to an error that we want to discard.</span>
00078 <span class="comment">    </span>
00079 <span class="comment">    This can happen, for instance, because we already have an error message and we want to keep </span>
00080 <span class="comment">    the first one.</span>
00081 <span class="comment">*/</span>
<a name="l00082"></a><a class="code" href="daemon_8c.html#a0">00082</a> <span class="keywordtype">char</span> <a class="code" href="sockutils_8c.html#a6">fakeerrbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];
00083 
00084 
00085 
00086 <span class="comment">// Function bodies</span>
00087 
00088 
00089 
00090 
00091 
<a name="l00104"></a><a class="code" href="daemon_8c.html#a13">00104</a> <span class="keywordtype">void</span> <a class="code" href="daemon_8c.html#a13">daemon_serviceloop</a>( <span class="keywordtype">void</span> *ptr )
00105 {
00106 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];      <span class="comment">// keeps the error string, prior to be printed</span>
00107 <span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];             <span class="comment">// keeps the string that contains the interface to open</span>
00108 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;             <span class="comment">// RPCAP message general header</span>
00109 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp= NULL;                       <span class="comment">// pcap_t main variable</span>
00110 <span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *pars;             <span class="comment">// parameters related to the present daemon loop</span>
00111 
00112 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifdrops, ifrecv, krnldrop, svrcapt;    <span class="comment">// needed to save the values of the statistics</span>
00113 
00114 <span class="comment">// Structures needed for the select() call</span>
00115 fd_set rfds;                        <span class="comment">// set of socket descriptors we have to check</span>
00116 <span class="keyword">struct </span>timeval tv;                  <span class="comment">// maximum time the select() can block waiting for data</span>
00117 <span class="keywordtype">int</span> retval;                         <span class="comment">// select() return value</span>
00118 
00119     pars= (<span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *) ptr;
00120 
00121     
00122     *<a class="code" href="inet_8c.html#a5">errbuf</a>= 0; <span class="comment">// Initialize errbuf</span>
00123 
00124     <span class="comment">// If we're in active mode, this is not a separate thread</span>
00125     <span class="keywordflow">if</span> (! pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>)
00126     {
00127         <span class="comment">// Modify thread params so that it can be killed at any time</span>
00128         <span class="keywordflow">if</span> (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL) )
00129             <span class="keywordflow">goto</span> end;
00130         <span class="keywordflow">if</span> (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL) )
00131             <span class="keywordflow">goto</span> end;
00132     }
00133 
00134 auth_again:
00135     <span class="comment">// If we're in active mode, we have to check for the initial timeout</span>
00136     <span class="keywordflow">if</span> (!pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>)
00137     {
00138         FD_ZERO(&amp;rfds);
00139         <span class="comment">// We do not have to block here</span>
00140         tv.tv_sec = <a class="code" href="group__remote__pri__struct.html#a8">RPCAP_TIMEOUT_INIT</a>;
00141         tv.tv_usec = 0;
00142         
00143         FD_SET(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, &amp;rfds);
00144 
00145         retval = select(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a> + 1, &amp;rfds, NULL, NULL, &amp;tv);
00146         <span class="keywordflow">if</span> (retval == -1)
00147         {
00148             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"select(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
00149             <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, errbuf, PCAP_ERR_NETW, fakeerrbuf);
00150             <span class="keywordflow">goto</span> end;
00151         }
00152 
00153         <span class="comment">// The timeout has expired</span>
00154         <span class="comment">// So, this was a fake connection. Drop it down</span>
00155         <span class="keywordflow">if</span> (retval == 0)
00156         {
00157             <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, <span class="stringliteral">"The RPCAP initial timeout has expired"</span>, PCAP_ERR_INITTIMEOUT, fakeerrbuf);
00158             <span class="keywordflow">goto</span> end;
00159         }
00160     }
00161 
00162 
00163     retval= <a class="code" href="daemon_8c.html#a1">daemon_checkauth</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, pars-&gt;<a class="code" href="structdaemon__slpars.html#m2">nullAuthAllowed</a>, errbuf);
00164 
00165     <span class="keywordflow">if</span> (retval)
00166     {
00167         <span class="comment">// the other user requested to close the connection</span>
00168         <span class="comment">// It can be also the case of 'active mode', in which this host is not</span>
00169         <span class="comment">// allowed to connect to the other peer; in that case, it drops down the connection</span>
00170         <span class="keywordflow">if</span> (retval == -3) 
00171             <span class="keywordflow">goto</span> end;
00172 
00173         <span class="comment">// It can be an authentication failure or an unrecoverable error</span>
00174         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, errbuf, PCAP_ERR_AUTH, fakeerrbuf);
00175 
00176         <span class="comment">// authentication error</span>
00177         <span class="keywordflow">if</span> (retval == -2)
00178         {
00179             <span class="comment">// suspend for 1 sec</span>
00180             <span class="comment">// WARNING: this day is inserted only in this point; if the user drops down the connection</span>
00181             <span class="comment">// and it connects again, this suspension time does not have any effects.</span>
00182             <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(RPCAP_SUSPEND_WRONGAUTH*1000);
00183             <span class="keywordflow">goto</span> auth_again;
00184         }
00185 
00186          <span class="comment">// Unrecoverable error</span>
00187         <span class="keywordflow">if</span> (retval == -1)
00188             <span class="keywordflow">goto</span> end;
00189     }
00190 
00191     <span class="keywordflow">while</span> (1)
00192     {
00193     <span class="keywordtype">int</span> retval;
00194 
00195         <a class="code" href="inet_8c.html#a5">errbuf</a>[0]= 0;   <span class="comment">// clear errbuf</span>
00196 
00197         <span class="comment">// Avoid zombies connections; check if the connection is opens but no commands are performed</span>
00198         <span class="comment">// from more than RPCAP_TIMEOUT_RUNTIME</span>
00199         <span class="comment">// Conditions:</span>
00200         <span class="comment">// - I have to be in normal mode (no active mode)</span>
00201         <span class="comment">// - if the device is open, I don't have to be in the middle of a capture (fp-&gt;rmt_sockdata)</span>
00202         <span class="comment">// - if the device is closed, I have always to check if a new command arrives</span>
00203         <span class="comment">//</span>
00204         <span class="comment">// Be carefully: the capture can have been started, but an error occurred (so fp != NULL, but</span>
00205         <span class="comment">//  rmt_sockdata is 0</span>
00206         <span class="keywordflow">if</span> ( (!pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>) &amp;&amp;  ( (fp == NULL) || ( (fp != NULL) &amp;&amp; (fp-&gt;rmt_sockdata == 0) ) ))
00207         {
00208             <span class="comment">// Check for the initial timeout</span>
00209             FD_ZERO(&amp;rfds);
00210             <span class="comment">// We do not have to block here</span>
00211             tv.tv_sec = <a class="code" href="group__remote__pri__struct.html#a9">RPCAP_TIMEOUT_RUNTIME</a>;
00212             tv.tv_usec = 0;
00213             
00214             FD_SET(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, &amp;rfds);
00215 
00216             retval = select(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a> + 1, &amp;rfds, NULL, NULL, &amp;tv);
00217             <span class="keywordflow">if</span> (retval == -1)
00218             {
00219                 <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"select(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
00220                 <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, errbuf, PCAP_ERR_NETW, fakeerrbuf);
00221                 <span class="keywordflow">goto</span> end;
00222             }
00223 
00224             <span class="comment">// The timeout has expired</span>
00225             <span class="comment">// So, this was a fake connection. Drop it down</span>
00226             <span class="keywordflow">if</span> (retval == 0)
00227             {
00228                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"The RPCAP runtime timeout has expired"</span>, 1);
00229                 <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, <span class="stringliteral">"The RPCAP runtime timeout has expired"</span>, PCAP_ERR_RUNTIMETIMEOUT, fakeerrbuf);
00230                 <span class="keywordflow">goto</span> end;
00231             }
00232         }
00233 
00234         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf) == -1)
00235             <span class="keywordflow">goto</span> end;
00236 
00237         <span class="comment">// Checks if the message is correct</span>
00238         <span class="comment">// It if is wrong, it discard the data</span>
00239         retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, &amp;header,
00240             RPCAP_MSG_FINDALLIF_REQ,
00241             RPCAP_MSG_OPEN_REQ,
00242             RPCAP_MSG_STARTCAP_REQ,
00243             RPCAP_MSG_UPDATEFILTER_REQ,
00244             RPCAP_MSG_STATS_REQ,
00245             RPCAP_MSG_ENDCAP_REQ,
00246             RPCAP_MSG_CLOSE,
00247             RPCAP_MSG_ERROR,
00248             0);
00249 
00250         <span class="keywordflow">switch</span> (retval)
00251         {
00252             <span class="keywordflow">case</span> -3:    <span class="comment">// Unrecoverable network error</span>
00253                 <span class="keywordflow">goto</span> end;   <span class="comment">// Do nothing; just exit from findalldevs; the error code is already into the errbuf</span>
00254 
00255             <span class="keywordflow">case</span> -2:    <span class="comment">// The other endpoint send a message that is not allowed here</span>
00256             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00257                 <span class="keywordflow">break</span>;
00258 
00259             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a15">RPCAP_MSG_FINDALLIF_REQ</a>:
00260             {
00261                 <span class="comment">// Checks that the header does not contain other data; if so, discard it</span>
00262                 <span class="keywordflow">if</span> (ntohl(header.plen))
00263                     <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, ntohl(header.plen), errbuf);
00264 
00265                 <span class="keywordflow">if</span> (<a class="code" href="daemon_8c.html#a3">daemon_findalldevs</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, errbuf) )
00266                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00267 
00268                 <span class="keywordflow">break</span>;
00269             };
00270 
00271             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a16">RPCAP_MSG_OPEN_REQ</a>:
00272             {
00273                 retval= <a class="code" href="daemon_8c.html#a4">daemon_opensource</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, source, <span class="keyword">sizeof</span>(source), ntohl(header.plen), errbuf);
00274 
00275                 <span class="keywordflow">if</span> (retval == -1)
00276                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00277 
00278                 <span class="keywordflow">break</span>;
00279             };
00280 
00281             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a17">RPCAP_MSG_STARTCAP_REQ</a>:
00282             {
00283                 fp= <a class="code" href="daemon_8c.html#a5">daemon_startcapture</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, source, pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>, ntohl(header.plen), errbuf);
00284 
00285                 <span class="keywordflow">if</span> (fp == NULL)
00286                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00287 
00288                 <span class="keywordflow">break</span>;
00289             };
00290 
00291             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a18">RPCAP_MSG_UPDATEFILTER_REQ</a>:
00292             {
00293                 <span class="keywordflow">if</span> (fp)
00294                 {
00295                     <span class="keywordflow">if</span> (<a class="code" href="daemon_8c.html#a7">daemon_updatefilter</a>(fp, ntohl(header.plen)) )
00296                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(fp-&gt;errbuf, 1);
00297                 }
00298                 <span class="keywordflow">else</span>
00299                 {
00300                     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, <span class="stringliteral">"Device not opened. Cannot update filter"</span>, PCAP_ERR_UPDATEFILTER, errbuf);
00301                 }
00302 
00303                 <span class="keywordflow">break</span>;
00304             };
00305 
00306             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a22">RPCAP_MSG_STATS_REQ</a>:
00307             {
00308                 <span class="comment">// Checks that the header does not contain other data; if so, discard it</span>
00309                 <span class="keywordflow">if</span> (ntohl(header.plen))
00310                     <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, ntohl(header.plen), errbuf);
00311 
00312                 <span class="keywordflow">if</span> (fp)
00313                 {
00314                     <span class="keywordflow">if</span> (<a class="code" href="daemon_8c.html#a9">daemon_getstats</a>(fp) )
00315                         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(fp-&gt;errbuf, 1);
00316                 }
00317                 <span class="keywordflow">else</span>
00318                 {
00319                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"GetStats: this call should't be allowed here"</span>, 1);
00320                     <span class="keywordflow">if</span> (<a class="code" href="daemon_8c.html#a10">daemon_getstatsnopcap</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, ifdrops, ifrecv, krnldrop, svrcapt, errbuf) )
00321                         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00322                     <span class="comment">// we have to keep compatibility with old applications, which ask for statistics</span>
00323                     <span class="comment">// also when the capture has already stopped</span>
00324 
00325 <span class="comment">//                  rpcap_senderror(pars-&gt;sockctrl, "Device not opened. Cannot get statistics", PCAP_ERR_GETSTATS, errbuf);</span>
00326                 }
00327 
00328                 <span class="keywordflow">break</span>;
00329             };
00330 
00331             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a23">RPCAP_MSG_ENDCAP_REQ</a>:      <span class="comment">// The other endpoint close the current capture session</span>
00332             {
00333                 <span class="keywordflow">if</span> (fp)
00334                 {
00335                 <span class="keyword">struct </span><a class="code" href="structpcap__stat.html">pcap_stat</a> stats;
00336 
00337                     <span class="comment">// Save statistics (we can need them in the future)</span>
00338                     <span class="keywordflow">if</span> (<a class="code" href="Pcap-win32_8c.html#a5">pcap_stats</a>(fp, &amp;stats) )
00339                     {
00340                         ifdrops= stats.<a class="code" href="structpcap__stat.html#m2">ps_ifdrop</a>;
00341                         ifrecv= stats.<a class="code" href="structpcap__stat.html#m0">ps_recv</a>;
00342                         krnldrop= stats.<a class="code" href="structpcap__stat.html#m1">ps_drop</a>;
00343                         svrcapt= fp-&gt;md.TotCapt;
00344                     }
00345                     <span class="keywordflow">else</span>
00346                         ifdrops= ifrecv= krnldrop= svrcapt= 0;
00347 
00348                     <span class="keywordflow">if</span> ( <a class="code" href="daemon_8c.html#a6">daemon_endcapture</a>(fp, errbuf) )
00349                         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00350                     fp= NULL;
00351                 }
00352                 <span class="keywordflow">else</span>
00353                 {
00354                     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, <span class="stringliteral">"Device not opened. Cannot close the capture"</span>, PCAP_ERR_ENDCAPTURE, errbuf);
00355                 }
00356                 <span class="keywordflow">break</span>;
00357             };
00358 
00359             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a19">RPCAP_MSG_CLOSE</a>:       <span class="comment">// The other endpoint close the pcap session</span>
00360             {
00361                 <span class="comment">// signal to the main that the user closed the control connection</span>
00362                 <span class="comment">// This is used only in case of active mode</span>
00363                 pars-&gt;<a class="code" href="structdaemon__slpars.html#m3">activeclose</a>= 1;   
00364                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"The other end system asked to close the connection."</span>, 1);
00365                 <span class="keywordflow">goto</span> end;
00366                 <span class="keywordflow">break</span>;
00367             };
00368 
00369             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:       <span class="comment">// The other endpoint reported an error</span>
00370             {
00371                 <span class="comment">// Do nothing; just exit; the error code is already into the errbuf</span>
00372                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00373                 <span class="keywordflow">break</span>;
00374             };
00375 
00376             <span class="keywordflow">default</span>:
00377             {
00378                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error."</span>, 1);
00379                 <span class="keywordflow">break</span>;
00380             };
00381         }
00382     }
00383 
00384 end:
00385     <span class="comment">// The child thread is about to end</span>
00386 
00387     <span class="comment">// perform pcap_t cleanup, in case it has not been done</span>
00388     <span class="keywordflow">if</span> (fp)
00389     {
00390         <span class="keywordflow">if</span> (fp-&gt;rmt_threaddata)
00391         {
00392             pthread_cancel(fp-&gt;rmt_threaddata);
00393             fp-&gt;rmt_threaddata= 0;
00394         }
00395         <span class="keywordflow">if</span> (fp-&gt;rmt_sockdata)
00396         {
00397             <a class="code" href="sockutils_8c.html#a12">sock_close</a>(fp-&gt;rmt_sockdata, fakeerrbuf);
00398             fp-&gt;rmt_sockdata= 0;
00399         }
00400         <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
00401         fp= NULL;
00402     }
00403 
00404     <span class="comment">// Print message and exit</span>
00405     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"I'm exiting from the child loop"</span>, 1);
00406     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00407 
00408     <span class="keywordflow">if</span> (!pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>)
00409     {
00410         <span class="keywordflow">if</span> (pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>)
00411             <a class="code" href="sockutils_8c.html#a12">sock_close</a>(pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>, fakeerrbuf);
00412         
00413         free(pars);
00414 <span class="preprocessor">#ifdef WIN32</span>
00415 <span class="preprocessor"></span>        pthread_exit(0);
00416 <span class="preprocessor">#endif</span>
00417 <span class="preprocessor"></span>    }
00418 }
00419 
00420 
<a name="l00444"></a><a class="code" href="daemon_8c.html#a1">00444</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a1">daemon_checkauth</a>(SOCKET sockctrl, <span class="keywordtype">int</span> nullAuthAllowed, <span class="keywordtype">char</span> *errbuf)
00445 {
00446 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;         <span class="comment">// RPCAP message general header</span>
00447 <span class="keywordtype">int</span> retval;                         <span class="comment">// generic return value</span>
00448 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread;                 <span class="comment">// number of bytes of the payload read from the socket</span>
00449 <span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a> auth;             <span class="comment">// RPCAP authentication header</span>
00450 <span class="keywordtype">char</span> *string1, *string2;            <span class="comment">// two strings exchanged by the authentication message</span>
00451 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plen;                  <span class="comment">// length of the payload</span>
00452 <span class="keywordtype">int</span> retcode;                        <span class="comment">// the value we have to return to the caller</span>
00453 
00454     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf) == -1)
00455         <span class="keywordflow">return</span> -1;
00456 
00457     plen= ntohl(header.plen);
00458 
00459     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, sockctrl, &amp;header,
00460         RPCAP_MSG_AUTH_REQ,
00461         RPCAP_MSG_CLOSE,
00462         0);
00463 
00464     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a21">RPCAP_MSG_AUTH_REQ</a>)
00465     {
00466         <span class="keywordflow">switch</span> (retval)
00467         {
00468             <span class="keywordflow">case</span> -3:    <span class="comment">// Unrecoverable network error</span>
00469                 <span class="keywordflow">return</span> -1;  <span class="comment">// Do nothing; just exit; the error code is already into the errbuf</span>
00470 
00471             <span class="keywordflow">case</span> -2:    <span class="comment">// The other endpoint send a message that is not allowed here</span>
00472             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00473                 <span class="keywordflow">return</span> -2;
00474 
00475             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a19">RPCAP_MSG_CLOSE</a>:
00476             {
00477                 <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
00478                 <span class="keywordflow">if</span> (ntohl(header.plen) )
00479                 {
00480                     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, ntohl(header.plen), fakeerrbuf) )
00481                     {
00482                         retcode= -1;
00483                         <span class="keywordflow">goto</span> error;
00484                     }
00485                 }       
00486                 <span class="keywordflow">return</span> -3;
00487             };
00488 
00489             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:
00490                 <span class="keywordflow">return</span> -3;
00491 
00492             <span class="keywordflow">default</span>:
00493             {
00494                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error."</span>, 1);
00495                 retcode= -2;
00496                 <span class="keywordflow">goto</span> error;
00497             };
00498         }
00499     }
00500 
00501     <span class="comment">// If it comes here, it means that we have an authentication request message</span>
00502     <span class="keywordflow">if</span> ( (nread= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;auth, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__auth.html">rpcap_auth</a>), errbuf)) == -1)
00503     {
00504         retcode= -1;
00505         <span class="keywordflow">goto</span> error;
00506     }
00507 
00508     <span class="keywordflow">switch</span> (ntohs(auth.type) )
00509     {
00510         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a9">RPCAP_RMTAUTH_NULL</a>:
00511         {
00512             <span class="keywordflow">if</span> (!<a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>)
00513             {
00514                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication failed; NULL autentication not permitted."</span>);
00515                 retcode= -2;
00516                 <span class="keywordflow">goto</span> error;
00517             }
00518             <span class="keywordflow">break</span>;
00519         }
00520 
00521         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a10">RPCAP_RMTAUTH_PWD</a>:
00522         {
00523         <span class="keywordtype">int</span> len1, len2;
00524 
00525             len1= ntohs(auth.slen1);
00526             len2= ntohs(auth.slen2);
00527 
00528             string1= (<span class="keywordtype">char</span> *) malloc (len1 + 1);
00529             string2= (<span class="keywordtype">char</span> *) malloc (len2 + 1);
00530 
00531             <span class="keywordflow">if</span> ( (string1 == NULL) || (string2 == NULL) )
00532             {
00533                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00534                 retcode= -1;
00535                 <span class="keywordflow">goto</span> error;
00536             }
00537 
00538             <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, string1, len1, errbuf)) == -1)
00539             {
00540                 retcode= -1;
00541                 <span class="keywordflow">goto</span> error;
00542             }
00543             <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, string2, len2, errbuf)) == -1)
00544             {
00545                 retcode= -1;
00546                 <span class="keywordflow">goto</span> error;
00547             }
00548 
00549             string1[len1]= 0;
00550             string2[len2]= 0;
00551 
00552             <span class="keywordflow">if</span> (<a class="code" href="daemon_8c.html#a2">daemon_AuthUserPwd</a>(string1, string2, errbuf) )
00553             {
00554                 retcode= -2;
00555                 <span class="keywordflow">goto</span> error;
00556             }
00557 
00558             <span class="keywordflow">break</span>;
00559             }
00560 
00561         <span class="keywordflow">default</span>:
00562             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication type not recognized."</span>);
00563             retcode= -2;
00564             <span class="keywordflow">goto</span> error;
00565     }
00566 
00567 
00568     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
00569     <span class="keywordflow">if</span> (nread != plen)
00570     {
00571         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, plen - nread, fakeerrbuf) )
00572         {
00573             retcode= -1;
00574             <span class="keywordflow">goto</span> error;
00575         }
00576     }
00577 
00578     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>(&amp;header, RPCAP_MSG_AUTH_REPLY, 0, 0);
00579 
00580     <span class="comment">// Send the ok message back</span>
00581     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> rpcap_header), errbuf) == -1)
00582     {
00583         retcode= -1;
00584         <span class="keywordflow">goto</span> error;
00585     }
00586 
00587     <span class="keywordflow">return</span> 0;
00588 
00589 error:
00590     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
00591     <span class="keywordflow">if</span> (nread != plen)
00592         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, plen - nread, fakeerrbuf);
00593 
00594     <span class="keywordflow">return</span> retcode;
00595 }
00596 
00597 
00598 
<a name="l00599"></a><a class="code" href="daemon_8c.html#a2">00599</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a2">daemon_AuthUserPwd</a>(<span class="keywordtype">char</span> *username, <span class="keywordtype">char</span> *password, <span class="keywordtype">char</span> *errbuf)
00600 {
00601 <span class="preprocessor">#ifdef WIN32</span>
00602 <span class="preprocessor"></span>    <span class="comment">/*</span>
00603 <span class="comment">        Warning: the user which launches the process must have the SE_TCB_NAME right.</span>
00604 <span class="comment">        This corresponds to have the "Act as part of the Operating System" turined on</span>
00605 <span class="comment">        (administrative tools, local security settings, local policies, user right assignment)</span>
00606 <span class="comment">        However, it seems to me that if you run it as a service, this right should be</span>
00607 <span class="comment">        provided by default.</span>
00608 <span class="comment">    */</span>
00609     HANDLE Token;
00610     <span class="keywordflow">if</span> (LogonUser(username, <span class="stringliteral">"."</span>, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &amp;Token) == 0)
00611     {
00612     <span class="keywordtype">int</span> error;
00613 
00614         error = GetLastError();
00615         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,
00616             PCAP_ERRBUF_SIZE, NULL);
00617 
00618         <span class="keywordflow">return</span> -1;
00619     }
00620 
00621     <span class="comment">// This call should change the current thread to the selected user.</span>
00622     <span class="comment">// I didn't test it.</span>
00623     <span class="keywordflow">if</span> (ImpersonateLoggedOnUser(Token) == 0)
00624     {
00625     <span class="keywordtype">int</span> error;
00626 
00627         error = GetLastError();
00628         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,
00629             PCAP_ERRBUF_SIZE, NULL);
00630 
00631         <span class="keywordflow">return</span> -1;
00632     }
00633 
00634     <span class="keywordflow">return</span> 0;
00635 
00636 <span class="preprocessor">#else</span>
00637 <span class="preprocessor"></span><span class="comment">/*  Standard user authentication:</span>
00638 <span class="comment">        http://www.unixpapa.com/incnote/passwd.html</span>
00639 <span class="comment">    Problem: it is not able to merge the standard pwd file with the shadow one</span>
00640 <span class="comment"></span>
00641 <span class="comment">    Shadow user authentication:</span>
00642 <span class="comment">        http://www.tldp.org/HOWTO/Shadow-Password-HOWTO-8.html</span>
00643 <span class="comment">    Problem: the program must either (1) run as root, or (2) run as user, but it</span>
00644 <span class="comment">    must be owned by root and must be SUID root (chmod u+s rpcapd)</span>
00645 <span class="comment">*/</span>
00646 
00647     <span class="keyword">struct </span>passwd *user;
00648     <span class="keyword">struct </span>spwd *usersp;
00649 
00650     <span class="comment">// This call is needed to get the uid</span>
00651     <span class="keywordflow">if</span> ((user= getpwnam(username)) == NULL)
00652     {
00653         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication failed: no such user"</span>);
00654         <span class="keywordflow">return</span> -1;
00655     }
00656 
00657     <span class="comment">// This call is needed to get the password; otherwise 'x' is returned</span>
00658     <span class="keywordflow">if</span> ((usersp= getspnam(username)) == NULL)
00659     {
00660         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication failed: no such user"</span>);
00661         <span class="keywordflow">return</span> -1;
00662     }
00663     
00664     <span class="keywordflow">if</span> (strcmp(usersp-&gt;sp_pwdp, (<span class="keywordtype">char</span> *) crypt(password, usersp-&gt;sp_pwdp) ) != 0)
00665     {
00666         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication failed: password incorrect"</span>);
00667         <span class="keywordflow">return</span> -1;
00668     }
00669 
00670     <span class="keywordflow">if</span> (setuid(user-&gt;pw_uid) )
00671     {
00672         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"%s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno) );
00673         <span class="keywordflow">return</span> -1;
00674     }
00675 
00676 <span class="comment">/*  if (setgid(user-&gt;pw_gid) )</span>
00677 <span class="comment">    {</span>
00678 <span class="comment">        SOCK_ASSERT("setgid failed", 1);</span>
00679 <span class="comment">        snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s", pcap_strerror(errno) );</span>
00680 <span class="comment">        return -1;</span>
00681 <span class="comment">    }</span>
00682 <span class="comment">*/</span>
00683     <span class="keywordflow">return</span> 0;
00684 
00685 <span class="preprocessor">#endif</span>
00686 <span class="preprocessor"></span>
00687 }
00688 
00689 
00690 
00691 <span class="comment">// PORTING WARNING We assume u_int is a 32bit value</span>
<a name="l00692"></a><a class="code" href="daemon_8c.html#a3">00692</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a3">daemon_findalldevs</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *errbuf)
00693 {
00694 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];            <span class="comment">// temporary buffer in which data to be sent is buffered</span>
00695 <span class="keywordtype">int</span> sendbufidx= 0;                          <span class="comment">// index which keeps the number of bytes currently buffered</span>
00696 <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;                         <span class="comment">// pointer to the heade of the interface chain</span>
00697 <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;                               <span class="comment">// temp pointer neede to scan the interface chain</span>
00698 <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> plen= 0;                             <span class="comment">// length of the payload of this message</span>
00699 <span class="keyword">struct </span><a class="code" href="structpcap__addr.html">pcap_addr</a> *<a class="code" href="rpcapd_8c.html#a7">address</a>;                  <span class="comment">// pcap structure that keeps a network address of an interface</span>
00700 <span class="keyword">struct </span><a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a> *findalldevs_if;<span class="comment">// rpcap structure that packet all the data of an interface together</span>
00701 <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> nif= 0;                              <span class="comment">// counts the number of interface listed</span>
00702 
00703     <span class="comment">// Retrieve the device list</span>
00704     <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
00705     {
00706         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_FINDALLIF, fakeerrbuf);
00707         <span class="keywordflow">return</span> -1;
00708     }
00709 
00710     <span class="keywordflow">if</span> (alldevs == NULL)
00711     {
00712         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl,
00713             <span class="stringliteral">"No interfaces found! Make sure libpcap/WinPcap is properly installed"</span>
00714             <span class="stringliteral">" and you have the right to access to the remote device."</span>,
00715             PCAP_ERR_NOREMOTEIF, 
00716             errbuf);
00717         <span class="keywordflow">return</span> -1;
00718     }
00719 
00720     <span class="comment">// checks the number of interfaces and it computes the total length of the payload</span>
00721     <span class="keywordflow">for</span> (d= alldevs; d != NULL; d= d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>)
00722     {
00723         nif++;
00724 
00725         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>)
00726             plen+= strlen(d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
00727         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>)
00728             plen+= strlen(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
00729 
00730         plen+= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a>);
00731 
00732         <span class="keywordflow">for</span> (<a class="code" href="rpcapd_8c.html#a7">address</a>= d-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a>; <a class="code" href="rpcapd_8c.html#a7">address</a> != NULL; <a class="code" href="rpcapd_8c.html#a7">address</a>= <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;next)
00733             plen+= ( <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage) * 4);
00734     }
00735 
00736     <span class="comment">// RPCAP findalldevs command</span>
00737     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00738         <span class="keywordflow">return</span> -1;
00739 
00740     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_FINDALLIF_REPLY, nif, plen);
00741 
00742     <span class="comment">// send the interface list</span>
00743     <span class="keywordflow">for</span> (d= alldevs; d != NULL; d= d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>)
00744     {
00745     <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> lname, ldescr;
00746 
00747         findalldevs_if= (<span class="keyword">struct </span><a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a> *) &amp;sendbuf[sendbufidx];
00748 
00749         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00750             <span class="keywordflow">return</span> -1;
00751 
00752         memset(findalldevs_if, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_findalldevs_if) );
00753 
00754         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>) ldescr= (short) strlen(d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
00755         <span class="keywordflow">else</span> ldescr= 0;
00756         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>) lname= (short) strlen(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
00757         <span class="keywordflow">else</span> lname= 0;
00758 
00759         findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m1">desclen</a>= htons(ldescr);
00760         findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m0">namelen</a>= htons(lname);
00761         findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m2">flags</a>= htonl(d-&gt;<a class="code" href="structpcap__if.html#m4">flags</a>);
00762 
00763         <span class="keywordflow">for</span> (<a class="code" href="rpcapd_8c.html#a7">address</a>= d-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a>; <a class="code" href="rpcapd_8c.html#a7">address</a> != NULL; <a class="code" href="rpcapd_8c.html#a7">address</a>= <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;next)
00764             findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m3">naddr</a>++;
00765 
00766         findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m3">naddr</a>= htons(findalldevs_if-&gt;<a class="code" href="structrpcap__findalldevs__if.html#m3">naddr</a>);
00767 
00768         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, lname, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) == -1)
00769             <span class="keywordflow">return</span> -1;
00770 
00771         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>, ldescr, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) == -1)
00772             <span class="keywordflow">return</span> -1;
00773 
00774         <span class="comment">// send all addresses</span>
00775         <span class="keywordflow">for</span> (<a class="code" href="rpcapd_8c.html#a7">address</a>= d-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a>; <a class="code" href="rpcapd_8c.html#a7">address</a> != NULL; <a class="code" href="rpcapd_8c.html#a7">address</a>= <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;next)
00776         {
00777         <span class="keyword">struct </span>sockaddr_storage *sockaddr;
00778 
00779             sockaddr= (<span class="keyword">struct </span>sockaddr_storage *) &amp;sendbuf[sendbufidx];
00780             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00781                 <span class="keywordflow">return</span> -1;
00782             <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;addr, sockaddr);
00783 
00784             sockaddr= (<span class="keyword">struct </span>sockaddr_storage *) &amp;sendbuf[sendbufidx];
00785             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00786                 <span class="keywordflow">return</span> -1;
00787             <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;netmask, sockaddr);
00788 
00789             sockaddr= (<span class="keyword">struct </span>sockaddr_storage *) &amp;sendbuf[sendbufidx];
00790             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00791                 <span class="keywordflow">return</span> -1;
00792             <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;broadaddr, sockaddr);
00793 
00794             sockaddr= (<span class="keyword">struct </span>sockaddr_storage *) &amp;sendbuf[sendbufidx];
00795             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00796                 <span class="keywordflow">return</span> -1;
00797             <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) <a class="code" href="rpcapd_8c.html#a7">address</a>-&gt;dstaddr, sockaddr);
00798         }
00799     }
00800 
00801     <span class="comment">// Send a final command that says "now send it!"</span>
00802     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, sendbuf, sendbufidx, errbuf) == -1)
00803         <span class="keywordflow">return</span> -1;
00804 
00805     <span class="comment">// We do no longer need the device list. Free it</span>
00806     <a class="code" href="inet_8c.html#a11">pcap_freealldevs</a>(alldevs);
00807 
00808     <span class="comment">// everything is fine</span>
00809     <span class="keywordflow">return</span> 0;
00810 }
00811 
00812 
00813 
00814 
00815 
00816 <span class="comment">/*</span>
00817 <span class="comment">    \param plen: the length of the current message (needed in order to be able</span>
00818 <span class="comment">    to discard excess data in the message, if present)</span>
00819 <span class="comment">*/</span>
<a name="l00820"></a><a class="code" href="daemon_8c.html#a4">00820</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a4">daemon_opensource</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> srclen, uint32 plen, <span class="keywordtype">char</span> *errbuf)
00821 {
00822 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp= NULL;                   <span class="comment">// pcap_t main variable</span>
00823 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread;                 <span class="comment">// number of bytes of the payload read from the socket</span>
00824 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data to be sent is buffered</span>
00825 <span class="keywordtype">int</span> sendbufidx= 0;                  <span class="comment">// index which keeps the number of bytes currently buffered</span>
00826 
00827 <span class="keyword">struct </span><a class="code" href="structrpcap__openreply.html">rpcap_openreply</a> *openreply;  <span class="comment">// open reply message</span>
00828 
00829     strcpy(source, PCAP_SRC_IF_KEY);
00830 
00831     <span class="keywordflow">if</span> (srclen &lt;= (int) (strlen(PCAP_SRC_IF_KEY) + plen) )
00832     {
00833         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, <span class="stringliteral">"Source string too long"</span>, PCAP_ERR_OPEN, fakeerrbuf);
00834         <span class="keywordflow">return</span> -1;
00835     }
00836 
00837     <span class="keywordflow">if</span> ( (nread= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, &amp;source[strlen(PCAP_SRC_IF_KEY)], plen, errbuf)) == -1)
00838         <span class="keywordflow">return</span> -1;
00839 
00840     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
00841     <span class="keywordflow">if</span> (nread != plen)
00842         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, plen - nread, fakeerrbuf);
00843 
00844     <span class="comment">// Puts a '0' to terminate the source string</span>
00845     source[strlen(PCAP_SRC_IF_KEY) + plen]= 0;
00846 
00847     <span class="comment">// Open the selected device</span>
00848     <span class="comment">// This is a fake open, since we do that only to get the needed parameters, then we close the device again</span>
00849     <span class="keywordflow">if</span> ( (fp= <a class="code" href="pcap-new_8c.html#a6">pcap_open</a>(source, 
00850             1500 <span class="comment">/* faks snaplen */</span>,
00851             0 <span class="comment">/* no promis */</span>, 
00852             1000 <span class="comment">/* fake timeout */</span>,
00853             NULL <span class="comment">/* local device, so no auth */</span>,
00854             errbuf)) == NULL)
00855     {
00856         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_OPEN, fakeerrbuf);
00857         <span class="keywordflow">return</span> -1;
00858     }
00859 
00860 
00861     <span class="comment">// Now, I can send a RPCAP open reply message</span>
00862     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00863         <span class="keywordflow">goto</span> error;
00864 
00865     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_OPEN_REPLY, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__openreply.html">rpcap_openreply</a>) );
00866 
00867     openreply= (<span class="keyword">struct </span><a class="code" href="structrpcap__openreply.html">rpcap_openreply</a> *) &amp;sendbuf[sendbufidx];
00868     
00869     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__openreply.html">rpcap_openreply</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
00870         <span class="keywordflow">goto</span> error;
00871 
00872     memset(openreply, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_openreply) );
00873     openreply-&gt;<a class="code" href="structrpcap__openreply.html#m0">linktype</a>= htonl(fp-&gt;linktype);
00874     openreply-&gt;<a class="code" href="structrpcap__openreply.html#m1">tzoff</a>= htonl(fp-&gt;tzoff);
00875 
00876     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, sendbuf, sendbufidx, errbuf) == -1)
00877         <span class="keywordflow">goto</span> error;
00878 
00879     <span class="comment">// I have to close the device again, since if has been opened with wrong parameters</span>
00880     <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
00881     fp= NULL;
00882 
00883     <span class="keywordflow">return</span> 0;
00884 
00885 error:
00886     <span class="keywordflow">if</span> (fp)
00887     {
00888         <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
00889         fp= NULL;
00890     }
00891 
00892     <span class="keywordflow">return</span> -1;
00893 }
00894 
00895 
00896 
00897 
00898 
00899 <span class="comment">/*</span>
00900 <span class="comment">    \param plen: the length of the current message (needed in order to be able</span>
00901 <span class="comment">    to discard excess data in the message, if present)</span>
00902 <span class="comment">*/</span>
<a name="l00903"></a><a class="code" href="daemon_8c.html#a5">00903</a> <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *<a class="code" href="daemon_8c.html#a5">daemon_startcapture</a>(SOCKET sockctrl, <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> active, uint32 plen, <span class="keywordtype">char</span> *errbuf)
00904 {
00905 pthread_t threaddata= 0;            <span class="comment">// handle to the receiving thread</span>
00906 <span class="keywordtype">char</span> portdata[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];       <span class="comment">// temp variable needed to derive the data port</span>
00907 <span class="keywordtype">char</span> peerhost[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];       <span class="comment">// temp variable needed to derive the host name of our peer</span>
00908 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp= NULL;                   <span class="comment">// pcap_t main variable</span>
00909 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread;                 <span class="comment">// number of bytes of the payload read from the socket</span>
00910 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data to be sent is buffered</span>
00911 <span class="keywordtype">int</span> sendbufidx= 0;                  <span class="comment">// index which keeps the number of bytes currently buffered</span>
00912 
00913 <span class="comment">// socket-related variables</span>
00914 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockdata= 0;                 <span class="comment">// socket descriptor of the data connection</span>
00915 <span class="keyword">struct </span>addrinfo hints;              <span class="comment">// temp, needed to open a socket connection</span>
00916 <span class="keyword">struct </span>addrinfo *addrinfo;          <span class="comment">// temp, needed to open a socket connection</span>
00917 <span class="keyword">struct </span>sockaddr_storage saddr;      <span class="comment">// temp, needed to retrieve the network data port chosen on the local machine</span>
00918 socklen_t saddrlen;                 <span class="comment">// temp, needed to retrieve the network data port chosen on the local machine</span>
00919 
00920 <span class="comment">// RPCAP-related variables</span>
00921 <span class="keyword">struct </span><a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a> startcapreq;       <span class="comment">// start capture request message</span>
00922 <span class="keyword">struct </span><a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a> *startcapreply;  <span class="comment">// start capture reply message</span>
00923 <span class="keywordtype">int</span> serveropen_dp;                          <span class="comment">// keeps who is going to open the data connection</span>
00924 
00925     addrinfo= NULL;
00926 
00927     <span class="keywordflow">if</span> ( (nread= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;startcapreq, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a>), errbuf)) == -1)
00928         <span class="keywordflow">return</span> NULL;
00929 
00930     startcapreq.flags= ntohs(startcapreq.flags);
00931 
00932     <span class="comment">// Open the selected device</span>
00933     <span class="keywordflow">if</span> ( (fp= <a class="code" href="pcap-new_8c.html#a6">pcap_open</a>(source, 
00934             ntohl(startcapreq.snaplen),
00935             (startcapreq.flags &amp; RPCAP_STARTCAPREQ_FLAG_PROMISC) ? PCAP_OPENFLAG_PROMISCUOUS : 0 <span class="comment">/* local device, other flags not needed */</span>, 
00936             ntohl(startcapreq.read_timeout),
00937             NULL <span class="comment">/* local device, so no auth */</span>,
00938             errbuf)) == NULL)
00939     {
00940         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_OPEN, fakeerrbuf);
00941         <span class="keywordflow">return</span> NULL;
00942     }
00943 
00944     <span class="comment">/*</span>
00945 <span class="comment">    We're in active mode if:</span>
00946 <span class="comment">    - we're using TCP, and the user wants us to be in active mode</span>
00947 <span class="comment">    - we're using UDP</span>
00948 <span class="comment">    */</span>
00949     serveropen_dp= (startcapreq.flags &amp; <a class="code" href="group__remote__pri__struct.html#a33">RPCAP_STARTCAPREQ_FLAG_SERVEROPEN</a>) || (startcapreq.flags &amp; <a class="code" href="group__remote__pri__struct.html#a32">RPCAP_STARTCAPREQ_FLAG_DGRAM</a>) || active;
00950 
00951     <span class="comment">// get the sockaddr structure referred to the other peer in the ctrl connection</span>
00952     <span class="comment">/*</span>
00953 <span class="comment">    We need that because:</span>
00954 <span class="comment">    - if we're in passive mode, we need to know the address family we want to use </span>
00955 <span class="comment">    (the same used for the ctrl socket</span>
00956 <span class="comment">    - if we're in active mode, we need to know the network address of the other host </span>
00957 <span class="comment">    we want to connect to</span>
00958 <span class="comment">    */</span>
00959     saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
00960     <span class="keywordflow">if</span> (getpeername(sockctrl, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen) == -1)
00961     {
00962         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getpeername(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
00963         <span class="keywordflow">goto</span> error;
00964     }
00965 
00966     memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo) );
00967     hints.ai_socktype = (startcapreq.flags &amp; <a class="code" href="group__remote__pri__struct.html#a32">RPCAP_STARTCAPREQ_FLAG_DGRAM</a>) ? SOCK_DGRAM : SOCK_STREAM;
00968     hints.ai_family = saddr.ss_family;
00969 
00970     <span class="comment">// Now we have to create a new socket to send packets</span>
00971     <span class="keywordflow">if</span> (serveropen_dp)      <span class="comment">// Data connection is opened by the server toward the client</span>
00972     {
00973         sprintf(portdata, <span class="stringliteral">"%d"</span>, ntohs(startcapreq.portdata) );
00974 
00975         <span class="comment">// Get the name of the other peer (needed to connect to that specific network address)</span>
00976         <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;saddr, saddrlen, peerhost, 
00977                 <span class="keyword">sizeof</span>(peerhost), NULL, 0, NI_NUMERICHOST) )
00978         {
00979             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
00980             <span class="keywordflow">goto</span> error;
00981         }
00982 
00983         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(peerhost, portdata, &amp;hints, &amp;addrinfo, errbuf) == -1)
00984             <span class="keywordflow">goto</span> error;
00985 
00986         <span class="keywordflow">if</span> ( (sockdata= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_CLIENT, 0, errbuf)) == -1)
00987             <span class="keywordflow">goto</span> error;
00988     }
00989     <span class="keywordflow">else</span>        <span class="comment">// Data connection is opened by the client toward the server</span>
00990     {
00991         hints.ai_flags = AI_PASSIVE;
00992 
00993         <span class="comment">// Let's the server socket pick up a free network port for us</span>
00994         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(NULL, <span class="stringliteral">"0"</span>, &amp;hints, &amp;addrinfo, errbuf) == -1)
00995             <span class="keywordflow">goto</span> error;
00996 
00997         <span class="keywordflow">if</span> ( (sockdata= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_SERVER, 1 <span class="comment">/* max 1 connection in queue */</span>, errbuf)) == -1)
00998             <span class="keywordflow">goto</span> error;
00999 
01000         <span class="comment">// get the complete sockaddr structure used in the data connection</span>
01001         saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
01002         <span class="keywordflow">if</span> (getsockname(sockdata, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen) == -1)
01003         {
01004             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getsockname(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01005             <span class="keywordflow">goto</span> error;
01006         }
01007 
01008         <span class="comment">// Get the local port the system picked up</span>
01009         <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;saddr, saddrlen, NULL, 
01010                 0, portdata, <span class="keyword">sizeof</span>(portdata), NI_NUMERICSERV) )
01011         {
01012             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01013             <span class="keywordflow">goto</span> error;
01014         }
01015     }
01016 
01017     <span class="comment">// addrinfo is no longer used</span>
01018     freeaddrinfo(addrinfo);
01019     addrinfo= NULL;
01020 
01021     <span class="comment">// save the socket ID for the next calls</span>
01022     fp-&gt;rmt_sockctrl= sockctrl; <span class="comment">// Needed to send an error on the ctrl connection</span>
01023 
01024     <span class="comment">// Now I can set the filter</span>
01025     <span class="keywordflow">if</span> ( <a class="code" href="daemon_8c.html#a8">daemon_unpackapplyfilter</a>(fp, &amp;nread, &amp;plen, errbuf) )
01026         <span class="keywordflow">goto</span> error;
01027 
01028 
01029     <span class="comment">// Now, I can send a RPCAP start capture reply message</span>
01030     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01031         <span class="keywordflow">goto</span> error;
01032 
01033     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_STARTCAP_REPLY, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a>) );
01034 
01035     startcapreply= (<span class="keyword">struct </span><a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a> *) &amp;sendbuf[sendbufidx];
01036     
01037     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01038         <span class="keywordflow">goto</span> error;
01039 
01040     memset(startcapreply, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_startcapreply) );
01041     startcapreply-&gt;<a class="code" href="structrpcap__startcapreply.html#m0">bufsize</a>= htonl(fp-&gt;bufsize);
01042 
01043     <span class="keywordflow">if</span> (!serveropen_dp)
01044     {
01045         sscanf(portdata, <span class="stringliteral">"%d"</span>, &amp;(startcapreply-&gt;<a class="code" href="structrpcap__startcapreply.html#m1">portdata</a>) );
01046         startcapreply-&gt;<a class="code" href="structrpcap__startcapreply.html#m1">portdata</a>= htons(startcapreply-&gt;<a class="code" href="structrpcap__startcapreply.html#m1">portdata</a>);
01047     }
01048 
01049     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, sendbuf, sendbufidx, errbuf) == -1)
01050         <span class="keywordflow">goto</span> error;
01051 
01052     <span class="keywordflow">if</span> (!serveropen_dp)
01053     {
01054     <a class="code" href="group__remote__struct.html#a12">SOCKET</a> socktemp;    <span class="comment">// We need another socket, since we're going to accept() a connection</span>
01055 
01056         <span class="comment">// Connection creation</span>
01057         saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
01058 
01059         socktemp= accept(sockdata, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen);
01060         
01061         <span class="keywordflow">if</span> (socktemp == -1)
01062         {
01063             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"accept(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01064             <span class="keywordflow">goto</span> error;
01065         }
01066 
01067         <span class="comment">// Now that I accepted the connection, the server socket is no longer needed</span>
01068         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockdata, errbuf);
01069         sockdata= socktemp;
01070     }
01071 
01072     fp-&gt;rmt_sockdata= sockdata;
01073 
01074     <span class="comment">// Now we have to create a new thread to receive packets</span>
01075     <span class="keywordflow">if</span> ( pthread_create( &amp;threaddata, NULL, (<span class="keywordtype">void</span> *) &amp;daemon_thrdatamain, (<span class="keywordtype">void</span> *) fp) )
01076     {
01077         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error creating the data thread"</span>);
01078         <span class="keywordflow">goto</span> error;
01079     }
01080 
01081     fp-&gt;rmt_threaddata= threaddata;
01082 
01083     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
01084     <span class="keywordflow">if</span> (nread != plen)
01085         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, plen - nread, fakeerrbuf);
01086 
01087     <span class="keywordflow">return</span> fp;
01088 
01089 error:
01090     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_STARTCAPTURE, fakeerrbuf);
01091 
01092     <span class="keywordflow">if</span> (addrinfo)
01093         freeaddrinfo(addrinfo);
01094 
01095     <span class="keywordflow">if</span> (threaddata)
01096         pthread_cancel(threaddata);
01097 
01098     <span class="keywordflow">if</span> (sockdata)
01099         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockdata, fakeerrbuf);
01100 
01101     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
01102     <span class="keywordflow">if</span> (nread != plen)
01103         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, plen - nread, fakeerrbuf);
01104 
01105     <span class="keywordflow">if</span> (fp)
01106     {
01107         <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
01108         fp= NULL;
01109     }
01110 
01111     <span class="keywordflow">return</span> NULL;
01112 }
01113 
01114 
01115 
<a name="l01116"></a><a class="code" href="daemon_8c.html#a6">01116</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a6">daemon_endcapture</a>(pcap_t *fp, <span class="keywordtype">char</span> *errbuf)
01117 {
01118 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;
01119 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockctrl;
01120 
01121     <span class="keywordflow">if</span> (fp-&gt;rmt_threaddata)
01122     {
01123         pthread_cancel(fp-&gt;rmt_threaddata);
01124         fp-&gt;rmt_threaddata= 0;
01125     }
01126     <span class="keywordflow">if</span> (fp-&gt;rmt_sockdata)
01127     {
01128         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(fp-&gt;rmt_sockdata, fakeerrbuf);
01129         fp-&gt;rmt_sockdata= 0;
01130     }
01131 
01132     sockctrl= fp-&gt;rmt_sockctrl;
01133 
01134     <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
01135     fp= NULL;
01136 
01137     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( &amp;header, RPCAP_MSG_ENDCAP_REPLY, 0, 0);
01138 
01139     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf) == -1)
01140         <span class="keywordflow">return</span> -1;
01141     
01142     <span class="keywordflow">return</span> 0;
01143 }
01144 
01145 
01146 
<a name="l01147"></a><a class="code" href="daemon_8c.html#a8">01147</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a8">daemon_unpackapplyfilter</a>(pcap_t *fp, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *nread, <span class="keywordtype">int</span> *plen, <span class="keywordtype">char</span> *errbuf)
01148 {
01149 <span class="keyword">struct </span><a class="code" href="structrpcap__filter.html">rpcap_filter</a> filter;
01150 <span class="keyword">struct </span><a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a> insn;
01151 <span class="keyword">struct </span><a class="code" href="structbpf__insn.html">bpf_insn</a> *bf_insn;
01152 <span class="keyword">struct </span><a class="code" href="structbpf__program.html">bpf_program</a> bf_prog;
01153 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
01154 
01155 
01156     <span class="keywordflow">if</span> ( ( *nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;filter, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filter.html">rpcap_filter</a>), errbuf)) == -1)
01157     {
01158         <span class="comment">// to avoid blocking on the sock_discard()</span>
01159         *plen= *nread;
01160         <span class="keywordflow">return</span> -1;
01161     }
01162 
01163     bf_prog.<a class="code" href="structbpf__program.html#m0">bf_len</a>= ntohl(filter.nitems);
01164 
01165     <span class="keywordflow">if</span> (ntohs(filter.filtertype) != <a class="code" href="group__remote__pri__struct.html#a36">RPCAP_UPDATEFILTER_BPF</a>)
01166     {
01167         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Only BPF/NPF filters are currently supported"</span>);
01168         <span class="keywordflow">return</span> -1;
01169     }
01170 
01171     bf_insn= (<span class="keyword">struct </span><a class="code" href="structbpf__insn.html">bpf_insn</a> *) malloc ( sizeof(struct bpf_insn) * bf_prog.bf_len);
01172     <span class="keywordflow">if</span> (bf_insn == NULL)
01173     {
01174         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
01175         <span class="keywordflow">return</span> -1;
01176     }
01177 
01178     bf_prog.bf_insns= bf_insn;
01179 
01180     <span class="keywordflow">for</span> (i= 0; i &lt; bf_prog.bf_len; i++)
01181     {
01182         <span class="keywordflow">if</span> ( ( *nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;insn, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a>), errbuf)) == -1)
01183             <span class="keywordflow">return</span> -1;
01184 
01185         bf_insn-&gt;<a class="code" href="structbpf__insn.html#m0">code</a>= ntohs(insn.code);
01186         bf_insn-&gt;<a class="code" href="structbpf__insn.html#m2">jf</a>= insn.jf;
01187         bf_insn-&gt;<a class="code" href="structbpf__insn.html#m1">jt</a>= insn.jt;
01188         bf_insn-&gt;<a class="code" href="structbpf__insn.html#m3">k</a>= ntohl(insn.k);
01189 
01190         bf_insn++;
01191     }
01192 
01193     <span class="keywordflow">if</span> (<a class="code" href="group__NPF__code.html#a25">bpf_validate</a>(bf_prog.bf_insns, bf_prog.bf_len) == 0)
01194     {
01195         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The filter contains bogus instructions"</span>);
01196         <span class="keywordflow">return</span> -1;
01197     }
01198 
01199     <span class="keywordflow">if</span> (<a class="code" href="Pcap-win32_8c.html#a8">pcap_setfilter</a>(fp, &amp;bf_prog) )
01200     {
01201         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"RPCAP error: %s"</span>, fp-&gt;errbuf);
01202         <span class="keywordflow">return</span> -1;
01203     }
01204 
01205     <span class="keywordflow">return</span> 0;
01206 }
01207 
01208 
01209 
<a name="l01210"></a><a class="code" href="daemon_8c.html#a7">01210</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a7">daemon_updatefilter</a>(pcap_t *fp, uint32 plen)
01211 {
01212 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;         <span class="comment">// keeps the answer to the updatefilter command</span>
01213 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread;
01214 
01215     <span class="keywordflow">if</span> ( <a class="code" href="daemon_8c.html#a8">daemon_unpackapplyfilter</a>(fp, &amp;nread, &amp;plen, fp-&gt;errbuf) )
01216         <span class="keywordflow">goto</span> error;
01217 
01218     <span class="comment">// Check if all the data has been read; if not, discard the data in excess</span>
01219     <span class="keywordflow">if</span> (nread != plen)
01220     {
01221         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, plen - nread, fakeerrbuf) )
01222         {
01223             nread= plen;        <span class="comment">// just to avoid to call discard again in the 'error' section</span>
01224             <span class="keywordflow">goto</span> error;
01225         }
01226     }
01227 
01228     <span class="comment">// A response is needed, otherwise the other host does not know that everything went well</span>
01229     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( &amp;header, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);
01230 
01231     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, sizeof (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), fp-&gt;errbuf) )
01232         <span class="keywordflow">goto</span> error;
01233 
01234     <span class="keywordflow">return</span> 0;
01235 
01236 
01237 error:
01238     <span class="keywordflow">if</span> (nread != plen)
01239         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, plen - nread, fakeerrbuf);
01240 
01241     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(fp-&gt;rmt_sockctrl, fp-&gt;errbuf, PCAP_ERR_UPDATEFILTER, fakeerrbuf);
01242 
01243     <span class="keywordflow">return</span> -1;
01244 }
01245 
01246 
01247 
<a name="l01248"></a><a class="code" href="daemon_8c.html#a9">01248</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a9">daemon_getstats</a>(pcap_t *fp)
01249 {
01250 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data to be sent is buffered</span>
01251 <span class="keywordtype">int</span> sendbufidx= 0;                  <span class="comment">// index which keeps the number of bytes currently buffered</span>
01252 <span class="keyword">struct </span><a class="code" href="structpcap__stat.html">pcap_stat</a> stats;             <span class="comment">// local statistics</span>
01253 <span class="keyword">struct </span><a class="code" href="structrpcap__stats.html">rpcap_stats</a> *netstats;       <span class="comment">// statistics sent on the network</span>
01254 
01255     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) == -1)
01256         <span class="keywordflow">goto</span> error;
01257 
01258     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_STATS_REPLY, 0, (uint16) <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__stats.html">rpcap_stats</a>));
01259 
01260     netstats= (<span class="keyword">struct </span><a class="code" href="structrpcap__stats.html">rpcap_stats</a> *) &amp;sendbuf[sendbufidx];
01261 
01262     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__stats.html">rpcap_stats</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) == -1)
01263         <span class="keywordflow">goto</span> error;
01264 
01265     <span class="keywordflow">if</span> (<a class="code" href="Pcap-win32_8c.html#a5">pcap_stats</a>(fp, &amp;stats) )
01266         <span class="keywordflow">goto</span> error;
01267 
01268     netstats-&gt;<a class="code" href="structrpcap__stats.html#m1">ifdrop</a>= htonl(stats.<a class="code" href="structpcap__stat.html#m2">ps_ifdrop</a>);
01269     netstats-&gt;<a class="code" href="structrpcap__stats.html#m0">ifrecv</a>= htonl(stats.<a class="code" href="structpcap__stat.html#m0">ps_recv</a>);
01270     netstats-&gt;<a class="code" href="structrpcap__stats.html#m2">krnldrop</a>= htonl(stats.<a class="code" href="structpcap__stat.html#m1">ps_drop</a>);
01271     netstats-&gt;<a class="code" href="structrpcap__stats.html#m3">svrcapt</a>= htonl(fp-&gt;md.TotCapt);
01272 
01273     <span class="comment">// Send the packet</span>
01274     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, sendbuf, sendbufidx, fp-&gt;errbuf) == -1)
01275         <span class="keywordflow">goto</span> error;
01276 
01277     <span class="keywordflow">return</span> 0;
01278 
01279 error:
01280     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(fp-&gt;rmt_sockctrl, fp-&gt;errbuf, PCAP_ERR_GETSTATS, fakeerrbuf);
01281     <span class="keywordflow">return</span> -1;
01282 }
01283 
01284 
01285 
01286 
<a name="l01287"></a><a class="code" href="daemon_8c.html#a10">01287</a> <span class="keywordtype">int</span> <a class="code" href="daemon_8c.html#a10">daemon_getstatsnopcap</a>(SOCKET sockctrl, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifdrops, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifrecv, 
01288                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> krnldrop, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> svrcapt, <span class="keywordtype">char</span> *errbuf)
01289 {
01290 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data to be sent is buffered</span>
01291 <span class="keywordtype">int</span> sendbufidx= 0;                  <span class="comment">// index which keeps the number of bytes currently buffered</span>
01292 <span class="keyword">struct </span><a class="code" href="structrpcap__stats.html">rpcap_stats</a> *netstats;       <span class="comment">// statistics sent on the network</span>
01293 
01294     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01295         <span class="keywordflow">goto</span> error;
01296 
01297     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_STATS_REPLY, 0, (uint16) <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__stats.html">rpcap_stats</a>));
01298 
01299     netstats= (<span class="keyword">struct </span><a class="code" href="structrpcap__stats.html">rpcap_stats</a> *) &amp;sendbuf[sendbufidx];
01300 
01301     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__stats.html">rpcap_stats</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01302         <span class="keywordflow">goto</span> error;
01303 
01304     netstats-&gt;<a class="code" href="structrpcap__stats.html#m1">ifdrop</a>= htonl(ifdrops);
01305     netstats-&gt;<a class="code" href="structrpcap__stats.html#m0">ifrecv</a>= htonl(ifrecv);
01306     netstats-&gt;<a class="code" href="structrpcap__stats.html#m2">krnldrop</a>= htonl(krnldrop);
01307     netstats-&gt;<a class="code" href="structrpcap__stats.html#m3">svrcapt</a>= htonl(svrcapt);
01308 
01309     <span class="comment">// Send the packet</span>
01310     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, sendbuf, sendbufidx, errbuf) == -1)
01311         <span class="keywordflow">goto</span> error;
01312 
01313     <span class="keywordflow">return</span> 0;
01314 
01315 error:
01316     <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_GETSTATS, fakeerrbuf);
01317     <span class="keywordflow">return</span> -1;
01318 }
01319 
01320 
01321 
01322 
<a name="l01323"></a><a class="code" href="daemon_8c.html#a12">01323</a> <span class="keywordtype">void</span> <a class="code" href="daemon_8c.html#a12">daemon_thrdatamain</a>(<span class="keywordtype">void</span> *ptr)
01324 {
01325 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// error buffer</span>
01326 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;                         <span class="comment">// pointer to a 'pcap' structure</span>
01327 <span class="keywordtype">int</span> retval;                         <span class="comment">// general variable used to keep the return value of other functions</span>
01328 <span class="keyword">struct </span><a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a> *net_pkt_header;<span class="comment">// header of the packet</span>
01329 <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header;     <span class="comment">// pointer to the buffer that contains the header of the current packet</span>
01330 u_char *pkt_data;                   <span class="comment">// pointer to the buffer that contains the current packet</span>
01331 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data to be sent is buffered</span>
01332 <span class="keywordtype">int</span> sendbufidx;                     <span class="comment">// index which keeps the number of bytes currently buffered</span>
01333 
01334 
01335     fp= (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *) ptr;
01336 
01337     fp-&gt;md.TotCapt= 0;          <span class="comment">// counter which is incremented each time a packet is received</span>
01338 
01339     <span class="comment">// Initialize errbuf</span>
01340     memset(errbuf, 0, <span class="keyword">sizeof</span>(errbuf) );
01341 
01342     <span class="comment">// Modify thread params so that it can be killed at any time</span>
01343     <span class="keywordflow">if</span> (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL) )
01344         <span class="keywordflow">goto</span> error;
01345     <span class="keywordflow">if</span> (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL) )
01346         <span class="keywordflow">goto</span> error;
01347 
01348     <span class="comment">// Retrieve the packets</span>
01349     <span class="keywordflow">while</span> ((retval = <a class="code" href="pcap_8c.html#a10">pcap_next_ex</a>(fp, &amp;pkt_header, &amp;pkt_data)) &gt;= 0)
01350     {
01351         <span class="keywordflow">if</span> (retval == 0)    <span class="comment">// Read timeout elapsed</span>
01352             <span class="keywordflow">continue</span>;
01353 
01354         sendbufidx= 0;
01355 
01356         <span class="comment">// Bufferize the general header</span>
01357         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01358             <span class="keywordflow">goto</span> error;
01359 
01360         <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_PACKET, 0,
01361             (uint16) (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a>) + pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>) );
01362 
01363         net_pkt_header= (<span class="keyword">struct </span><a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a> *) &amp;sendbuf[sendbufidx];
01364 
01365         <span class="comment">// Bufferize the pkt header</span>
01366         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) == -1)
01367             <span class="keywordflow">goto</span> error;
01368 
01369         net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m2">caplen</a>= htonl(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>);
01370         net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m3">len</a>= htonl(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>);
01371         net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m4">npkt</a>= htonl( ++(fp-&gt;md.TotCapt) );
01372         net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m0">timestamp_sec</a>= htonl(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec);
01373         net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m1">timestamp_usec</a>= htonl(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec);
01374 
01375         <span class="comment">// Bufferize the pkt data</span>
01376         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>((<span class="keywordtype">char</span> *) pkt_data, pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) == -1)
01377             <span class="keywordflow">goto</span> error;
01378 
01379         <span class="comment">// Send the packet</span>
01380         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockdata, sendbuf, sendbufidx, errbuf) == -1)
01381             <span class="keywordflow">goto</span> error;
01382 
01383     }
01384 
01385     <span class="keywordflow">if</span> (retval == -1)
01386     {
01387         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error reading the packets: %s"</span>, <a class="code" href="pcap_8c.html#a24">pcap_geterr</a>(fp) );
01388         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(fp-&gt;rmt_sockctrl, errbuf, PCAP_ERR_READEX, fakeerrbuf);
01389         <span class="keywordflow">goto</span> error;
01390     }
01391 
01392 error:
01393 
01394     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01395     closesocket(fp-&gt;rmt_sockdata);
01396     fp-&gt;rmt_sockdata= 0;
01397     fp-&gt;rmt_threaddata= 0;
01398 
01399     <span class="keywordflow">return</span>;
01400 }
01401 
01402 
01403 
<a name="l01421"></a><a class="code" href="daemon_8c.html#a11">01421</a> <span class="keywordtype">void</span> <a class="code" href="daemon_8c.html#a11">daemon_seraddr</a>(<span class="keyword">struct</span> sockaddr_storage *sockaddrin, <span class="keyword">struct</span> sockaddr_storage *sockaddrout)
01422 {
01423     memset(sockaddrout, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage) );
01424 
01425     <span class="comment">// There can be the case in which the sockaddrin is not available</span>
01426     <span class="keywordflow">if</span> (sockaddrin == NULL) <span class="keywordflow">return</span>;
01427 
01428     <span class="comment">// Warning: we support only AF_INET and AF_INET6</span>
01429     <span class="keywordflow">if</span> (sockaddrin-&gt;ss_family == AF_INET)
01430     {
01431     <span class="keyword">struct </span>sockaddr_in *sockaddr;
01432 
01433         sockaddr= (<span class="keyword">struct </span>sockaddr_in *) sockaddrin;
01434         sockaddr-&gt;sin_family= htons(sockaddr-&gt;sin_family);
01435         sockaddr-&gt;sin_port= htons(sockaddr-&gt;sin_port);
01436         memcpy(sockaddrout, sockaddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in) );
01437     }
01438     <span class="keywordflow">else</span>
01439     {
01440     <span class="keyword">struct </span>sockaddr_in6 *sockaddr;
01441     
01442         sockaddr= (<span class="keyword">struct </span>sockaddr_in6 *) sockaddrin;
01443         sockaddr-&gt;sin6_family= htons(sockaddr-&gt;sin6_family);
01444         sockaddr-&gt;sin6_port= htons(sockaddr-&gt;sin6_port);
01445         sockaddr-&gt;sin6_flowinfo= htonl(sockaddr-&gt;sin6_flowinfo);
01446         sockaddr-&gt;sin6_scope_id= htonl(sockaddr-&gt;sin6_scope_id);
01447         memcpy(sockaddrout, sockaddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6) );
01448     }
01449 }
01450 
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
