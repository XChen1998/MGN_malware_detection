<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Internal Functions</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Internal Functions<br>
<small>
[<a class="el" href="group__remote.html">Remote Capture</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a0">sock_geterror</a> (const char *caller, char *string, int <a class="el" href="gencode_8c.html#a27">size</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves the error message after an error occurred in the socket interface.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a1">sock_init</a> (char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes sockets.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a2">sock_cleanup</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It deallocates sockets.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a3">sock_ismcastaddr</a> (const struct sockaddr *saddr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It checks if the sockaddr variable contains a multicast address.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a4">sock_open</a> (struct addrinfo *addrinfo, int server, int nconn, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes a network connection both from the client and the server side.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a5">sock_close</a> (SOCKET sock, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Closes the present (TCP and UDP) socket connection.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a6">sock_validaddr</a> (const char *<a class="el" href="rpcapd_8c.html#a7">address</a>, const char *<a class="el" href="rpcapd_8c.html#a8">port</a>, struct addrinfo *hints, struct addrinfo **addrinfo, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that the address, port and flags given are valids and it returns an 'addrinfo' stucture.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a7">sock_send</a> (SOCKET socket, const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends the amount of data contained into 'buffer' on the given socket.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a8">sock_bufferize</a> (const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *tempbuf, int *<a class="el" href="gencode_8c.html#a30">offset</a>, int totsize, int checkonly, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It copies the amount of data contained into 'buffer' into 'tempbuf'. and it checks for buffer overflows.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a9">sock_recv</a> (SOCKET socket, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive exactly 'size' bytes.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a10">sock_recv_dgram</a> (SOCKET sock, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive one message.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a11">sock_discard</a> (SOCKET socket, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It discards N bytes that are currently waiting to be read on the current socket.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a12">sock_check_hostlist</a> (char *<a class="el" href="rpcapd_8c.html#a0">hostlist</a>, const char *sep, struct sockaddr_storage *from, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a13">sock_cmpaddr</a> (struct sockaddr_storage *first, struct sockaddr_storage *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compares two addresses contained into two sockaddr_storage structures.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a14">rpcap_deseraddr</a> (struct sockaddr_storage *sockaddrin, struct sockaddr_storage **sockaddrout, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It traslates (i.e. de-serializes) a 'sockaddr_storage' structure from the network byte order to the host byte order.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a15">pcap_read_nocb_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, u_char **pkt_data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It reads a packet from the network socket. This does not make used of callback (hence the "nocb" string into its name).</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a16">pcap_read_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcap__fn.html#a0">pcap_handler</a> callback, u_char *user)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It reads a packet from the network socket.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a17">pcap_close_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends a CLOSE command to the capture server.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a18">pcap_stats_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a19">pcap_stats_ex_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps, int mode)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a21">pcap_opensource_remote</a> (const char *source, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It opens a remote adapter by opening an RPCAP connection and so on.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a22">pcap_startcapture_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It starts a remote capture.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a23">pcap_updatefilter_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp, struct <a class="el" href="structbpf__program.html">bpf_program</a> *prog)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Update a filter on a remote host.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a24">pcap_setfilter_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp, struct <a class="el" href="structbpf__program.html">bpf_program</a> *prog)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a filter to a remote host.</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a25">pthread_suspend</a> (int msec)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Suspends a pthread for msec milliseconds.</em> <a href="#a25"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a26">rpcap_thrdatamain_stream</a> (void *ptr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a TCP data connection.</em> <a href="#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a27">rpcap_thrdatamain_dgram</a> (void *ptr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a UDP data connection.</em> <a href="#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a28">rpcap_senderror</a> (SOCKET sock, char *error, unsigned short errcode, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends a RPCAP error to the other peer.</em> <a href="#a28"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a29">rpcap_sendauth</a> (SOCKET sock, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sends the authentication message.</em> <a href="#a29"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a30">rpcap_createhdr</a> (struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, <a class="el" href="group__remote__pri__struct.html#a0">uint8</a> type, <a class="el" href="group__remote__pri__struct.html#a1">uint16</a> value, <a class="el" href="group__remote__pri__struct.html#a2">uint32</a> length)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Creates a structure of type <a class="el" href="structrpcap__header.html">rpcap_header</a>.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a31">rpcap_checkmsg</a> (char *<a class="el" href="inet_8c.html#a5">errbuf</a>, SOCKET sock, struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, <a class="el" href="group__remote__pri__struct.html#a0">uint8</a> first,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks if the header of the received message is correct.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a32">rpcap_checkver</a> (SOCKET sock, struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks if the version contained into the message is compatible with the one handled by this implementation.</em> <a href="#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a33">rpcap_remoteact_getsock</a> (const char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It returns the socket currently used for this active connection (active mode only).</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a17" doxytag="pcap-remote.h::pcap_close_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_close_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends a CLOSE command to the capture server.
<p>
This function is called when the user wants to close a pcap_t adapter. In case we're capturing from the network, it sends a command to the other peer that says 'ok, let's stop capturing'. This function is called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a30">pcap_close()</a>.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a30">pcap_close()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Since we're closing the connection, we do not check for errors. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00300">300</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="pcap-remote.h::pcap_opensource_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#a2">pcap_t</a>* pcap_opensource_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It opens a remote adapter by opening an RPCAP connection and so on.
<p>
This function does basically the job of <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a> for a remote interface. In other words, we have a pcap_read for win32, which reads packets from NPF, another for LINUX, and so on. Now, we have a <a class="el" href="group__remote__pri__func.html#a21">pcap_opensource_remote()</a> as well. The difference, here, is the capture thread does not start until the <a class="el" href="group__remote__pri__func.html#a22">pcap_startcapture_remote()</a> is called.<p>
This is because, in remote capture, we cannot start capturing data as soon ad the 'open adapter' command is sent. Suppose the remote adapter is already overloaded; if we start a capture (which, by default, has a NULL filter) the new traffic can saturate the network.<p>
Instead, we want to "open" the adapter, then send a "start capture" command only when we're ready to start the capture. This funtion does this job: it sends a "open adapter" command (according to the RPCAP protocol), but it does not start the capture.<p>
Since the other libpcap functions do not share this way of life, we have to make some dirty things in order to make everyting working.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>source:</em>&nbsp;</td><td>see <a class="el" href="group__remote__func.html#a3">pcap_open()</a>. </td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>see <a class="el" href="group__remote__func.html#a3">pcap_open()</a>.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be either a network problem, an RPCAP problem (e.g. authentication failed), and more.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a 'pcap_t' which can be used as a parameter to the following calls (<a class="el" href="group__wpcap__fn.html#a14">pcap_compile()</a> and so on) and that specifies an opened WinPcap session. In case of problems, it returns NULL and the 'errbuf' variable keeps the error message.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>In case we call the <a class="el" href="group__wpcap__fn.html#a14">pcap_compile()</a> and the capture is not started, the filter will be saved into the pcap_t structure, and it will be sent to the other host later (when the <a class="el" href="group__remote__pri__func.html#a22">pcap_startcapture_remote()</a> is called). </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00554">554</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>, <a class="el" href="pcap-new_8c-source.html#l00636">pcap_parsesrcstr()</a>, <a class="el" href="remote-ext_8h-source.html#l00099">PCAP_SRC_IFREMOTE</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00279">RPCAP_MSG_OPEN_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00881">pcap_open()</a>, and <a class="el" href="Pcap-win32_8c-source.html#l00144">pcap_open_live()</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="pcap-remote.h::pcap_read_nocb_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_read_nocb_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pkt_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It reads a packet from the network socket. This does not make used of callback (hence the "nocb" string into its name).
<p>
This function is called by the several <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a> when they detect that we have a remote capture and they are the client side. In that case, they need to read packets from the socket.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>By choice, this function does not make use of semaphores. A smarter implementation should put a semaphore into the data thread, and a signal will be raised as soon as there is data into the socket buffer. However this is complicated and it does not bring any advantages when reading from the network, in which network delays can be much more important than these optimizations. Therefore, we chose the following approach:<ul>
<li>the 'timeout' chosen by the user is split in two (half on the server side, with the usual meaning, and half on the client side)</li><li>this function checks for packets; if there are no packets, it waits for timeout/2 and then it checks again. If packets are still missing, it returns, otherwise it reads packets. </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00203">203</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l01252">pthread_suspend()</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00148">pcap_next_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00270">pcap_read_remote()</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="pcap-remote.h::pcap_read_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_read_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__fn.html#a0">pcap_handler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>callback</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>user</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It reads a packet from the network socket.
<p>
This function is called by the several <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a> when they detect that we have a remote capture and they are the client side. In that case, they need to read packets from the socket.<p>
This function relies on the pcap_read_nocb_remote to deliver packets. The difference, here, is that as soon as a packet is read, it is delivered to the application by means of a callback function.<p>
Parameters and return values are exactly the same of the <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00270">270</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="bpf__image_8c-source.html#l00043">n</a>, and <a class="el" href="pcap-remote_8c-source.html#l00203">pcap_read_nocb_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00079">pcap_read()</a>.    </td>
  </tr>
</table>
<a name="a24" doxytag="pcap-remote.h::pcap_setfilter_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setfilter_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structbpf__program.html">bpf_program</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prog</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a filter to a remote host.
<p>
This function is called when the user wants to set a filter. In case we're capturing from the network, it sends the filter to the other peer. This function is called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01228">1228</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00292">pcap_setfilter()</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="pcap-remote.h::pcap_startcapture_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_startcapture_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It starts a remote capture.
<p>
This function is requires since the RPCAP protocol decouples the 'open' from the 'start capture' functions. This function takes all the parameters needed (which have been stored into the pcap_t structure) and sends them to the server. If everything is fine, it creates a new child thread that reads data from the network and puts data it into the user buffer. The <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a> will read data from the user buffer, as usual.<p>
The remote capture acts like a new "kernel", which puts packets directly into the buffer pointed by pcap_t. In fact, this function does not rely on a kernel that reads packets and put them into the user buffer; it has to do that on its own.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fp:</em>&nbsp;</td><td>the pcap_t descriptor of the device currently open.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' otherwise. The error message (if one) is returned into the 'errbuf' field of the pcap_t structure. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00761">761</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00196">rpcap_startcapreq::flags</a>, <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>, <a class="el" href="remote-ext_8h-source.html#l00136">PCAP_OPENFLAG_PROMISCUOUS</a>, <a class="el" href="remote-ext_8h-source.html#l00140">PCAP_OPENFLAG_UDP_DP</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="pcap-remote_8h-source.html#l00197">rpcap_startcapreq::portdata</a>, <a class="el" href="pcap-remote_8h-source.html#l00195">rpcap_startcapreq::read_timeout</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00280">RPCAP_MSG_STARTCAP_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="pcap-remote_8h-source.html#l00287">RPCAP_STARTCAPREQ_FLAG_DGRAM</a>, <a class="el" href="pcap-remote_8h-source.html#l00286">RPCAP_STARTCAPREQ_FLAG_PROMISC</a>, <a class="el" href="pcap-remote_8h-source.html#l00288">RPCAP_STARTCAPREQ_FLAG_SERVEROPEN</a>, <a class="el" href="pcap-remote_8h-source.html#l00194">rpcap_startcapreq::snaplen</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00148">pcap_next_ex()</a>, and <a class="el" href="Pcap-win32_8c-source.html#l00079">pcap_read()</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="pcap-remote.h::pcap_stats_ex_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpcap__stat.html">pcap_stat</a>* pcap_stats_ex_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves network statistics from the other peer.
<p>
This function is just a void cointainer, since the work is done by the <a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote()</a>. See that funcion for more details.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a44">pcap_stats_ex()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00396">396</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00396">pcap_stats_ex_remote()</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.
<p>
Referenced by <a class="el" href="Win32-Extensions_8c-source.html#l00051">pcap_stats_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00396">pcap_stats_ex_remote()</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="pcap-remote.h::pcap_stats_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_stats_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves network statistics from the other peer.
<p>
This function is just a void cointainer, since the work is done by the <a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote()</a>. See that funcion for more details.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a24">pcap_stats()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00373">373</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00060">pcap_stats()</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="pcap-remote.h::pcap_updatefilter_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_updatefilter_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structbpf__program.html">bpf_program</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prog</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update a filter on a remote host.
<p>
This function is called when the user wants to update a filter. In case we're capturing from the network, it sends the filter to the other peer. This function is *not* called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>. There will be two cases:<ul>
<li>the capture is already on: in this case, <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a> calls <a class="el" href="group__remote__pri__func.html#a23">pcap_updatefilter_remote()</a></li><li>the capture has not started yet: in this case, <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a> stores the filter into the pcap_t structure, and then the filter is sent with the pcap_startcap().</li></ul>
<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This function *does not* clear the packet currently into the buffers. Therefore, the user has to expect to receive some packets that are related to the previous filter. If you want to discard all the packets before applying a new filter, you have to close the current capture session and start a new one. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01161">1161</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="Packet32_8h-source.html#l00104">bpf_program::bf_len</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00281">RPCAP_MSG_UPDATEFILTER_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, and <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l01228">pcap_setfilter_remote()</a>.    </td>
  </tr>
</table>
<a name="a25" doxytag="pcap-remote.h::pthread_suspend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pthread_suspend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msec</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspends a pthread for msec milliseconds.
<p>
This fucntion is provided since pthreads do not have a suspend() call. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01252">1252</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-remote_8c-source.html#l00203">pcap_read_nocb_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a31" doxytag="pcap-remote.h::rpcap_checkmsg"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_checkmsg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a0">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if the header of the received message is correct.
<p>
This function is a way to easily check if the message received, in a certain state of the RPCAP protocol Finite State Machine, is valid. This function accepts, as a parameter, the list of message types that are allowed in a certain situation, and it returns the one which occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be either problem occurred inside this function (e.g. a network problem in case it tries to send an error on the other peer and the send() call fails), an error message which has been sent to us from the other party, or a version error (the message receive has a version number that is incompabile with our).</td></tr>
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket that has to be used to receive data. This function can read data from socket in case the version contained into the message is not compatible with our. In that case, all the message is purged from the socket, so that the following recv() calls will return a new message.</td></tr>
    <tr><td valign=top><em>header:</em>&nbsp;</td><td>a pointer to and 'rpcap_header' structure that keeps the data received from the network (still in network byte order) and that has to be checked.</td></tr>
    <tr><td valign=top><em>first:</em>&nbsp;</td><td>this function has a variable number of parameters. From this point on, all the messages that are valid in this context must be passed as parameters. The message type list must be terminated with a '0' value, the null message type, which means 'no more types to check'. The RPCAP protocol does not define anything with message type equal to zero, so there is no ambiguity in using this value as a list terminator.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The message type of the message that has been detected. In case of errors (e.g. the header contains a type that is not listed among the allowed types), this function will return the following codes:<ul>
<li>(-1) if the version is incompatible.</li><li>(-2) if the code is not among the one listed into the parameters list</li><li>(-3) if a network error (connection reset, ...)</li><li>RPCAP_MSG_ERROR if the message is an error message (it follow that the RPCAP_MSG_ERROR could not be present in the allowed message-types list, beucase this function checks for errors anyway)</li></ul>
</dd></dl>
In case either the version is incompatible or nothing matches (i.e. it returns '-1' or '-2'), it discards the message body (i.e. it reads the remaining part of the message from the network and it discards it) so that the application is ready to receive a new message. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01945">1945</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="inet_8c-source.html#l00632">errbuf</a>, <a class="el" href="pcap-remote_8h-source.html#l00115">int32</a>, <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8c-source.html#l02043">rpcap_checkver()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="pcap-remote_8h-source.html#l00150">rpcap_header::type</a>, and <a class="el" href="pcap-remote_8h-source.html#l00112">uint8</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a32" doxytag="pcap-remote.c::rpcap_checkver"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_checkver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if the version contained into the message is compatible with the one handled by this implementation.
<p>
Right now, this function does not have any sophisticated task: if the versions are different, it returns -1 and it discards the message. It is expected that in the future this message will become more complex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket that has to be used to receive data. This function can read data from socket in case the version contained into the message is not compatible with our. In that case, all the message is purged from the socket, so that the following recv() calls will return a new (clean) message.</td></tr>
    <tr><td valign=top><em>header:</em>&nbsp;</td><td>a pointer to and 'rpcap_header' structure that keeps the data received from the network (still in network byte order) and that has to be checked.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). The error message is "incompatible version".</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l02043">2043</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8h-source.html#l00086">RPCAP_VERSION</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00149">rpcap_header::ver</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>.    </td>
  </tr>
</table>
<a name="a30" doxytag="pcap-remote.h::rpcap_createhdr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rpcap_createhdr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a0">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a1">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>value</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a2">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a structure of type <a class="el" href="structrpcap__header.html">rpcap_header</a>.
<p>
This function is provided just because the creation of an rpcap header is quite a common task. It accepts all the values that appears into an <a class="el" href="structrpcap__header.html">rpcap_header</a>, and it puts them in place using the proper hton() calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>header:</em>&nbsp;</td><td>a pointer to a user-allocated buffer which will contain the serialized header, ready to be sent on the network.</td></tr>
    <tr><td valign=top><em>type:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.type field and that represents the type of the current message.</td></tr>
    <tr><td valign=top><em>value:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.value field and that has a message-dependent meaning.</td></tr>
    <tr><td valign=top><em>length:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.length field and that represents the payload length of the message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. The serialized header is returned into the 'header' variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01890">1890</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8h-source.html#l00086">RPCAP_VERSION</a>, <a class="el" href="pcap-remote_8h-source.html#l00150">rpcap_header::type</a>, <a class="el" href="pcap-remote_8h-source.html#l00151">rpcap_header::value</a>, and <a class="el" href="pcap-remote_8h-source.html#l00149">rpcap_header::ver</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="pcap-remote.h::rpcap_deseraddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_deseraddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sockaddrin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sockaddrout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It traslates (i.e. de-serializes) a 'sockaddr_storage' structure from the network byte order to the host byte order.
<p>
It accepts a 'sockaddr_storage' structure as it is received from the network and it converts it into the host byte order (by means of a set of ntoh() ). The function will allocate the 'sockaddrout' variable according to the address family in use. In case the address does not belong to the AF_INET nor AF_INET6 families, 'sockaddrout' is not allocated and a NULL pointer is returned. This usually happens because that address does not exist on the other host, so the RPCAP daemon sent a 'sockaddr_storage' structure containing all 'zero' values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sockaddrin:</em>&nbsp;</td><td>a 'sockaddr_storage' pointer to the variable that has to be de-serialized.</td></tr>
    <tr><td valign=top><em>sockaddrout:</em>&nbsp;</td><td>a 'sockaddr_storage' pointer to the variable that will contain the de-serialized data. The structure returned can be either a 'sockaddr_in' or 'sockaddr_in6'. This variable will be allocated automatically inside this function.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. Basically, the error can be only the fact that the malloc() failed to allocate memory. The error message is returned in the 'errbuf' variable, while the deserialized address is returned into the 'sockaddrout' variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>This function supports only AF_INET and AF_INET6 address families.<p>
The sockaddrout (if not NULL) must be deallocated by the user. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00133">133</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>.    </td>
  </tr>
</table>
<a name="a33" doxytag="pcap-remote.h::rpcap_remoteact_getsock"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_remoteact_getsock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It returns the socket currently used for this active connection (active mode only).
<p>
This function is just for internal use; it returns the socket ID of the active connection currently opened.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>a string that keeps the host name of the host for which we want to get the socket ID for that active connection.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the socket identifier if everything is fine, '0' if this host is not in the active host list. It returns '-1' in case of error. The error message is returned into the errbuf variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Win32: be carefully not to assign the returning value of this call to a SOCKET directly. It should lead to wrong results, since Win32 sockets are unsigned int; therefore a negative value could not be handled correctly. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l02086">2086</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00132">activehosts::host</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>.    </td>
  </tr>
</table>
<a name="a29" doxytag="pcap-remote.h::rpcap_sendauth"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_sendauth </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends the authentication message.
<p>
It sends the authentication parameters on the control socket. Ths function is required in order to open the connection with the other end party.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket we are currently using.</td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>authentication parameters that have to be sent.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be network problem ot the fact that the authorization failed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. The error message could be also 'the authentication failed'. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01752">1752</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="remote-ext_8h-source.html#l00192">pcap_rmtauth::password</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00282">RPCAP_MSG_AUTH_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="remote-ext_8h-source.html#l00204">RPCAP_RMTAUTH_NULL</a>, <a class="el" href="remote-ext_8h-source.html#l00215">RPCAP_RMTAUTH_PWD</a>, <a class="el" href="pcap-remote_8h-source.html#l00250">rpcap_auth::slen1</a>, <a class="el" href="pcap-remote_8h-source.html#l00251">rpcap_auth::slen2</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="remote-ext_8h-source.html#l00176">pcap_rmtauth::type</a>, <a class="el" href="pcap-remote_8h-source.html#l00248">rpcap_auth::type</a>, <a class="el" href="pcap-remote_8h-source.html#l00113">uint16</a>, and <a class="el" href="remote-ext_8h-source.html#l00184">pcap_rmtauth::username</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a28" doxytag="pcap-remote.h::rpcap_senderror"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_senderror </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>error</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errcode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends a RPCAP error to the other peer.
<p>
This function has to be called when the main program detects an error. This funcion will send on the other peer the 'buffer' specified by the user. This function *does not* request a RPCAP CLOSE connection. A CLOSE command must be sent explicitely by the program, since we do not know it the error can be recovered in some way or it is a non-recoverable one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket we are currently using.</td></tr>
    <tr><td valign=top><em>error:</em>&nbsp;</td><td>an user-allocated (and '0' termined) buffer that contains the error description thas has to be transmitted on the other peer. The error message cannot be longer than PCAP_ERRBUF_SIZE.</td></tr>
    <tr><td valign=top><em>errcode:</em>&nbsp;</td><td>a integer which tells the other party the type of error we had; currently is is not too much used.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01707">1707</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00113">uint16</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a20" doxytag="pcap-remote.c::rpcap_stats_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpcap__stat.html">pcap_stat</a> * rpcap_stats_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ps</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves network statistics from the other peer.
<p>
This function can be called in two modes:<ul>
<li>PCAP_STATS_STANDARD: if we want just standard statistics (i.e. the <a class="el" href="group__wpcap__fn.html#a24">pcap_stats()</a> )</li><li>PCAP_STATS_EX: if we want extended statistics (i.e. the <a class="el" href="group__wpcap__fn.html#a44">pcap_stats_ex()</a> )</li></ul>
<p>
This 'mode' parameter is needed because in the standard <a class="el" href="group__wpcap__fn.html#a24">pcap_stats()</a> the variable that keeps the statistics is allocated by the user. Unfortunately, this structure has been extended in order to keep new stats. However, if the user has a smaller structure and it passes it to the pcap_stats, thid function will try to fill in more data than the size of the structure, so that the application goes in memory overflow. So, we need to know it we have to copy just the standard fields, or the extended fields as well.<p>
In case we want to copy the extended fields as well, the problem of memory overflow does no longer exist because the structure <a class="el" href="structpcap__stat.html">pcap_stat</a> is no longer allocated by the program; it is allocated by the library instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>p:</em>&nbsp;</td><td>the pcap_t structure related to the current instance.</td></tr>
    <tr><td valign=top><em>ps:</em>&nbsp;</td><td>a 'pcap_stat' structure, needed for compatibility with pcap_stat(), in which the structure is allocated by the user. In case of pcap_stats_ex, this structure and the function return value point to the same variable.</td></tr>
    <tr><td valign=top><em>mode:</em>&nbsp;</td><td>one of PCAP_STATS_STANDARD or PCAP_STATS_EX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The structure that keeps the statistics, or NULL in case of error. The error string is placed in the pcap_t structure. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00434">434</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00065">PCAP_STATS_STANDARD</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="incs_2pcap_8h-source.html#l00138">pcap_stat::ps_drop</a>, <a class="el" href="incs_2pcap_8h-source.html#l00139">pcap_stat::ps_ifdrop</a>, <a class="el" href="incs_2pcap_8h-source.html#l00137">pcap_stat::ps_recv</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00283">RPCAP_MSG_STATS_REPLY</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, and <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l00396">pcap_stats_ex_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00373">pcap_stats_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<a name="a27" doxytag="pcap-remote.c::rpcap_thrdatamain_dgram"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rpcap_thrdatamain_dgram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>ptr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a UDP data connection.
<p>
This function does basically the job of the Operating System kernel in the local capture: it takes packet and it puts them into the user buffer.<p>
This function is different from the <a class="el" href="group__remote__pri__func.html#a26">rpcap_thrdatamain_stream()</a>, because UDP requires that a message coming from the network is received using a single recv() call. Vice versa, TCP sockets allows you reading only a few bytes each time, and the remaining part of the message is retained.<p>
From this point of view, UDP sockets makes this thread more epensive, because the message is first copied into a temporary buffer (allocated by the thread itself), then, if the WinPcap/libpcap user buffer has enough space, the data is copied into that buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ptr:</em>&nbsp;</td><td>it is a void pointer that will be casted into a pcap_t structure. This parameter is needed to retrieve the the socket (i.e. sockdata) we are currently using for the data connection, the control socket (in case we want to send error messages), and so on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01514">1514</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="incs_2pcap_8h-source.html#l00128">pcap_pkthdr::caplen</a>, <a class="el" href="pcap-remote_8h-source.html#l00220">rpcap_pkthdr::caplen</a>, <a class="el" href="inet_8c-source.html#l00632">errbuf</a>, <a class="el" href="pcap-remote_8h-source.html#l00221">rpcap_pkthdr::len</a>, <a class="el" href="incs_2pcap_8h-source.html#l00129">pcap_pkthdr::len</a>, <a class="el" href="pcap-remote_8h-source.html#l00222">rpcap_pkthdr::npkt</a>, <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="pcap-remote_8c-source.html#l01252">pthread_suspend()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8h-source.html#l00273">RPCAP_MSG_PACKET</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00635">sock_recv_dgram()</a>, <a class="el" href="pcap-remote_8h-source.html#l00218">rpcap_pkthdr::timestamp_sec</a>, <a class="el" href="pcap-remote_8h-source.html#l00219">rpcap_pkthdr::timestamp_usec</a>, and <a class="el" href="incs_2pcap_8h-source.html#l00127">pcap_pkthdr::ts</a>.    </td>
  </tr>
</table>
<a name="a26" doxytag="pcap-remote.c::rpcap_thrdatamain_stream"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rpcap_thrdatamain_stream </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>ptr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a TCP data connection.
<p>
This function does basically the job of the Operating System kernel in the local capture: it takes packets and it puts them into the user buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ptr:</em>&nbsp;</td><td>it is a void pointer that will be casted into a pcap_t structure. This parameter is needed to retrieve the the socket (i.e. sockdata) we are currently using for the data connection, the control socket (in case we want to send error messages), and so on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01298">1298</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="incs_2pcap_8h-source.html#l00128">pcap_pkthdr::caplen</a>, <a class="el" href="pcap-remote_8h-source.html#l00220">rpcap_pkthdr::caplen</a>, <a class="el" href="inet_8c-source.html#l00632">errbuf</a>, <a class="el" href="pcap-remote_8h-source.html#l00221">rpcap_pkthdr::len</a>, <a class="el" href="incs_2pcap_8h-source.html#l00129">pcap_pkthdr::len</a>, <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8c-source.html#l01252">pthread_suspend()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8h-source.html#l00273">RPCAP_MSG_PACKET</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="pcap-remote_8h-source.html#l00218">rpcap_pkthdr::timestamp_sec</a>, <a class="el" href="pcap-remote_8h-source.html#l00219">rpcap_pkthdr::timestamp_usec</a>, and <a class="el" href="incs_2pcap_8h-source.html#l00127">pcap_pkthdr::ts</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="sockutils.h::sock_bufferize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_bufferize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tempbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>totsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>checkonly</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It copies the amount of data contained into 'buffer' into 'tempbuf'. and it checks for buffer overflows.
<p>
This function basically copies 'size' bytes of data contained into 'buffer' into 'tempbuf', starting at offset 'offset'. Before that, it checks that the resulting buffer will not be larger than 'totsize'. Finally, it updates the 'offset' variable in order to point to the first empty location of the buffer.<p>
In case the function is called with 'checkonly' equal to 1, it does not copy the data into the buffer. It only checks for buffer overflows and it updates the 'offset' variable. This mode can be useful when the buffer already contains the data (maybe because the producer writes directly into the target buffer), so only the buffer overflow check has to be made. In this case, both 'buffer' and 'tempbuf' can be NULL values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer that keeps the data that has to be copied.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be copied.</td></tr>
    <tr><td valign=top><em>tempbuf:</em>&nbsp;</td><td>user-allocated buffer (of size 'totsize') in which data has to be copied.</td></tr>
    <tr><td valign=top><em>offset:</em>&nbsp;</td><td>an index into 'tempbuf' which keeps the location of its first empty location.</td></tr>
    <tr><td valign=top><em>totsize:</em>&nbsp;</td><td>total size of the buffer in which data is being copied.</td></tr>
    <tr><td valign=top><em>checkonly:</em>&nbsp;</td><td>'1' if we do not want to copy data into the buffer and we want just do a buffer ovreflow control, '0' if data has to be copied as well.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. When the function returns, 'tempbuf' will have the new string appended, and 'offset' will keep the length of that buffer. In case of 'checkonly == 1', data is not copied, but 'offset' is updated in any case.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>This function assumes that the buffer in which data has to be stored is large 'totbuf' bytes.<p>
In case of 'checkonly', be carefully to call this function *before* copying the data into the buffer. Otherwise, the control about the buffer overflow is useless. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00524">524</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l01713">offset</a>, <a class="el" href="gencode_8c-source.html#l04255">size</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="sockutils.h::sock_check_hostlist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_check_hostlist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sep</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>from</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.
<p>
This function is useful after an accept() call in order to check if the connecting host is allowed to connect to me. To do that, we have a buffer that keeps the list of the allowed host; this function checks the sockaddr_storage structure of the connecting host against this host list, and it returns '0' is the host is included in this list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>hostlist:</em>&nbsp;</td><td>a string that contains the list of the allowed host.</td></tr>
    <tr><td valign=top><em>sep:</em>&nbsp;</td><td>a string that keeps the separators used between the hosts (for example the space character) in the host list.</td></tr>
    <tr><td valign=top><em>from:</em>&nbsp;</td><td>a sockaddr_storage structure, as it is returned by the accept() call.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00726">726</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="fileconf_8c-source.html#l00044">hostlist</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="sockutils.h::sock_cleanup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sock_cleanup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It deallocates sockets.
<p>
This function is pretty useless on UNIX, since socket deallocation is not required. However it is required on Win32. In UNIX, this function appears to be completely empty.<p>
<dl compact><dt><b>Returns:</b></dt><dd>No error values. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00192">192</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00058">sockcount</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00409">main_cleanup()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-new_8c-source.html#l01249">pcap_remoteact_cleanup()</a>, and <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="sockutils.h::sock_close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes the present (TCP and UDP) socket connection.
<p>
This function sends a shutdown() on the socket in order to disable send() calls (while recv() ones are still allowed). Then, it closes the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket identifier of the connection that has to be closed.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00334">334</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="sockutils.h::sock_cmpaddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_cmpaddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compares two addresses contained into two sockaddr_storage structures.
<p>
This function is useful to compare two addresses, given their internal representation, i.e. an sockaddr_storage structure.<p>
The two structures do not need to be sockaddr_storage; you can have both 'sockaddr_in' and sockaddr_in6, properly acsted in order to be compliant to the function interface.<p>
This function will return '0' if the two addresses matches, '-1' if not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>first:</em>&nbsp;</td><td>a sockaddr_storage structure, (for example the one that is returned by an accept() call), containing the first address to compare.</td></tr>
    <tr><td valign=top><em>second:</em>&nbsp;</td><td>a sockaddr_storage structure containing the second address to compare.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if the addresses are equal, '-1' if they are different. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00823">823</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, and <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="sockutils.h::sock_discard"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_discard </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It discards N bytes that are currently waiting to be read on the current socket.
<p>
This function is useful in case we receive a message we cannot undestand (e.g. wrong version number when receiving a network packet), so that we have to discard all data before reading a new message.<p>
This function will read 'size' bytes from the socket and discard them. It defines an internal buffer in which data will be copied; however, in case this buffer is not large enough, it will cycle in order to read everything as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be discarded.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00672">672</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, and <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l02043">rpcap_checkver()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="sockutils.h::sock_geterror"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sock_geterror </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>caller</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves the error message after an error occurred in the socket interface.
<p>
This function is defined because of the different way errors are returned in UNIX and Win32. This function provides a consistent way to retrieve the error message (after a socket error occurred) on all the platforms.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>caller:</em>&nbsp;</td><td>a pointer to a user-allocated string which contains a message that has to be printed *before* the true error message. It could be, for example, 'this error comes from the recv() call at line 31'.</td></tr>
    <tr><td valign=top><em>string:</em>&nbsp;</td><td>a pointer to an user-allocated buffer that will contain the complete error message. This buffer has to be at least 'size' in length.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>the size of the buffer in which the error message will be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>No return values. The error message is returned in the 'string' parameter. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00116">116</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8h-source.html#l00136">SOCK_ERRBUF_SIZE</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01285">pcap_remoteact_list()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>, <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00635">sock_recv_dgram()</a>, and <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="sockutils.h::sock_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>errbuf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It initializes sockets.
<p>
This function is pretty useless on UNIX, since socket initialization is not required. However it is required on Win32. In UNIX, this function appears to be completely empty.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00160">160</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8c-source.html#l00058">sockcount</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00119">main()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="sockutils.c::sock_ismcastaddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_ismcastaddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct sockaddr *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>saddr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It checks if the sockaddr variable contains a multicast address.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if the address is multicast, '-1' if it is not. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00208">208</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="sockutils.h::sock_open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct addrinfo *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>addrinfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>nconn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It initializes a network connection both from the client and the server side.
<p>
In case of a client socket, this function calls socket() and connect(). In the meanwhile, it checks for any socket error. If an error occurs, it writes the error message into 'errbuf'.<p>
In case of a server socket, the function calls socket(), bind() and listen().<p>
In no cases this fucntion will authenticate the user on the remote host. This function has to be done in the <a class="el" href="group__remote__pri__func.html#a29">rpcap_sendauth()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>addrinfo:</em>&nbsp;</td><td>pointer to an addrinfo variable which will be used to open the socket and such. This variable is the one returned by the previous call to sockvalidateaddr().</td></tr>
    <tr><td valign=top><em>server:</em>&nbsp;</td><td>'1' if this is a server socket, '0' otherwise.</td></tr>
    <tr><td valign=top><em>nconn:</em>&nbsp;</td><td>number of the connections that are allowed to wait into the listen() call. This value has no meanings in case of a client socket.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the socket that has been opened (that has to be used in the following sockets calls) if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00254">254</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="sockutils.h::sock_recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It waits on a connected socket and it manages to receive exactly 'size' bytes.
<p>
This function basically calls the recv() socket function and it checks that no error occurred. If that happens, it writes the error message into 'errbuf'. In case the socket does not have enough data available, it cycles on the recv() util the requested data (of size 'size') is arrived.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data has to be stored</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>size of the allocated buffer. WARNING: this indicates the number of bytes that we are expecting to be read. This function (differenctly from the rpcap_recv_dgram() ) block until the number of bytes read is equal to 'size'.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00566">566</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01147">daemon_unpackapplyfilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>, and <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="sockutils.h::sock_recv_dgram"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_recv_dgram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It waits on a connected socket and it manages to receive one message.
<p>
There is a difference here between this function and the <a class="el" href="group__remote__pri__func.html#a9">sock_recv()</a>: the previous one will loop until 'size' bytes are read (i.e. until a message with the expected size has arrived); here just one recv() is done, and all what is waiting in the socket bufer is read all at once.<p>
This function is required for UDP sockets, in which the message has to be read all at once, otherwise it is discarded. Therefore we have to call this function with a large buffer, in order to be sure no data is lost. It follow that the number of bytes received is usually less than the size buffer: therefore we must exit anyway, even if the number of bytes read is less than the size of the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data has to be stored.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>size of the allocated buffer. WARNING: this indicates the maximum number of bytes that we can read. This function (differenctly from the rpcap_recv_dgram() ) does not block if the number of bytes read is equal to 'size'.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00635">635</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="sockutils.h::sock_send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>socket</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends the amount of data contained into 'buffer' on the given socket.
<p>
This function basically calls the send() socket function and it checks that all the data specified in 'buffer' (of size 'size') will be sent. If an error occurs, it writes the error message into 'errbuf'. In case the socket buffer does not have enough space, it loops until all data has been sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>socket:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data is contained.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be sent.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00443">443</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="sockutils.h::sock_validaddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_validaddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>address</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct addrinfo *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct addrinfo **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>addrinfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks that the address, port and flags given are valids and it returns an 'addrinfo' stucture.
<p>
This function basically calls the getaddrinfo() calls, and it performs a set of sanity checks to control that everything is fine (e.g. a TCP socket cannot have a mcast address, and such). If an error occurs, it writes the error message into 'errbuf'.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>address:</em>&nbsp;</td><td>a pointer to a user-allocated buffer containing the network address to check. It could be both a numeric - literal address, and it can be NULL or "" (useful in case of a server socket which has to bind to all addresses).</td></tr>
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>a pointer to a user-allocated buffer containing the network port to use.</td></tr>
    <tr><td valign=top><em>hints:</em>&nbsp;</td><td>an addrinfo variable (passed by reference) containing the flags needed to create the addrinfo structure appropriately.</td></tr>
    <tr><td valign=top><em>addrinfo:</em>&nbsp;</td><td>it represents the true returning value. This is a pointer to an addrinfo variable (passed by reference), which will be allocated by this function and returned back to the caller. This variable will be used in the next sockets calls.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. The addrinfo variable that has to be used in the following sockets calls is returned into the addrinfo parameter.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>The 'addrinfo' variable has to be deleted by the programmer by calling freeaddrinfo() when it is no longer needed.<p>
SOCKET: I should check all the accept() in order to bind to all addresses (in case addrinfo has more han one pointers, and all connect() to use all addresses (in the case the firs one fails) </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00386">386</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8c-source.html#l00208">sock_ismcastaddr()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
