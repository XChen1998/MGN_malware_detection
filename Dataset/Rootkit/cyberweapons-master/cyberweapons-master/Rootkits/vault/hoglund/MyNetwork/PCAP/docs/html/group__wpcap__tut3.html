<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Opening an adapter and capturing the packets</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Opening an adapter and capturing the packets<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to program WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Now that we've seen how to obtain an adapter to play with, let's start the real job, opening the device and capturing the transiting traffic. In this lesson we'll write a program that will print some information about every packet transiting on the network.<p>
The function that opens a capture device is <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a>. Among its parameters, <em>snaplen,</em> <em>promisc</em> and <em>to_ms</em> deserve a better explanation.<p>
<em>snaplen</em> specifies the portion of the packet to capture. On some OSes (like xBSD and Win32), the packet driver gives the possibility to capture only a part of any packet: this decreases the amount of data to copy and therefore improves the efficiency of the capture. In this case we use a value (65536) higher than the greatest MTU that we could encounter, therefore we are sure that the application will always receive the whole packet.<p>
<em>promisc</em> indicates if the adapter will be put in promiscuous mode. In normal situations, an adapter extracts from the network only the traffic destined to it; the packets exchanged by other hosts are therefore ignored. Instead, when the adapter is in promiscuous mode it accepts the whole traffic: this means that on shared media (like non-switched Ethernet) WinPcap will be able to capture the packets of other hosts as well. Promiscuous mode is the default for most capture applications, so we enable it in the following example.<p>
<em>to_ms</em> specifies the read timeout, in milliseconds. A read on the adapter (for example with <a class="el" href="group__wpcap__fn.html#a11">pcap_dispatch()</a> or <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a>) will always return after <em>to_ms</em> milliseconds, also if no packets are available from the network. Moreover, <em>to_ms</em> defines the interval between statistical report if the adapter is in statistical mode (see the lesson "<a class="el" href="group__wpcap__tut9.html">Gathering Statistics on the network traffic</a> " for information about statistical mode). Setting <em>to_ms</em> to 0 means no timeout, a read on the adapter never returns if no packets arrive. A -1 timeout on the other side causes a read on the adapter to always return immediately.<p>
<div class="fragment"><pre><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

<a class="code" href="pcap__filter_8c.html#a4">main</a>()
{
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
    <span class="keywordtype">int</span> inum;
    <span class="keywordtype">int</span> i=0;
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *adhandle;
    <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    
    <span class="comment">/* Retrieve the device list */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }
    
    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>, i++);
    
    <span class="comment">/* Open the adapter */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, <span class="comment">// name of the device</span>
                             65536,     <span class="comment">// portion of the packet to capture. </span>
                             <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span>
                             1,         <span class="comment">// promiscuous mode</span>
                             1000,      <span class="comment">// read timeout</span>
                             errbuf     <span class="comment">// error buffer</span>
                             ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
    
    <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
    <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcap__fn.html#a6">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
    
    <span class="keywordflow">return</span> 0;
}


<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    
    <span class="comment">/* convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);
    
    printf(<span class="stringliteral">"%s,%.6d len:%d\n"</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>);
    
}
</pre></div><p>
Once the adapter is opened, the capture can be started with <a class="el" href="group__wpcap__fn.html#a11">pcap_dispatch()</a> or <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a>. These two functions are very similar, the difference is that pcap_ dispatch() is granted to return when the expires while <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> doesn't return until <em>cnt</em> packets have been captured, so it can block for an arbitrary period on a few utilized network. <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> is enough for the purpose of this sample, while <a class="el" href="group__wpcap__fn.html#a11">pcap_dispatch()</a> is normally used in more complex program.<p>
Both these functions have a <em>callback</em> parameter, pointing to a function that will receive the packets, packet_handler in this case. This function is invoked by libpcap for every new packet coming from the network and receives a generic status (corresponding to the <em>user</em> parameter of <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> and <a class="el" href="group__wpcap__fn.html#a11">pcap_dispatch()</a>), an header with some information on the packet like the timestamp and the length, and finally the actual data of the packet including all the protocol headers. Note that the MAC CRC is normally not present, because it is removed by the network adapter after frame validation. Note also that most adapters discard the packets with wrong CRC, therefore WinPcap is normally not able to capture them.<p>
The just proposed example extracts the timestamp and the length of every packet from the <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> header and prints them on the screen. 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
