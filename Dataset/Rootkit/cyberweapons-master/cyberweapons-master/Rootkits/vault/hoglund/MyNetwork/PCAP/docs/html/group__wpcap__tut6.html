<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Interpreting the packets</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Interpreting the packets<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to program WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Now that we are able to sniff and filter the traffic, we want to put our knowledge in practice with a first simple "real world" application.<p>
In this lesson we will take the code of the previous lessons and extend it to build a more useful program; the main purpose is to show how the content of a captured packet, and in particular its protocol headers can be parsed and interpreted. The resulting application, called UDPdump, will print on the screen a summary of the UDP traffic of our network.<p>
We choose to display the UDP protocol because it's simpler than TCP, so it's more immediate from a didactic perspective. Let's give a look at the code.<p>
<div class="fragment"><pre><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2002</span>
<span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
<span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
<span class="comment"> * distributions including binary code include the above copyright notice and</span>
<span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
<span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
<span class="comment"> * features or use of this software display the following acknowledgement:</span>
<span class="comment"> * ``This product includes software developed by the Politecnico</span>
<span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
<span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
<span class="comment"> * or promote products derived from this software without specific prior</span>
<span class="comment"> * written permission.</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
<span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
<span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* 4 bytes IP address */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_address{
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
}ip_address;

<span class="comment">/* IPv4 header */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_header{
    u_char  ver_ihl;        <span class="comment">// Version (4 bits) + Internet header length (4 bits)</span>
    u_char  tos;            <span class="comment">// Type of service </span>
    u_short tlen;           <span class="comment">// Total length </span>
    u_short identification; <span class="comment">// Identification</span>
    u_short flags_fo;       <span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span>
    u_char  ttl;            <span class="comment">// Time to live</span>
    u_char  <a class="code" href="gencode_8c.html#a46">proto</a>;          <span class="comment">// Protocol</span>
    u_short crc;            <span class="comment">// Header checksum</span>
    ip_address  saddr;      <span class="comment">// Source address</span>
    ip_address  daddr;      <span class="comment">// Destination address</span>
    u_int   op_pad;         <span class="comment">// Option + Padding</span>
}ip_header;

<span class="comment">/* UDP header*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>udp_header{
    u_short sport;          <span class="comment">// Source port</span>
    u_short dport;          <span class="comment">// Destination port</span>
    u_short len;            <span class="comment">// Datagram length</span>
    u_short crc;            <span class="comment">// Checksum</span>
}udp_header;

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);


<a class="code" href="pcap__filter_8c.html#a4">main</a>()
{
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
    <span class="keywordtype">int</span> inum;
    <span class="keywordtype">int</span> i=0;
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *adhandle;
    <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    u_int netmask;
    <span class="keywordtype">char</span> packet_filter[] = <span class="stringliteral">"ip and udp"</span>;
    <span class="keyword">struct </span><a class="code" href="structbpf__program.html">bpf_program</a> fcode;
  
    <span class="comment">/* Retrieve the device list */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>, i++);
    
    <span class="comment">/* Open the adapter */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, <span class="comment">// name of the device</span>
                             65536,     <span class="comment">// portion of the packet to capture. </span>
                                        <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span>
                             1,         <span class="comment">// promiscuous mode</span>
                             1000,      <span class="comment">// read timeout</span>
                             errbuf     <span class="comment">// error buffer</span>
                             ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a11">pcap_datalink</a>(adhandle) != DLT_EN10MB)
    {
        fprintf(stderr,<span class="stringliteral">"\nThis program works only on Ethernet networks.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="keywordflow">if</span>(d-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a> != NULL)
        <span class="comment">/* Retrieve the mask of the first address of the interface */</span>
        netmask=((<span class="keyword">struct </span>sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;
    <span class="keywordflow">else</span>
        <span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span>
        netmask=0xffffff; 


    <span class="comment">//compile the filter</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a111">pcap_compile</a>(adhandle, &amp;fcode, packet_filter, 1, netmask) &lt;0 ){
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">//set the filter</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a8">pcap_setfilter</a>(adhandle, &amp;fcode)&lt;0){
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;description);
    
    <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
    <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcap__fn.html#a6">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    ip_header *ih;
    udp_header *uh;
    u_int ip_len;
    u_short sport,dport;

    <span class="comment">/* convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* print timestamp and length of the packet */</span>
    printf(<span class="stringliteral">"%s.%.6d len:%d "</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>);

    <span class="comment">/* retireve the position of the ip header */</span>
    ih = (ip_header *) (pkt_data +
        14); <span class="comment">//length of ethernet header</span>

    <span class="comment">/* retireve the position of the udp header */</span>
    ip_len = (ih-&gt;ver_ihl &amp; 0xf) * 4;
    uh = (udp_header *) ((u_char*)ih + ip_len);

    <span class="comment">/* convert from network byte order to host byte order */</span>
    sport = ntohs( uh-&gt;sport );
    dport = ntohs( uh-&gt;dport );

    <span class="comment">/* print ip addresses and udp ports */</span>
    printf(<span class="stringliteral">"%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n"</span>,
        ih-&gt;saddr.byte1,
        ih-&gt;saddr.byte2,
        ih-&gt;saddr.byte3,
        ih-&gt;saddr.byte4,
        sport,
        ih-&gt;daddr.byte1,
        ih-&gt;daddr.byte2,
        ih-&gt;daddr.byte3,
        ih-&gt;daddr.byte4,
        dport);
}
</pre></div><p>
First of all, we set the filter "ip and udp". In this way we are sure that <a class="el" href="basic__dump_8c.html#a0">packet_handler()</a> will receive only UDP packets over IPv4: this simplifies the parsing and increases the efficiency of the program.<p>
We have also created a couple of structs that describe the IP and UDP headers. These structs are used by <a class="el" href="basic__dump_8c.html#a0">packet_handler()</a> to properly locate the various header fields.<p>
<a class="el" href="basic__dump_8c.html#a0">packet_handler()</a>, although limited to a single protocol dissector (UDP over IPv4), shows how complex sniffers like tcpdump/WinDump decode the network traffic. First of all, since we aren't interested in the MAC header, we skip it. For simplicity, before starting the capture we made a check on the MAC layer with <a class="el" href="group__wpcap__fn.html#a19">pcap_datalink()</a>, so that UDPdump will work only on Ethernet networks. In this way we are sure that the MAC header is exactly 14 bytes.<p>
The IP header is located just after the MAC one. We extract from it the source and destination addresses.<p>
Reaching the UDP header is a bit more complex, because the IP header hasn't a fixed length. Therefore, we use the internet header length field to know its dimension. Once we know the location of the UDP header, we extract the source and destination ports.<p>
The extracted values are printed on the screen, and the result is something like:<p>
<code> 1. {A7FD048A-5D4B-478E-B3C1-34401AC3B72F} (Xircom t 10/100 Adapter) <br>
 Enter the interface number (1-2):1<br>
</code><p>
<code>listening on Xircom CardBus Ethernet 10/100 Adapter... <br>
 16:13:15.312784 len:87 130.192.31.67.2682 -&gt; 130.192.3.21.53 <br>
 16:13:15.314796 len:137 130.192.3.21.53 -&gt; 130.192.31.67.2682 <br>
 16:13:15.322101 len:78 130.192.31.67.2683 -&gt; 130.192.3.21.53 <br>
 </code><p>
In which every line represents a different packet. 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
