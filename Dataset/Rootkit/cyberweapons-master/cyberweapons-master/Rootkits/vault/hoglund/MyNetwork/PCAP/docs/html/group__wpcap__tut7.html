<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Handling offline dump files</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Handling offline dump files<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to program WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
In the previous lessons we became experts in packet capture from network cards, now we're going to learn how to handle packet dumps. WinPcap offers a wide range of functions to save the network traffic to a file and to read the content of dumps; this lesson will teach how to use all these functions. We'll see also how to use the kernel dump feature of WinPcap to obtain high-performance dumps.<p>
The file format is the libpcap one. This format, very simple, contains the data of the captured packets in binary form and is a standard used by a lot of network tools like for example WinDump, Ethereal and Snort.<p>
<b>Saving packets to a dump file</b><p>
First of all, let's see how to write packets in libpcap format.<p>
The following example captures the packets from the selected interface and saves them on a file whose name is provided by the user.<p>
<div class="fragment"><pre><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

<a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
    <span class="keywordtype">int</span> inum;
    <span class="keywordtype">int</span> i=0;
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *adhandle;
    <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    <a class="code" href="group__wpcap__def.html#a3">pcap_dumper_t</a> *dumpfile;


    
    <span class="comment">/* Check command line */</span>
    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }
    
    <span class="comment">/* Retrieve the device list */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
        
    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#m0">next</a>, i++);
    
    <span class="comment">/* Open the adapter */</span>
    <span class="keywordflow">if</span> ( (adhandle = <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, <span class="comment">// name of the device</span>
                             65536,     <span class="comment">// portion of the packet to capture. </span>
                                        <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span>
                             1,         <span class="comment">// promiscuous mode</span>
                             1000,      <span class="comment">// read timeout</span>
                             errbuf     <span class="comment">// error buffer</span>
                             ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Open the dump file */</span>
    dumpfile = <a class="code" href="group__wpcap__fn.html#a61">pcap_dump_open</a>(adhandle, argv[1]);
    <span class="keywordflow">if</span>(dumpfile==NULL){
        fprintf(stderr,<span class="stringliteral">"\nError opening output file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
    
    <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
    <a class="code" href="group__wpcap__fn.html#a11">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcap__fn.html#a6">pcap_loop</a>(adhandle, 0, packet_handler, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dumpfile);

    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> <a class="code" href="basic__dump_8c.html#a0">packet_handler</a>(u_char *dumpfile, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="comment">/* save the packet on the dump file */</span>
    <a class="code" href="group__wpcap__fn.html#a60">pcap_dump</a>(dumpfile, header, pkt_data);
}
</pre></div><p>
As you can see, the structure of the program is very similar to the ones seen in the previous lessons. The differences are:<ul>
<li>a call to <a class="el" href="group__wpcap__fn.html#a4">pcap_dump_open()</a> is issued once the interface is opened. This call opens a dump file and associates it with the interface.</li><li>the packets are written to this file with a <a class="el" href="group__wpcap__fn.html#a13">pcap_dump()</a> inside the <a class="el" href="basic__dump_8c.html#a0">packet_handler()</a> callback. The parameters of this function are the same received by the <a class="el" href="group__wpcap__fn.html#a0">pcap_handler()</a>, so saving a packet is very simple.</li></ul>
<p>
<b>Reading packets from a dump file</b><p>
Now that we have a dump file available, we can see how to read its content. The following code opens a libpcap dump and displays every packet contained in it. The file is opened with <a class="el" href="group__wpcap__fn.html#a3">pcap_open_offline()</a>, then the usual <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> is used to cycle among the packets. As you can see, reading packets from an offline capture is nearly identical to receiving them from a physical interface.<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a2">dispatcher_handler</a>(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);

<a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;
    <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];


    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }
    
    <span class="comment">/* Open a capture file */</span>
    <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcap__fn.html#a57">pcap_open_offline</a>(argv[1], errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening dump file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">// read and dispatch packets until EOF is reached</span>
    <a class="code" href="group__wpcap__fn.html#a6">pcap_loop</a>(fp, 0, dispatcher_handler, NULL);

    <span class="keywordflow">return</span> 0;
}



<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a2">dispatcher_handler</a>(u_char *temp1, 
                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    u_int i=0;
    
    <span class="comment">/* print pkt timestamp and pkt len */</span>
    printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>);          
    
    <span class="comment">/* Print the packet */</span>
    <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + 1 ) ; i++)
    {
        printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
        <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
    }
    
    printf(<span class="stringliteral">"\n\n"</span>);     
    
}
</pre></div><p>
The following example has the same purpose of the last one, but <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a> is used instead of the <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> callback method.<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
<a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;
    <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header;
    u_char *pkt_data;
    u_int i=0;
    <span class="keywordtype">int</span> res;

    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }
    
    <span class="comment">/* Open a capture file */</span>
    <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcap__fn.html#a57">pcap_open_offline</a>(argv[1], errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening dump file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Retrieve the packets from the file */</span>
    <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcap__fn.html#a10">pcap_next_ex</a>( fp, &amp;header, &amp;pkt_data)) &gt;= 0){
        <span class="comment">/* print pkt timestamp and pkt len */</span>
        printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>);          
        
        <span class="comment">/* Print the packet */</span>
        <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + 1 ) ; i++)
        {
            printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
            <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
        }
        
        printf(<span class="stringliteral">"\n\n"</span>);     
    }
    
    
    <span class="keywordflow">if</span>(res == -1){
        printf(<span class="stringliteral">"Error reading the packets: %s\n"</span>, <a class="code" href="group__wpcap__fn.html#a24">pcap_geterr</a>(fp));
    }
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><p>
<b>Writing packets to a dump file with pcap_live_dump</b><p>
Recent versions of WinPcap provide a further way to save network traffic to disk, the <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> function. <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> takes three parameters: a file name, the maximum size (in bytes) that this file is allowed to reach and the maximum amount of packets that the file is allowed to contain. Zero means no limit for both these values. Notice that the program can set a filter (with <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>, see the tutorial <a class="el" href="group__wpcap__tut5.html">Filtering the traffic</a> ) before calling <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> to define the subset of the traffic that will be saved.<p>
<a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> is non-blocking, therefore it starts the dump and returns immediately: The dump process goes on asynchronously until the maximum file size or the maximum amount of packets has been reached.<p>
The application can wait or check the end of the dump with <a class="el" href="group__wpcap__fn.html#a43">pcap_live_dump_ended()</a>. <b>Beware</b> that if the <em>sync</em> parameter is nonzero this function will block your application forever if the limits are both 0.<p>
<div class="fragment"><pre></pre></div><p>
The difference between <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> and <a class="el" href="group__wpcap__fn.html#a13">pcap_dump()</a>, apart from the possibility to set limits, is performance. <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> exploits the ability of the WinPcap NPF driver (see <a class="el" href="group__NPF.html">NPF driver internals manual</a> ) to write dumps from kernel level, minimizing the number of context switches and memory copies.<p>
Obviously, since this feature is currently not available on other operating systems, <a class="el" href="group__wpcap__fn.html#a42">pcap_live_dump()</a> is WinPcap specific and is present only under Win32. 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
