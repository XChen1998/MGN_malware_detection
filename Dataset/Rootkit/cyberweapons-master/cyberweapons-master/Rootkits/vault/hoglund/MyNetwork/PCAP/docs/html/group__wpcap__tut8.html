<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sending Packets</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Sending Packets<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to program WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Although the name <em>WinPcap</em> indicates clearly that the main purpose of the library is packet capture, other useful features for raw networking are provided. Among them, the user can find a complete set of functions to send packets, that this lesson will show.<p>
Note that the original libpcap library at the moment doesn't provide any way to send packets: all the functions showed here are WinPcap externsions and will not work under Unix.<p>
<b>Sending a single packet with pcap_sendpacket</b><p>
the simplest way to send a packet is shown in the next code snippet. After opening an adapter, <a class="el" href="group__wpcap__fn.html#a34">pcap_sendpacket()</a> is called to send a hand-crafted packet. <a class="el" href="group__wpcap__fn.html#a34">pcap_sendpacket()</a> takes as arguments a buffer containing the data to send, its length and the adapter that will send it. Notice that the buffer is sent to the net as is, without any manipulation: this means that the application has to create the correct protocol headers in order to send something meaningful.<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a3">usage</a>();

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;
    <span class="keywordtype">char</span> error[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    u_char packet[100];
    <span class="keywordtype">int</span> i;

    <span class="comment">/* Check the validity of the command line */</span>
    <span class="keywordflow">if</span> (argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s inerface"</span>, argv[0]);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Open the output adapter */</span>
    <span class="keywordflow">if</span>((fp = <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(argv[1], 100, 1, 1000, error) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening adapter: %s\n"</span>, error);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Supposing to be on ethernet, set mac destination to 1:1:1:1:1:1 */</span>
    packet[0]=1;
    packet[1]=1;
    packet[2]=1;
    packet[3]=1;
    packet[4]=1;
    packet[5]=1;
    
    <span class="comment">/* set mac source to 2:2:2:2:2:2 */</span>
    packet[6]=2;
    packet[7]=2;
    packet[8]=2;
    packet[9]=2;
    packet[10]=2;
    packet[11]=2;
    
    <span class="comment">/* Fill the rest of the packet */</span>
    <span class="keywordflow">for</span>(i=12;i&lt;100;i++){
        packet[i]=i%256;
    }

    <span class="comment">/* Send down the packet */</span>
    <a class="code" href="group__wpcap__fn.html#a10">pcap_sendpacket</a>(fp,
        packet,
        100);

    <span class="keywordflow">return</span>;
}
</pre></div><p>
<b>Send queues</b><p>
While <a class="el" href="group__wpcap__fn.html#a34">pcap_sendpacket()</a> offers a simple and immediate way to send a single packet, send queues provide an advanced, powerful and optimized mechanism to send groups of packets. A send queue is a container for a variable number of packets that will be sent to the network. It has a size, that represents the maximum amount of bytes it can store.<p>
A send queue is created calling the <a class="el" href="group__wpcap__fn.html#a37">pcap_sendqueue_alloc()</a> function, specifying the size that the new queue will have.<p>
Once the queue is created, <a class="el" href="group__wpcap__fn.html#a39">pcap_sendqueue_queue()</a> can be used to store a packet in it. This function receives a <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> with the timestamp and the length and a buffer with the data of the packet. These parameters are the same received by <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a> and <a class="el" href="group__wpcap__fn.html#a0">pcap_handler()</a>, therefore queuing a packet that was just captured or read from a file is a matter of passing them to <a class="el" href="group__wpcap__fn.html#a39">pcap_sendqueue_queue()</a>.<p>
To send a queue, WinPcap provides the <a class="el" href="group__wpcap__fn.html#a40">pcap_sendqueue_transmit()</a> function. Note the third parameter: if nonzero, the send will be <em>synchronized,</em> i.e. the relative timestamps of the packets will be respected. This requires a remarkable amount of CPU, because the synchronization takes place in the kernel driver using "brute force" loops, but normally grants a very high precision (often around few microseconds or less).<p>
Note that sending a queue with <a class="el" href="group__wpcap__fn.html#a40">pcap_sendqueue_transmit()</a> is much more efficient than performing a series of <a class="el" href="group__wpcap__fn.html#a34">pcap_sendpacket()</a>, because a send queue is buffered at kernel level decreasing drastically the number of context switches.<p>
When a queue is no more needed, it can be deleted with <a class="el" href="group__wpcap__fn.html#a38">pcap_sendqueue_destroy()</a> that frees all the buffers associated with it.<p>
The next code shows how to use send queues. It opens a capture file with <a class="el" href="group__wpcap__fn.html#a3">pcap_open_offline()</a>, then it moves the packets from the file to a properly allocated queue. At his point it transmits the queue, synchronizing it if requested by the user.<p>
Note that the link-layer of the dumpfile is compared with the one of the interface that will send the packets using <a class="el" href="group__wpcap__fn.html#a19">pcap_datalink()</a>, and a warning is printed if they are different: sending on a link-layer the packets captured from a different one is quite pointless.<p>
<div class="fragment"><pre><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2002</span>
<span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
<span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
<span class="comment"> * distributions including binary code include the above copyright notice and</span>
<span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
<span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
<span class="comment"> * features or use of this software display the following acknowledgement:</span>
<span class="comment"> * ``This product includes software developed by the Politecnico</span>
<span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
<span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
<span class="comment"> * or promote products derived from this software without specific prior</span>
<span class="comment"> * written permission.</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
<span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
<span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a3">usage</a>();

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *indesc,*outdesc;
    <span class="keywordtype">char</span> error[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    FILE *capfile;
    <span class="keywordtype">int</span> caplen,
        sync;
    u_int res;
    <a class="code" href="structpcap__send__queue.html">pcap_send_queue</a> *squeue;
    <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pktheader;
    u_char *pktdata;

    <span class="comment">/* Check the validity of the command line */</span>
    <span class="keywordflow">if</span> (argc &lt;= 2 || argc &gt;= 5)
    {
        <a class="code" href="pcap__filter_8c.html#a3">usage</a>();
        <span class="keywordflow">return</span>;
    }
        
    <span class="comment">/* Retrieve the length of the capture file */</span>
    capfile=fopen(argv[1],<span class="stringliteral">"rb"</span>);
    <span class="keywordflow">if</span>(!capfile){
        printf(<span class="stringliteral">"Capture file not found!\n"</span>);
        <span class="keywordflow">return</span>;
    }
    
    fseek(capfile , 0, SEEK_END);
    caplen= ftell(capfile)- <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__file__header.html">pcap_file_header</a>);
    fclose(capfile);
            
    <span class="comment">/* Chek if the timestamps must be respected */</span>
    <span class="keywordflow">if</span>(argc == 4 &amp;&amp; argv[3][0] == <span class="charliteral">'s'</span>)
        sync = TRUE;
    <span class="keywordflow">else</span>
        sync = FALSE;

    <span class="comment">/* Open the capture */</span>
    <span class="keywordflow">if</span>((indesc = <a class="code" href="group__wpcap__fn.html#a57">pcap_open_offline</a>(argv[1], error)) == NULL){
        fprintf(stderr,<span class="stringliteral">"\nError opening the input file: %s\n"</span>, error);
        <span class="keywordflow">return</span>; 
    }

    <span class="comment">/* Open the output adapter */</span>
    <span class="keywordflow">if</span>((outdesc = <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(argv[2], 100, 1, 1000, error) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening adapter: %s\n"</span>, error);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Check the MAC type */</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a11">pcap_datalink</a>(indesc) != <a class="code" href="group__wpcap__fn.html#a11">pcap_datalink</a>(outdesc)){
        printf(<span class="stringliteral">"Warning: the datalink of the capture differs from the one of the selected interface.\n"</span>);
        printf(<span class="stringliteral">"Press a key to continue, or CTRL+C to stop.\n"</span>);
        getchar();
    }

    <span class="comment">/* Allocate a send queue */</span>
    squeue = <a class="code" href="group__wpcap__fn.html#a2">pcap_sendqueue_alloc</a>(caplen);

    <span class="comment">/* Fill the queue with the packets from the file */</span>
    <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcap__fn.html#a10">pcap_next_ex</a>( indesc, &amp;pktheader, &amp;pktdata)) == 1){
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a4">pcap_sendqueue_queue</a>(squeue, pktheader, pktdata) == -1){
            printf(<span class="stringliteral">"Warning: packet buffer too small, not all the packets will be sent.\n"</span>);
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span>(res == -1){
        printf(<span class="stringliteral">"Corrupted input file.\n"</span>);
        <a class="code" href="group__wpcap__fn.html#a3">pcap_sendqueue_destroy</a>(squeue);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Transmit the queue */</span>
    
    <span class="keywordflow">if</span>((res = <a class="code" href="group__wpcap__fn.html#a5">pcap_sendqueue_transmit</a>(outdesc, squeue, sync)) &lt; squeue-&gt;<a class="code" href="structpcap__send__queue.html#m1">len</a>)
    {
        printf(<span class="stringliteral">"An error occurred sending the packets: %s. Only %d bytes were sent\n"</span>, error, res);
    }
    
    <span class="comment">/* free the send queue */</span>
    <a class="code" href="group__wpcap__fn.html#a3">pcap_sendqueue_destroy</a>(squeue);

    <span class="keywordflow">return</span>;
}


<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a3">usage</a>()
{
    
    printf(<span class="stringliteral">"\nSendcap, sends a libpcap/tcpdump capture file to the net. Copyright (C) 2002 Loris Degioanni.\n"</span>);
    printf(<span class="stringliteral">"\nUsage:\n"</span>);
    printf(<span class="stringliteral">"\t sendcap file_name adapter [s]\n"</span>);
    printf(<span class="stringliteral">"\nParameters:\n"</span>);
    printf(<span class="stringliteral">"\nfile_name: the name of the dump file that will be sent to the network\n"</span>);
    printf(<span class="stringliteral">"\nadapter: the device to use. Use \"WinDump -D\" for a list of valid devices\n"</span>);
    printf(<span class="stringliteral">"\ns: if present, forces the packets to be sent synchronously, i.e. respecting the timestamps in the dump file. This option will work only under Windows NTx.\n\n"</span>);

    exit(0);
}
</pre></div> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
