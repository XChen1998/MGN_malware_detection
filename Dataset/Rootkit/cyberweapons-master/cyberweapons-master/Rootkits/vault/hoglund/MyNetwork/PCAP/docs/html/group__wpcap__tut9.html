<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Gathering Statistics on the network traffic</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Gathering Statistics on the network traffic<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to program WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
This lesson shows another advanced feature of WinPcap: the ability to collect statistics about network traffic. The statistical engine makes use of the kernel-level packet filter to efficiently classify the incoming packet. You can give a look at the <a class="el" href="group__NPF.html">NPF driver internals manual</a> if you want to know more details.<p>
In order to use this feature to monitor the network, the programmer must open an adapter and put it in <em>statistical</em> <em>mode.</em> This can be done with <a class="el" href="group__wpcap__fn.html#a33">pcap_setmode()</a>. In particular, MODE_STAT must be used as the <em>mode</em> argument of this function.<p>
With statistical mode, making an application that monitors the TCP traffic load is a matter of few lines of code. The following sample shows how to do it.<p>
<div class="fragment"><pre><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2002</span>
<span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
<span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
<span class="comment"> * distributions including binary code include the above copyright notice and</span>
<span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
<span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
<span class="comment"> * features or use of this software display the following acknowledgement:</span>
<span class="comment"> * ``This product includes software developed by the Politecnico</span>
<span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
<span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
<span class="comment"> * or promote products derived from this software without specific prior</span>
<span class="comment"> * written permission.</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
<span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
<span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a3">usage</a>();

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a2">dispatcher_handler</a>(u_char *, 
    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);


<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;
    <span class="keywordtype">char</span> error[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>];
    <span class="keyword">struct </span>timeval st_ts;
    u_int netmask;
    <span class="keyword">struct </span><a class="code" href="structbpf__program.html">bpf_program</a> fcode;
  
    <span class="comment">/* Check the validity of the command line */</span>
    <span class="keywordflow">if</span> (argc != 2)
    {
        <a class="code" href="pcap__filter_8c.html#a3">usage</a>();
        <span class="keywordflow">return</span>;
    }
        
    <span class="comment">/* Open the output adapter */</span>
    <span class="keywordflow">if</span>((fp = <a class="code" href="group__wpcap__fn.html#a1">pcap_open_live</a>(argv[1], 100, 1, 1000, error) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening adapter: %s\n"</span>, error);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Don't care about netmask, it won't be used for this filter */</span>
    netmask=0xffffff; 

    <span class="comment">//compile the filter</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a111">pcap_compile</a>(fp, &amp;fcode, <span class="stringliteral">"tcp"</span>, 1, netmask) &lt;0 ){
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <span class="keywordflow">return</span>;
    }
    
    <span class="comment">//set the filter</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcap__fn.html#a8">pcap_setfilter</a>(fp, &amp;fcode)&lt;0){
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Put the interface in statstics mode */</span>
    <a class="code" href="group__wpcap__fn.html#a9">pcap_setmode</a>(fp, MODE_STAT);

    printf(<span class="stringliteral">"TCP traffic summary:\n"</span>);

    <span class="comment">/* Start the main loop */</span>
    <a class="code" href="group__wpcap__fn.html#a6">pcap_loop</a>(fp, 0, dispatcher_handler, (PUCHAR)&amp;st_ts);

    <span class="keywordflow">return</span>;
}

<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a2">dispatcher_handler</a>(u_char *state, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>timeval *old_ts = (<span class="keyword">struct </span>timeval *)state;
    u_int delay;
    LARGE_INTEGER Bps,Pps;
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];

    <span class="comment">/* Calculate the delay in microseconds from the last sample. */</span>
    <span class="comment">/* This value is obtained from the timestamp that the associated with the sample. */</span>
    delay=(header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec - old_ts-&gt;tv_sec) * 1000000 - old_ts-&gt;tv_usec + header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec;
    <span class="comment">/* Get the number of Bits per second */</span>
    Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
    <span class="comment">/*                                            ^      ^</span>
<span class="comment">                                                  |      |</span>
<span class="comment">                                                  |      | </span>
<span class="comment">                                                  |      |</span>
<span class="comment">                         converts bytes in bits --       |</span>
<span class="comment">                                                         |</span>
<span class="comment">                    delay is expressed in microseconds --</span>
<span class="comment">    */</span>

    <span class="comment">/* Get the number of Packets per second */</span>
    Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));

    <span class="comment">/* Convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* Print timestamp*/</span>
    printf(<span class="stringliteral">"%s "</span>, timestr);

    <span class="comment">/* Print the samples */</span>
    printf(<span class="stringliteral">"BPS=%I64u "</span>, Bps.QuadPart);
    printf(<span class="stringliteral">"PPS=%I64u\n"</span>, Pps.QuadPart);

    <span class="comment">//store current timestamp</span>
    old_ts-&gt;tv_sec=header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec;
    old_ts-&gt;tv_usec=header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec;
}


<span class="keywordtype">void</span> <a class="code" href="pcap__filter_8c.html#a3">usage</a>()
{
    
    printf(<span class="stringliteral">"\nShows the TCP traffic load, in bits per second and packets per second.\nCopyright (C) 2002 Loris Degioanni.\n"</span>);
    printf(<span class="stringliteral">"\nUsage:\n"</span>);
    printf(<span class="stringliteral">"\t tcptop adapter\n"</span>);
    printf(<span class="stringliteral">"\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n"</span>);

    exit(0);
}
</pre></div><p>
Before enabling statistical mode, the user has the possibility to set a filter, that defines the subset of network traffic that will be monitored. See the paragraph on the <a class="el" href="group__language.html">Filtering expression syntax</a> for details. If no filter has been set, the whole traffic will be monitored. Once<ul>
<li>the filter is set</li><li><a class="el" href="group__wpcap__fn.html#a33">pcap_setmode()</a> is called</li><li>callback invocation is enabled with <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a></li></ul>
<p>
the interface descriptor starts to work in statistical mode. Notice the fourth parameter (<em>to_ms)</em> of <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a>: it defines the interval among the statistical samples. The callback receives, every to_ms milliseconds, the samples calculated by the driver. These samples are encapsulated in the second and third parameter of the callback, like shown in the following figure:<p>
<div align="center">
<img src="stats_wpcap.gif" alt="stats_wpcap.gif">
</div>
 Two 64-bit counters are provided: the number of packets and the amount of bytes received during the last interval.<p>
In the example, the adapter is opened with a timeout of 1000 ms. This means that <a class="el" href="pcap__filter_8c.html#a2">dispatcher_handler()</a> is called once per second. At this point a filter that keeps only tcp packets is compiled and set. Then <a class="el" href="group__wpcap__fn.html#a33">pcap_setmode()</a> and <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> are called. Note that a struct timeval pointer is passed to <a class="el" href="group__wpcap__fn.html#a12">pcap_loop()</a> as the <em>user</em> parameter. This structure will be used to store a timestamp in order to calculate the interval between two samples. <a class="el" href="pcap__filter_8c.html#a2">dispatcher_handler()</a>uses this interval to obtain the bits per second and the packets per second and then prints these values on the screen.<p>
Note finally that this example is by far more efficient than a program that captures the packets in the traditional way and calculates statistics at user-level: statistical mode requires the minumum amount of data copies and context switches, therefore the CPU is optimized. Moreover, a very small quantity of memory is required. 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
