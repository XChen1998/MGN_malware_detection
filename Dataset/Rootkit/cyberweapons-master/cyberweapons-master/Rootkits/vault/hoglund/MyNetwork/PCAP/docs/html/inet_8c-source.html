<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>inet.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>inet.c</h1><a href="inet_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */</span>
00002 <span class="comment">/*</span>
00003 <span class="comment"> * Copyright (c) 1994, 1995, 1996, 1997, 1998</span>
00004 <span class="comment"> *  The Regents of the University of California.  All rights reserved.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00010 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00011 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00012 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
00013 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
00014 <span class="comment"> * 3. All advertising materials mentioning features or use of this software</span>
00015 <span class="comment"> *    must display the following acknowledgement:</span>
00016 <span class="comment"> *  This product includes software developed by the Computer Systems</span>
00017 <span class="comment"> *  Engineering Group at Lawrence Berkeley Laboratory.</span>
00018 <span class="comment"> * 4. Neither the name of the University nor of the Laboratory may be used</span>
00019 <span class="comment"> *    to endorse or promote products derived from this software without</span>
00020 <span class="comment"> *    specific prior written permission.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</span>
00023 <span class="comment"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00024 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00025 <span class="comment"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
00026 <span class="comment"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
00027 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
00028 <span class="comment"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
00029 <span class="comment"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00030 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00031 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00032 <span class="comment"> * SUCH DAMAGE.</span>
00033 <span class="comment"> */</span>
00034 
00035 <span class="preprocessor">#ifndef lint</span>
<a name="l00036"></a><a class="code" href="inet_8c.html#a2">00036</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a2">rcsid</a>[] =
00037     <span class="stringliteral">"@(#) $Header: /tcpdump/master/libpcap/inet.c,v 1.54 2002/12/22 02:36:48 guy Exp $ (LBL)"</span>;
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00042 <span class="preprocessor">#endif</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#ifdef WIN32</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pcap-stdinc.h&gt;</span>
00046 <span class="preprocessor">#else </span><span class="comment">/* WIN32 */</span>
00047 
00048 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00049 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>
00050 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
00051 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00052 <span class="preprocessor">#ifdef HAVE_SYS_SOCKIO_H</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/sockio.h&gt;</span>
00054 <span class="preprocessor">#endif</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>               <span class="comment">/* concession to AIX */</span>
00056 
00057 <span class="keyword">struct </span>mbuf;        <span class="comment">/* Squelch compiler warnings on some platforms for */</span>
00058 <span class="keyword">struct </span>rtentry;     <span class="comment">/* declarations in &lt;net/if.h&gt; */</span>
00059 <span class="preprocessor">#include &lt;net/if.h&gt;</span>
00060 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00061 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
00062 
00063 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00064 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00065 <span class="preprocessor">#include &lt;memory.h&gt;</span>
00066 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00067 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00068 <span class="preprocessor">#include &lt;string.h&gt;</span>
00069 <span class="preprocessor">#ifndef WIN32</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00071 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
00072 <span class="preprocessor">#ifdef HAVE_LIMITS_H</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#include &lt;limits.h&gt;</span>
00074 <span class="preprocessor">#else</span>
<a name="l00075"></a><a class="code" href="inet_8c.html#a0">00075</a> <span class="preprocessor"></span><span class="preprocessor">#define INT_MAX     2147483647</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IFADDRS_H</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ifaddrs.h&gt;</span>
00079 <span class="preprocessor">#endif</span>
00080 <span class="preprocessor"></span>
00081 <span class="preprocessor">#include "pcap-int.h"</span>
00082 
00083 <span class="preprocessor">#ifdef HAVE_OS_PROTO_H</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#include "os-proto.h"</span>
00085 <span class="preprocessor">#endif</span>
00086 <span class="preprocessor"></span>
00087 <span class="comment">/* Not all systems have IFF_LOOPBACK */</span>
00088 <span class="preprocessor">#ifdef IFF_LOOPBACK</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define ISLOOPBACK(name, flags) ((flags) &amp; IFF_LOOPBACK)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00091"></a><a class="code" href="inet_8c.html#a1">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define ISLOOPBACK(name, flags) ((name)[0] == 'l' &amp;&amp; (name)[1] == 'o' &amp;&amp; \</span>
00092 <span class="preprocessor">    (isdigit((unsigned char)((name)[2])) || (name)[2] == '\0'))</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00094 <span class="preprocessor"></span>
00095 <span class="keyword">struct </span>sockaddr *
<a name="l00096"></a><a class="code" href="inet_8c.html#a6">00096</a> <a class="code" href="inet_8c.html#a6">dup_sockaddr</a>(struct sockaddr *sa, size_t sa_length)
00097 {
00098     <span class="keyword">struct </span>sockaddr *newsa;
00099 
00100     <span class="keywordflow">if</span> ((newsa = malloc(sa_length)) == NULL)
00101         <span class="keywordflow">return</span> (NULL);
00102     <span class="keywordflow">return</span> (memcpy(newsa, sa, sa_length));
00103 }
00104 
00105 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00106"></a><a class="code" href="inet_8c.html#a7">00106</a> <a class="code" href="inet_8c.html#a7">get_instance</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00107 {
00108     <span class="keyword">const</span> <span class="keywordtype">char</span> *cp, *endcp;
00109     <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a>;
00110 
00111     <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">"any"</span>) == 0) {
00112         <span class="comment">/*</span>
00113 <span class="comment">         * Give the "any" device an artificially high instance</span>
00114 <span class="comment">         * number, so it shows up after all other non-loopback</span>
00115 <span class="comment">         * interfaces.</span>
00116 <span class="comment">         */</span>
00117         <span class="keywordflow">return</span> <a class="code" href="inet_8c.html#a0">INT_MAX</a>;
00118     }
00119 
00120     endcp = name + strlen(name);
00121     <span class="keywordflow">for</span> (cp = name; cp &lt; endcp &amp;&amp; !isdigit((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)*cp); ++cp)
00122         <span class="keywordflow">continue</span>;
00123 
00124     <span class="keywordflow">if</span> (isdigit((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)*cp))
00125         <a class="code" href="bpf__image_8c.html#a1">n</a> = atoi(cp);
00126     <span class="keywordflow">else</span>
00127         <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00128     <span class="keywordflow">return</span> (n);
00129 }
00130 
00131 <span class="keywordtype">int</span>
<a name="l00132"></a><a class="code" href="inet_8c.html#a8">00132</a> <a class="code" href="inet_8c.html#a8">add_or_find_if</a>(<a class="code" href="structpcap__if.html">pcap_if_t</a> **curdev_ret, <a class="code" href="structpcap__if.html">pcap_if_t</a> **alldevs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
00133     u_int flags, <span class="keyword">const</span> <span class="keywordtype">char</span> *description, <span class="keywordtype">char</span> *errbuf)
00134 {
00135     <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p;
00136     <a class="code" href="structpcap__if.html">pcap_if_t</a> *curdev, *prevdev, *nextdev;
00137     <span class="keywordtype">int</span> this_instance;
00138 
00139     <span class="comment">/*</span>
00140 <span class="comment">     * Can we open this interface for live capture?</span>
00141 <span class="comment">     */</span>
00142     p = <a class="code" href="Pcap-win32_8c.html#a7">pcap_open_live</a>(name, 68, 0, 0, errbuf);
00143     <span class="keywordflow">if</span> (p == NULL) {
00144         <span class="comment">/*</span>
00145 <span class="comment">         * No.  Don't bother including it.</span>
00146 <span class="comment">         * Don't treat this as an error, though.</span>
00147 <span class="comment">         */</span>
00148         *curdev_ret = NULL;
00149         <span class="keywordflow">return</span> (0);
00150     }
00151     <a class="code" href="pcap_8c.html#a30">pcap_close</a>(p);
00152 
00153     <span class="comment">/*</span>
00154 <span class="comment">     * Is there already an entry in the list for this interface?</span>
00155 <span class="comment">     */</span>
00156     <span class="keywordflow">for</span> (curdev = *alldevs; curdev != NULL; curdev = curdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a>) {
00157         <span class="keywordflow">if</span> (strcmp(name, curdev-&gt;<a class="code" href="structpcap__if.html#m1">name</a>) == 0)
00158             <span class="keywordflow">break</span>;  <span class="comment">/* yes, we found it */</span>
00159     }
00160     <span class="keywordflow">if</span> (curdev == NULL) {
00161         <span class="comment">/*</span>
00162 <span class="comment">         * No, we didn't find it.</span>
00163 <span class="comment">         * Allocate a new entry.</span>
00164 <span class="comment">         */</span>
00165         curdev = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpcap__if.html">pcap_if_t</a>));
00166         <span class="keywordflow">if</span> (curdev == NULL) {
00167             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00168                 <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00169             <span class="keywordflow">return</span> (-1);
00170         }
00171 
00172         <span class="comment">/*</span>
00173 <span class="comment">         * Fill in the entry.</span>
00174 <span class="comment">         */</span>
00175         curdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a> = NULL;
00176         curdev-&gt;<a class="code" href="structpcap__if.html#m1">name</a> = malloc(strlen(name) + 1);
00177         strcpy(curdev-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, name);
00178         <span class="keywordflow">if</span> (description != NULL) {
00179             <span class="comment">/*</span>
00180 <span class="comment">             * We have a description for this interface.</span>
00181 <span class="comment">             */</span>
00182             curdev-&gt;<a class="code" href="structpcap__if.html#m2">description</a> = malloc(strlen(description) + 1);
00183             strcpy(curdev-&gt;<a class="code" href="structpcap__if.html#m2">description</a>, description);
00184         } <span class="keywordflow">else</span> {
00185             <span class="comment">/*</span>
00186 <span class="comment">             * We don't.</span>
00187 <span class="comment">             */</span>
00188             curdev-&gt;<a class="code" href="structpcap__if.html#m2">description</a> = NULL;
00189         }
00190         curdev-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a> = NULL;   <span class="comment">/* list starts out as empty */</span>
00191         curdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> = 0;
00192         <span class="keywordflow">if</span> (<a class="code" href="inet_8c.html#a1">ISLOOPBACK</a>(name, flags))
00193             curdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> |= <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>;
00194 
00195         <span class="comment">/*</span>
00196 <span class="comment">         * Add it to the list, in the appropriate location.</span>
00197 <span class="comment">         * First, get the instance number of this interface.</span>
00198 <span class="comment">         */</span>
00199         this_instance = <a class="code" href="inet_8c.html#a7">get_instance</a>(name);
00200 
00201         <span class="comment">/*</span>
00202 <span class="comment">         * Now look for the last interface with an instance number</span>
00203 <span class="comment">         * less than or equal to the new interface's instance</span>
00204 <span class="comment">         * number - except that non-loopback interfaces are</span>
00205 <span class="comment">         * arbitrarily treated as having interface numbers less</span>
00206 <span class="comment">         * than those of loopback interfaces, so the loopback</span>
00207 <span class="comment">         * interfaces are put at the end of the list.</span>
00208 <span class="comment">         *</span>
00209 <span class="comment">         * We start with "prevdev" being NULL, meaning we're before</span>
00210 <span class="comment">         * the first element in the list.</span>
00211 <span class="comment">         */</span>
00212         prevdev = NULL;
00213         <span class="keywordflow">for</span> (;;) {
00214             <span class="comment">/*</span>
00215 <span class="comment">             * Get the interface after this one.</span>
00216 <span class="comment">             */</span>
00217             <span class="keywordflow">if</span> (prevdev == NULL) {
00218                 <span class="comment">/*</span>
00219 <span class="comment">                 * The next element is the first element.</span>
00220 <span class="comment">                 */</span>
00221                 nextdev = *alldevs;
00222             } <span class="keywordflow">else</span>
00223                 nextdev = prevdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a>;
00224 
00225             <span class="comment">/*</span>
00226 <span class="comment">             * Are we at the end of the list?</span>
00227 <span class="comment">             */</span>
00228             <span class="keywordflow">if</span> (nextdev == NULL) {
00229                 <span class="comment">/*</span>
00230 <span class="comment">                 * Yes - we have to put the new entry</span>
00231 <span class="comment">                 * after "prevdev".</span>
00232 <span class="comment">                 */</span>
00233                 <span class="keywordflow">break</span>;
00234             }
00235 
00236             <span class="comment">/*</span>
00237 <span class="comment">             * Is the new interface a non-loopback interface</span>
00238 <span class="comment">             * and the next interface a loopback interface?</span>
00239 <span class="comment">             */</span>
00240             <span class="keywordflow">if</span> (!(curdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> &amp; <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>) &amp;&amp;
00241                 (nextdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> &amp; <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>)) {
00242                 <span class="comment">/*</span>
00243 <span class="comment">                 * Yes, we should put the new entry</span>
00244 <span class="comment">                 * before "nextdev", i.e. after "prevdev".</span>
00245 <span class="comment">                 */</span>
00246                 <span class="keywordflow">break</span>;
00247             }
00248 
00249             <span class="comment">/*</span>
00250 <span class="comment">             * Is the new interface's instance number less</span>
00251 <span class="comment">             * than the next interface's instance number,</span>
00252 <span class="comment">             * and is it the case that the new interface is a</span>
00253 <span class="comment">             * non-loopback interface or the next interface is</span>
00254 <span class="comment">             * a loopback interface?</span>
00255 <span class="comment">             *</span>
00256 <span class="comment">             * (The goal of both loopback tests is to make</span>
00257 <span class="comment">             * sure that we never put a loopback interface</span>
00258 <span class="comment">             * before any non-loopback interface and that we</span>
00259 <span class="comment">             * always put a non-loopback interface before all</span>
00260 <span class="comment">             * loopback interfaces.)</span>
00261 <span class="comment">             */</span>
00262             <span class="keywordflow">if</span> (this_instance &lt; <a class="code" href="inet_8c.html#a7">get_instance</a>(nextdev-&gt;<a class="code" href="structpcap__if.html#m1">name</a>) &amp;&amp;
00263                 (!(curdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> &amp; <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>) ||
00264                    (nextdev-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> &amp; <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>))) {
00265                 <span class="comment">/*</span>
00266 <span class="comment">                 * Yes - we should put the new entry</span>
00267 <span class="comment">                 * before "nextdev", i.e. after "prevdev".</span>
00268 <span class="comment">                 */</span>
00269                 <span class="keywordflow">break</span>;
00270             }
00271 
00272             prevdev = nextdev;
00273         }
00274 
00275         <span class="comment">/*</span>
00276 <span class="comment">         * Insert before "nextdev".</span>
00277 <span class="comment">         */</span>
00278         curdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a> = nextdev;
00279 
00280         <span class="comment">/*</span>
00281 <span class="comment">         * Insert after "prevdev" - unless "prevdev" is null,</span>
00282 <span class="comment">         * in which case this is the first interface.</span>
00283 <span class="comment">         */</span>
00284         <span class="keywordflow">if</span> (prevdev == NULL) {
00285             <span class="comment">/*</span>
00286 <span class="comment">             * This is the first interface.  Pass back a</span>
00287 <span class="comment">             * pointer to it, and put "curdev" before</span>
00288 <span class="comment">             * "nextdev".</span>
00289 <span class="comment">             */</span>
00290             *alldevs = curdev;
00291         } <span class="keywordflow">else</span>
00292             prevdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a> = curdev;
00293     }
00294 
00295     *curdev_ret = curdev;
00296     <span class="keywordflow">return</span> (0);
00297 }
00298 
00299 <span class="keywordtype">int</span>
<a name="l00300"></a><a class="code" href="inet_8c.html#a9">00300</a> <a class="code" href="inet_8c.html#a9">add_addr_to_iflist</a>(<a class="code" href="structpcap__if.html">pcap_if_t</a> **alldevs, <span class="keywordtype">char</span> *name, u_int flags,
00301     <span class="keyword">struct</span> sockaddr *addr, size_t addr_size,
00302     <span class="keyword">struct</span> sockaddr *netmask, size_t netmask_size,
00303     <span class="keyword">struct</span> sockaddr *broadaddr, size_t broadaddr_size,
00304     <span class="keyword">struct</span> sockaddr *dstaddr, size_t dstaddr_size,
00305     <span class="keywordtype">char</span> *errbuf)
00306 {
00307     <a class="code" href="structpcap__if.html">pcap_if_t</a> *curdev;
00308     <a class="code" href="structpcap__addr.html">pcap_addr_t</a> *curaddr, *prevaddr, *nextaddr;
00309 
00310     <span class="keywordflow">if</span> (<a class="code" href="inet_8c.html#a8">add_or_find_if</a>(&amp;curdev, alldevs, name, flags, NULL, errbuf) == -1) {
00311         <span class="comment">/*</span>
00312 <span class="comment">         * Error - give up.</span>
00313 <span class="comment">         */</span>
00314         <span class="keywordflow">return</span> (-1);
00315     }
00316     <span class="keywordflow">if</span> (curdev == NULL) {
00317         <span class="comment">/*</span>
00318 <span class="comment">         * Device wasn't added because it can't be opened.</span>
00319 <span class="comment">         * Not a fatal error.</span>
00320 <span class="comment">         */</span>
00321         <span class="keywordflow">return</span> (0);
00322     }
00323 
00324     <span class="comment">/*</span>
00325 <span class="comment">     * "curdev" is an entry for this interface; add an entry for this</span>
00326 <span class="comment">     * address to its list of addresses.</span>
00327 <span class="comment">     *</span>
00328 <span class="comment">     * Allocate the new entry and fill it in.</span>
00329 <span class="comment">     */</span>
00330     curaddr = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpcap__addr.html">pcap_addr_t</a>));
00331     <span class="keywordflow">if</span> (curaddr == NULL) {
00332         (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00333             <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00334         <span class="keywordflow">return</span> (-1);
00335     }
00336 
00337     curaddr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a> = NULL;
00338     <span class="keywordflow">if</span> (addr != NULL) {
00339         curaddr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a> = <a class="code" href="inet_8c.html#a6">dup_sockaddr</a>(addr, addr_size);
00340         <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a> == NULL) {
00341             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00342                 <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00343             free(curaddr);
00344             <span class="keywordflow">return</span> (-1);
00345         }
00346     } <span class="keywordflow">else</span>
00347         curaddr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a> = NULL;
00348 
00349     <span class="keywordflow">if</span> (netmask != NULL) {
00350         curaddr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a> = <a class="code" href="inet_8c.html#a6">dup_sockaddr</a>(netmask, netmask_size);
00351         <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a> == NULL) {
00352             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00353                 <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00354             free(curaddr);
00355             <span class="keywordflow">return</span> (-1);
00356         }
00357     } <span class="keywordflow">else</span>
00358         curaddr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a> = NULL;
00359 
00360     <span class="keywordflow">if</span> (broadaddr != NULL) {
00361         curaddr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a> = <a class="code" href="inet_8c.html#a6">dup_sockaddr</a>(broadaddr, broadaddr_size);
00362         <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a> == NULL) {
00363             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00364                 <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00365             free(curaddr);
00366             <span class="keywordflow">return</span> (-1);
00367         }
00368     } <span class="keywordflow">else</span>
00369         curaddr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a> = NULL;
00370 
00371     <span class="keywordflow">if</span> (dstaddr != NULL) {
00372         curaddr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a> = <a class="code" href="inet_8c.html#a6">dup_sockaddr</a>(dstaddr, dstaddr_size);
00373         <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a> == NULL) {
00374             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00375                 <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00376             free(curaddr);
00377             <span class="keywordflow">return</span> (-1);
00378         }
00379     } <span class="keywordflow">else</span>
00380         curaddr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a> = NULL;
00381 
00382     <span class="comment">/*</span>
00383 <span class="comment">     * Find the end of the list of addresses.</span>
00384 <span class="comment">     */</span>
00385     <span class="keywordflow">for</span> (prevaddr = curdev-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a>; prevaddr != NULL; prevaddr = nextaddr) {
00386         nextaddr = prevaddr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a>;
00387         <span class="keywordflow">if</span> (nextaddr == NULL) {
00388             <span class="comment">/*</span>
00389 <span class="comment">             * This is the end of the list.</span>
00390 <span class="comment">             */</span>
00391             <span class="keywordflow">break</span>;
00392         }
00393     }
00394 
00395     <span class="keywordflow">if</span> (prevaddr == NULL) {
00396         <span class="comment">/*</span>
00397 <span class="comment">         * The list was empty; this is the first member.</span>
00398 <span class="comment">         */</span>
00399         curdev-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a> = curaddr;
00400     } <span class="keywordflow">else</span> {
00401         <span class="comment">/*</span>
00402 <span class="comment">         * "prevaddr" is the last member of the list; append</span>
00403 <span class="comment">         * this member to it.</span>
00404 <span class="comment">         */</span>
00405         prevaddr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a> = curaddr;
00406     }
00407 
00408     <span class="keywordflow">return</span> (0);
00409 }
00410 
00411 <span class="keywordtype">int</span>
<a name="l00412"></a><a class="code" href="inet_8c.html#a10">00412</a> <a class="code" href="inet_8c.html#a10">pcap_add_if</a>(<a class="code" href="structpcap__if.html">pcap_if_t</a> **devlist, <span class="keywordtype">char</span> *name, u_int flags,
00413     <span class="keyword">const</span> <span class="keywordtype">char</span> *description, <span class="keywordtype">char</span> *errbuf)
00414 {
00415     <a class="code" href="structpcap__if.html">pcap_if_t</a> *curdev;
00416 
00417     <span class="keywordflow">return</span> (<a class="code" href="inet_8c.html#a8">add_or_find_if</a>(&amp;curdev, devlist, name, flags, description,
00418         errbuf));
00419 }
00420 
00421 
00422 <span class="comment">/*</span>
00423 <span class="comment"> * Free a list of interfaces.</span>
00424 <span class="comment"> */</span>
00425 <span class="keywordtype">void</span>
<a name="l00426"></a><a class="code" href="inet_8c.html#a11">00426</a> <a class="code" href="inet_8c.html#a11">pcap_freealldevs</a>(<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs)
00427 {
00428     <a class="code" href="structpcap__if.html">pcap_if_t</a> *curdev, *nextdev;
00429     <a class="code" href="structpcap__addr.html">pcap_addr_t</a> *curaddr, *nextaddr;
00430 
00431     <span class="keywordflow">for</span> (curdev = alldevs; curdev != NULL; curdev = nextdev) {
00432         nextdev = curdev-&gt;<a class="code" href="structpcap__if.html#m0">next</a>;
00433 
00434         <span class="comment">/*</span>
00435 <span class="comment">         * Free all addresses.</span>
00436 <span class="comment">         */</span>
00437         <span class="keywordflow">for</span> (curaddr = curdev-&gt;<a class="code" href="structpcap__if.html#m3">addresses</a>; curaddr != NULL; curaddr = nextaddr) {
00438             nextaddr = curaddr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a>;
00439             <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a>)
00440                 free(curaddr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a>);
00441             <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a>)
00442                 free(curaddr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a>);
00443             <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a>)
00444                 free(curaddr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a>);
00445             <span class="keywordflow">if</span> (curaddr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a>)
00446                 free(curaddr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a>);
00447             free(curaddr);
00448         }
00449 
00450         <span class="comment">/*</span>
00451 <span class="comment">         * Free the name string.</span>
00452 <span class="comment">         */</span>
00453         free(curdev-&gt;<a class="code" href="structpcap__if.html#m1">name</a>);
00454 
00455         <span class="comment">/*</span>
00456 <span class="comment">         * Free the description string, if any.</span>
00457 <span class="comment">         */</span>
00458         <span class="keywordflow">if</span> (curdev-&gt;<a class="code" href="structpcap__if.html#m2">description</a> != NULL)
00459             free(curdev-&gt;<a class="code" href="structpcap__if.html#m2">description</a>);
00460 
00461         <span class="comment">/*</span>
00462 <span class="comment">         * Free the interface.</span>
00463 <span class="comment">         */</span>
00464         free(curdev);
00465     }
00466 }
00467 
00468 <span class="preprocessor">#ifndef WIN32</span>
00469 <span class="preprocessor"></span>
00470 <span class="comment">/*</span>
00471 <span class="comment"> * Return the name of a network interface attached to the system, or NULL</span>
00472 <span class="comment"> * if none can be found.  The interface must be configured up; the</span>
00473 <span class="comment"> * lowest unit number is preferred; loopback is ignored.</span>
00474 <span class="comment"> */</span>
00475 <span class="keywordtype">char</span> *
00476 <a class="code" href="inet_8c.html#a12">pcap_lookupdev</a>(errbuf)
00477     <span class="keyword">register</span> <span class="keywordtype">char</span> *<a class="code" href="inet_8c.html#a5">errbuf</a>;
00478 {
00479     <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
00480 <span class="comment">/* for old BSD systems, including bsdi3 */</span>
00481 <span class="preprocessor">#ifndef IF_NAMESIZE</span>
00482 <span class="preprocessor"></span><span class="preprocessor">#define IF_NAMESIZE IFNAMSIZ</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00484 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">char</span> device[IF_NAMESIZE + 1];
00485     <span class="keywordtype">char</span> *ret;
00486 
00487     <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
00488         <span class="keywordflow">return</span> (NULL);
00489 
00490     <span class="keywordflow">if</span> (alldevs == NULL || (alldevs-&gt;<a class="code" href="structpcap__if.html#m4">flags</a> &amp; <a class="code" href="group__wpcap__def.html#a9">PCAP_IF_LOOPBACK</a>)) {
00491         <span class="comment">/*</span>
00492 <span class="comment">         * There are no devices on the list, or the first device</span>
00493 <span class="comment">         * on the list is a loopback device, which means there</span>
00494 <span class="comment">         * are no non-loopback devices on the list.  This means</span>
00495 <span class="comment">         * we can't return any device.</span>
00496 <span class="comment">         *</span>
00497 <span class="comment">         * XXX - why not return a loopback device?  If we can't</span>
00498 <span class="comment">         * capture on it, it won't be on the list, and if it's</span>
00499 <span class="comment">         * on the list, there aren't any non-loopback devices,</span>
00500 <span class="comment">         * so why not just supply it as the default device?</span>
00501 <span class="comment">         */</span>
00502         (void)strlcpy(errbuf, <span class="stringliteral">"no suitable device found"</span>,
00503             PCAP_ERRBUF_SIZE);
00504         ret = NULL;
00505     } <span class="keywordflow">else</span> {
00506         <span class="comment">/*</span>
00507 <span class="comment">         * Return the name of the first device on the list.</span>
00508 <span class="comment">         */</span>
00509         (void)strlcpy(device, alldevs-&gt;<a class="code" href="structpcap__if.html#m1">name</a>, <span class="keyword">sizeof</span>(device));
00510         ret = device;
00511     }
00512 
00513     <a class="code" href="inet_8c.html#a11">pcap_freealldevs</a>(alldevs);
00514     <span class="keywordflow">return</span> (ret);
00515 }
00516 
00517 <span class="keywordtype">int</span>
00518 <a class="code" href="group__wpcap__fn.html#a10">pcap_lookupnet</a>(device, netp, maskp, errbuf)
00519     <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *device;
00520     <span class="keyword">register</span> <a class="code" href="group__wpcap__def.html#a1">bpf_u_int32</a> *<a class="code" href="inet_8c.html#a3">netp</a>, *<a class="code" href="inet_8c.html#a4">maskp</a>;
00521     <span class="keyword">register</span> <span class="keywordtype">char</span> *<a class="code" href="inet_8c.html#a5">errbuf</a>;
00522 {
00523     <span class="keyword">register</span> <span class="keywordtype">int</span> fd;
00524     <span class="keyword">register</span> <span class="keyword">struct </span>sockaddr_in *sin;
00525     <span class="keyword">struct </span>ifreq ifr;
00526 
00527     <span class="comment">/*</span>
00528 <span class="comment">     * The pseudo-device "any" listens on all interfaces and therefore</span>
00529 <span class="comment">     * has the network address and -mask "0.0.0.0" therefore catching</span>
00530 <span class="comment">     * all traffic. Using NULL for the interface is the same as "any".</span>
00531 <span class="comment">     */</span>
00532     <span class="keywordflow">if</span> (!device || strcmp(device, <span class="stringliteral">"any"</span>) == 0) {
00533         *<a class="code" href="inet_8c.html#a3">netp</a> = *<a class="code" href="inet_8c.html#a4">maskp</a> = 0;
00534         <span class="keywordflow">return</span> 0;
00535     }
00536 
00537     fd = socket(AF_INET, SOCK_DGRAM, 0);
00538     <span class="keywordflow">if</span> (fd &lt; 0) {
00539         (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"socket: %s"</span>,
00540             <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00541         <span class="keywordflow">return</span> (-1);
00542     }
00543     memset(&amp;ifr, 0, <span class="keyword">sizeof</span>(ifr));
00544 <span class="preprocessor">#ifdef linux</span>
00545 <span class="preprocessor"></span>    <span class="comment">/* XXX Work around Linux kernel bug */</span>
00546     ifr.ifr_addr.sa_family = AF_INET;
00547 <span class="preprocessor">#endif</span>
00548 <span class="preprocessor"></span>    (void)strncpy(ifr.ifr_name, device, <span class="keyword">sizeof</span>(ifr.ifr_name));
00549     <span class="keywordflow">if</span> (ioctl(fd, SIOCGIFADDR, (<span class="keywordtype">char</span> *)&amp;ifr) &lt; 0) {
00550         <span class="keywordflow">if</span> (errno == EADDRNOTAVAIL) {
00551             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00552                 <span class="stringliteral">"%s: no IPv4 address assigned"</span>, device);
00553         } <span class="keywordflow">else</span> {
00554             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00555                 <span class="stringliteral">"SIOCGIFADDR: %s: %s"</span>,
00556                 device, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00557         }
00558         (void)close(fd);
00559         <span class="keywordflow">return</span> (-1);
00560     }
00561     sin = (<span class="keyword">struct </span>sockaddr_in *)&amp;ifr.ifr_addr;
00562     *<a class="code" href="inet_8c.html#a3">netp</a> = sin-&gt;sin_addr.s_addr;
00563     <span class="keywordflow">if</span> (ioctl(fd, SIOCGIFNETMASK, (<span class="keywordtype">char</span> *)&amp;ifr) &lt; 0) {
00564         (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00565             <span class="stringliteral">"SIOCGIFNETMASK: %s: %s"</span>, device, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00566         (void)close(fd);
00567         <span class="keywordflow">return</span> (-1);
00568     }
00569     (void)close(fd);
00570     *<a class="code" href="inet_8c.html#a4">maskp</a> = sin-&gt;sin_addr.s_addr;
00571     <span class="keywordflow">if</span> (*<a class="code" href="inet_8c.html#a4">maskp</a> == 0) {
00572         <span class="keywordflow">if</span> (IN_CLASSA(*netp))
00573             *<a class="code" href="inet_8c.html#a4">maskp</a> = IN_CLASSA_NET;
00574         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IN_CLASSB(*netp))
00575             *<a class="code" href="inet_8c.html#a4">maskp</a> = IN_CLASSB_NET;
00576         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IN_CLASSC(*netp))
00577             *<a class="code" href="inet_8c.html#a4">maskp</a> = IN_CLASSC_NET;
00578         <span class="keywordflow">else</span> {
00579             (void)<a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00580                 <span class="stringliteral">"inet class for 0x%x unknown"</span>, *netp);
00581             <span class="keywordflow">return</span> (-1);
00582         }
00583     }
00584     *<a class="code" href="inet_8c.html#a3">netp</a> &amp;= *<a class="code" href="inet_8c.html#a4">maskp</a>;
00585     <span class="keywordflow">return</span> (0);
00586 }
00587 
00588 <span class="preprocessor">#else </span><span class="comment">/* WIN32 */</span>
00589 
00590 <span class="comment">/*</span>
00591 <span class="comment"> * Return the name of a network interface attached to the system, or NULL</span>
00592 <span class="comment"> * if none can be found.  The interface must be configured up; the</span>
00593 <span class="comment"> * lowest unit number is preferred; loopback is ignored.</span>
00594 <span class="comment"> */</span>
00595 <span class="keywordtype">char</span> *
00596 <a class="code" href="inet_8c.html#a12">pcap_lookupdev</a>(errbuf)
00597     <span class="keyword">register</span> <span class="keywordtype">char</span> *<a class="code" href="inet_8c.html#a5">errbuf</a>;
00598 {
00599     DWORD dwVersion;
00600     DWORD dwWindowsMajorVersion;
00601     dwVersion = GetVersion();   <span class="comment">/* get the OS version */</span>
00602     dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
00603     
00604     <span class="keywordflow">if</span> (dwVersion &gt;= 0x80000000 &amp;&amp; dwWindowsMajorVersion &gt;= 4) {
00605         <span class="comment">/*</span>
00606 <span class="comment">         * Windows 95, 98, ME.</span>
00607 <span class="comment">         */</span>
00608         ULONG NameLength = 8192;
00609         <span class="keyword">static</span> <span class="keywordtype">char</span> AdaptersName[8192];
00610         
00611         <a class="code" href="Packet32_8c.html#a43">PacketGetAdapterNames</a>(AdaptersName,&amp;NameLength);
00612         
00613         <span class="keywordflow">return</span> (AdaptersName);
00614     } <span class="keywordflow">else</span> {
00615         <span class="comment">/*</span>
00616 <span class="comment">         * Windows NT (NT 4.0, W2K, WXP).</span>
00617 <span class="comment">         */</span>
00618         ULONG NameLength = 8192;
00619         <span class="keyword">static</span> WCHAR AdaptersName[8192];
00620         
00621         <a class="code" href="Packet32_8c.html#a43">PacketGetAdapterNames</a>((PTSTR)AdaptersName,&amp;NameLength);
00622         
00623         <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *)(AdaptersName);
00624     }   
00625 }
00626 
00627 
00628 <span class="keywordtype">int</span>
00629 <a class="code" href="group__wpcap__fn.html#a10">pcap_lookupnet</a>(device, netp, maskp, errbuf)
00630     <span class="keyword">register</span> <span class="keywordtype">char</span> *device;
<a name="l00631"></a><a class="code" href="inet_8c.html#a3">00631</a>     <span class="keyword">register</span> <a class="code" href="group__wpcap__def.html#a1">bpf_u_int32</a> *<a class="code" href="inet_8c.html#a3">netp</a>, *<a class="code" href="inet_8c.html#a4">maskp</a>;
<a name="l00632"></a><a class="code" href="inet_8c.html#a5">00632</a>     <span class="keyword">register</span> <span class="keywordtype">char</span> *<a class="code" href="inet_8c.html#a5">errbuf</a>;
00633 {
00634     <span class="comment">/* </span>
00635 <span class="comment">     * We need only the first address, so we allocate a single</span>
00636 <span class="comment">     * npf_if_addr structure and we set if_addr_size to 1.</span>
00637 <span class="comment">     */</span>
00638     <a class="code" href="structnpf__if__addr.html">npf_if_addr</a> if_addrs;
00639     LONG if_addr_size = 1;
00640     <span class="keyword">struct </span>sockaddr_in *t_addr;
00641 
00642     <span class="keywordflow">if</span> (!<a class="code" href="Packet32_8c.html#a44">PacketGetNetInfoEx</a>((<span class="keywordtype">void</span> *)device, &amp;if_addrs, &amp;if_addr_size)) {
00643         *<a class="code" href="inet_8c.html#a3">netp</a> = *<a class="code" href="inet_8c.html#a4">maskp</a> = 0;
00644         <span class="keywordflow">return</span> (0);
00645     }
00646 
00647     t_addr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(if_addrs.IPAddress);
00648     *<a class="code" href="inet_8c.html#a3">netp</a> = t_addr-&gt;sin_addr.S_un.S_addr;
00649     t_addr = (<span class="keyword">struct </span>sockaddr_in *) &amp;(if_addrs.SubnetMask);
00650     *<a class="code" href="inet_8c.html#a4">maskp</a> = t_addr-&gt;sin_addr.S_un.S_addr;
00651 
00652     <span class="comment">/*</span>
00653 <span class="comment">     * XXX - will we ever get back a 0 netmask?</span>
00654 <span class="comment">     * If so, we should presumably make the "if (*maskp == 0)" code</span>
00655 <span class="comment">     * above common, rather than non-Win32-specific.</span>
00656 <span class="comment">     */</span>
00657 
00658     *<a class="code" href="inet_8c.html#a3">netp</a> &amp;= *<a class="code" href="inet_8c.html#a4">maskp</a>;
00659     <span class="keywordflow">return</span> (0);
00660 }
00661 
00662 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
