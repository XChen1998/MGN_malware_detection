<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pcap-new.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pcap-new.c</h1><a href="pcap-new_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2002 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 <span class="preprocessor">#include &lt;pcap-int.h&gt;</span>   <span class="comment">// for the details of the pcap_t structure</span>
00034 <span class="preprocessor">#include &lt;<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>&gt;</span>
00035 <span class="preprocessor">#include &lt;<a class="code" href="sockutils_8h.html">sockutils.h</a>&gt;</span>
00036 <span class="preprocessor">#include &lt;errno.h&gt;</span>  <span class="comment">// for the errno variable</span>
00037 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>     <span class="comment">// for malloc(), free(), ...</span>
00038 <span class="preprocessor">#include &lt;string.h&gt;</span>     <span class="comment">// for strstr, etc</span>
00039 
00040 
00041 
00042 <span class="comment">/*</span>
00043 <span class="comment">    \brief Global variable; needed to keep the message due to an error that we want to discard.</span>
00044 <span class="comment">    </span>
00045 <span class="comment">    This can happen, for instance, because we already have an error message and we want to keep </span>
00046 <span class="comment">    the first one.</span>
00047 <span class="comment">*/</span>
<a name="l00048"></a><a class="code" href="pcap-new_8c.html#a0">00048</a> <span class="keywordtype">char</span> <a class="code" href="sockutils_8c.html#a6">fakeerrbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];
00049 
00050 
<a name="l00052"></a><a class="code" href="pcap-new_8c.html#a1">00052</a> <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *<a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
00053 
00054 
<a name="l00060"></a><a class="code" href="pcap-new_8c.html#a2">00060</a> <a class="code" href="group__remote__struct.html#a12">SOCKET</a> <a class="code" href="pcap-new_8c.html#a2">sockmain</a>;
00061 
00062 
00063 
00064 
00065 
00066 
00067 <span class="comment">/****************************************************</span>
00068 <span class="comment"> *                                                  *</span>
00069 <span class="comment"> * Function bodies                                  *</span>
00070 <span class="comment"> *                                                  *</span>
00071 <span class="comment"> ****************************************************/</span>
00072 
00073 
<a name="l00150"></a><a class="code" href="pcap-new_8c.html#a3">00150</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a3">pcap_findalldevs_ex</a>(<span class="keywordtype">char</span> *host, <span class="keywordtype">char</span> *port, SOCKET sockctrl, <span class="keyword">struct</span> <a class="code" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <a class="code" href="structpcap__if.html">pcap_if_t</a> **alldevs, <span class="keywordtype">char</span> *errbuf) 
00151 {
00152 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread= 0;      <span class="comment">// number of bytes of the payload read from the socket</span>
00153 <span class="keyword">struct </span>addrinfo hints;      <span class="comment">// temp variable needed to resove hostnames into to socket representation</span>
00154 <span class="keyword">struct </span>addrinfo *addrinfo;  <span class="comment">// temp variable needed to resove hostnames into to socket representation</span>
00155 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header; <span class="comment">// structure that keeps the general header of the rpcap protocol</span>
00156 <span class="keywordtype">int</span> i,j;        <span class="comment">// temp variables</span>
00157 <span class="keywordtype">int</span> naddr;      <span class="comment">// temp var needed to avoid problems with IPv6 addresses</span>
00158 <span class="keywordtype">int</span> retval;     <span class="comment">// store the return value of the functions</span>
00159 <span class="keywordtype">int</span> nif;        <span class="comment">// Number of interfaces listed</span>
00160 <span class="keywordtype">int</span> active= 0;  <span class="comment">// 'true' if we the other end-party is in active mode</span>
00161 
00162 
00163     <span class="comment">// We have to perform two controls here, because the user can call this function in two ways:</span>
00164     <span class="comment">//   pcap_findalldevs_ex(NULL, ...) ==&gt; address == NULL</span>
00165     <span class="comment">//   pcap_findalldevs_ex("", ...) ==&gt; address[0] == 0</span>
00166     <span class="keywordflow">if</span> ( (<a class="code" href="wpcap__remote_8htm.html#a3">host</a> == NULL) || (<a class="code" href="wpcap__remote_8htm.html#a3">host</a>[0] == 0) )
00167     {
00168         <span class="comment">// The user wants to retrieve adapters from a local host</span>
00169         <span class="keywordflow">if</span> (<a class="code" href="group__wpcap__fn.html#a7">pcap_findalldevs</a>(alldevs, errbuf) == -1)
00170             <span class="keywordflow">return</span> -1;
00171         <span class="keywordflow">if</span> ( (alldevs == NULL) || (*alldevs == NULL) )
00172         {
00173             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00174                 <span class="stringliteral">"No interfaces found! Make sure libpcap/WinPcap is properly installed"</span>
00175                 <span class="stringliteral">" on the local machine."</span>);
00176             <span class="keywordflow">return</span> -1;
00177         }
00178         <span class="keywordflow">return</span> 0;
00179     }
00180 
00181     <span class="comment">// Warning: this call can be the first one called by the user.</span>
00182     <span class="comment">// For this reason, we have to initialize the WinSock support.</span>
00183     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a9">sock_init</a>(errbuf) == -1)
00184         <span class="keywordflow">return</span> -1;
00185 
00186     <span class="comment">// Check for active mode</span>
00187     <span class="keywordflow">if</span> ( (retval= <a class="code" href="pcap-remote_8c.html#a24">rpcap_remoteact_getsock</a>(host, errbuf)) == -1)
00188         <span class="keywordflow">return</span> -1;
00189 
00190     <span class="keywordflow">if</span> (retval)
00191     {
00192         sockctrl= retval;
00193         active= 1;
00194     }
00195     <span class="keywordflow">else</span>    <span class="comment">// we're not in active mode; let's opening a new control connection (if needed)</span>
00196     {
00197         addrinfo= NULL;
00198 
00199         memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo) );
00200         hints.ai_family = PF_UNSPEC;
00201         hints.ai_socktype = SOCK_STREAM;
00202 
00203         <span class="keywordflow">if</span> ( (<a class="code" href="rpcapd_8c.html#a8">port</a> == NULL) || (<a class="code" href="rpcapd_8c.html#a8">port</a>[0] == 0) )
00204         {
00205             <span class="comment">// the user chose not to specify the port</span>
00206             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(host, RPCAP_DEFAULT_NETPORT, &amp;hints, &amp;addrinfo, errbuf) == -1)
00207                 <span class="keywordflow">return</span> -1;
00208         }
00209         <span class="keywordflow">else</span>
00210         {
00211             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(host, port, &amp;hints, &amp;addrinfo, errbuf) == -1)
00212                 <span class="keywordflow">return</span> -1;
00213         }
00214 
00215         <span class="keywordflow">if</span> ( (sockctrl= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_CLIENT, 0, errbuf)) == -1)
00216             <span class="keywordflow">goto</span> error;
00217 
00218         <span class="comment">// addrinfo is no longer used</span>
00219         freeaddrinfo(addrinfo);
00220         addrinfo= NULL;
00221 
00222         <span class="keywordflow">if</span> ( <a class="code" href="pcap-remote_8c.html#a21">rpcap_sendauth</a>(sockctrl, auth, errbuf) == -1)
00223         {
00224             <span class="comment">// Control connection has to be closed only in case the remote machine is in passive mode</span>
00225             <span class="keywordflow">if</span> (!active)
00226                 <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
00227             <span class="keywordflow">return</span> -1;
00228         }
00229     }
00230 
00231     <span class="comment">// RPCAP findalldevs command</span>
00232     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>(&amp;header, RPCAP_MSG_FINDALLIF_REQ, 0, 0);
00233 
00234     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf) == -1 )
00235         <span class="keywordflow">goto</span> error;
00236 
00237     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), errbuf) == -1)
00238         <span class="keywordflow">goto</span> error;
00239 
00240     <span class="comment">// Checks if the message is correct</span>
00241     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, sockctrl, &amp;header, RPCAP_MSG_FINDALLIF_REPLY, RPCAP_MSG_ERROR, 0);
00242 
00243     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a24">RPCAP_MSG_FINDALLIF_REPLY</a>)        <span class="comment">// the message is not the one expected</span>
00244     {
00245         <span class="keywordflow">switch</span> (retval)
00246         {
00247             <span class="keywordflow">case</span> -3:    <span class="comment">// Unrecoverable network error</span>
00248             <span class="keywordflow">case</span> -2:    <span class="comment">// The other endpoint send a message that is not allowed here</span>
00249             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00250                 <span class="keywordflow">break</span>;
00251 
00252             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:       <span class="comment">// The other endpoint reported an error</span>
00253                 <span class="keywordflow">break</span>;
00254 
00255             <span class="keywordflow">default</span>:
00256             {
00257                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Internal error"</span>);
00258                 <span class="keywordflow">break</span>;
00259             };
00260         }
00261 
00262         <span class="keywordflow">if</span> (!active)
00263             <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
00264 
00265         <span class="keywordflow">return</span> -1;
00266     }
00267 
00268     <span class="comment">// read the number of interfaces</span>
00269     nif= ntohs(header.value);
00270 
00271     <span class="comment">// loop until all interfaces have been received</span>
00272     <span class="keywordflow">for</span> (i= 0; i &lt; nif; i++)
00273     {
00274     <span class="keyword">struct </span><a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a> findalldevs_if;
00275     <a class="code" href="structpcap__if.html">pcap_if_t</a> *dev;     <span class="comment">// Previous device into the pcap_if_t chain</span>
00276 
00277         <span class="comment">// receive the findalldevs structure from remote hsot</span>
00278         <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;findalldevs_if, 
00279             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__findalldevs__if.html">rpcap_findalldevs_if</a>), errbuf) ) == -1)
00280             <span class="keywordflow">goto</span> error;
00281 
00282         findalldevs_if.<a class="code" href="structrpcap__findalldevs__if.html#m0">namelen</a>= ntohs(findalldevs_if.namelen);
00283         findalldevs_if.desclen= ntohs(findalldevs_if.desclen);
00284         findalldevs_if.naddr= ntohs(findalldevs_if.naddr);
00285 
00286         <span class="comment">// allocate the main structure</span>
00287         <span class="keywordflow">if</span> (i == 0)
00288         {
00289             (*alldevs)= (<a class="code" href="structpcap__if.html">pcap_if_t</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpcap__if.html">pcap_if_t</a>) );
00290             dev= (*alldevs);
00291         }
00292         <span class="keywordflow">else</span>
00293         {
00294             dev-&gt;next= (<a class="code" href="structpcap__if.html">pcap_if_t</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpcap__if.html">pcap_if_t</a>) );
00295             dev= dev-&gt;next;
00296         }
00297 
00298         <span class="comment">// check that the malloc() didn't fail</span>
00299         <span class="keywordflow">if</span> (dev == NULL)
00300         {
00301             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00302             <span class="keywordflow">goto</span> error;
00303         }
00304         dev-&gt;next= NULL;
00305         dev-&gt;addresses= NULL;
00306 
00307         <span class="comment">// allocate mem for name and description</span>
00308         <span class="keywordflow">if</span> (findalldevs_if.namelen)
00309         {
00310             dev-&gt;name= (<span class="keywordtype">char</span> *) malloc(findalldevs_if.namelen + 1);
00311             <span class="keywordflow">if</span> (dev-&gt;name == NULL)
00312             {
00313                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00314                 <span class="keywordflow">goto</span> error;
00315             }
00316             <span class="comment">// Retrieve adapter name and description</span>
00317             <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, dev-&gt;name, findalldevs_if.namelen, errbuf) ) == -1)
00318                 <span class="keywordflow">goto</span> error;
00319             dev-&gt;name[findalldevs_if.namelen]= 0;
00320         }
00321         <span class="keywordflow">else</span>
00322             dev-&gt;name= NULL;
00323 
00324         <span class="keywordflow">if</span> (findalldevs_if.desclen)
00325         {
00326             dev-&gt;description= (<span class="keywordtype">char</span> *) malloc(findalldevs_if.desclen + 1);
00327             <span class="keywordflow">if</span> (dev-&gt;description == NULL)
00328             {
00329                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00330                 <span class="keywordflow">goto</span> error;
00331             }
00332             <span class="comment">// Retrieve adapter name and description</span>
00333             <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, dev-&gt;description, findalldevs_if.desclen, errbuf) ) == -1)
00334                 <span class="keywordflow">goto</span> error;
00335             dev-&gt;description[findalldevs_if.desclen]= 0;
00336         }
00337         <span class="keywordflow">else</span>
00338             dev-&gt;description= NULL;
00339 
00340         dev-&gt;flags= ntohl(findalldevs_if.flags);
00341 
00342         naddr= 0;
00343         <span class="comment">// loop until all addresses have been received</span>
00344         <span class="keywordflow">for</span> (j= 0; j &lt; findalldevs_if.naddr; j++)
00345         {
00346         <span class="keyword">struct </span><a class="code" href="structrpcap__findalldevs__ifaddr.html">rpcap_findalldevs_ifaddr</a> ifaddr;
00347 
00348             <span class="comment">// Retrieve the interface addresses</span>
00349             <span class="keywordflow">if</span> (  (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;ifaddr, 
00350                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__findalldevs__ifaddr.html">rpcap_findalldevs_ifaddr</a>), errbuf) ) == -1)
00351                 <span class="keywordflow">goto</span> error;
00352 
00353             <span class="comment">// WARNING libpcap bug: the address listing is available only for AF_INET</span>
00354             <span class="keywordflow">if</span> ( ntohs(ifaddr.addr.ss_family) == AF_INET)
00355             {
00356             <span class="keyword">struct </span><a class="code" href="structpcap__addr.html">pcap_addr</a> *addr;
00357 
00358                 <span class="keywordflow">if</span> (naddr == 0)
00359                 {
00360                     dev-&gt;addresses= (<span class="keyword">struct </span><a class="code" href="structpcap__addr.html">pcap_addr</a> *) malloc ( sizeof(struct pcap_addr) );
00361                     addr= dev-&gt;addresses;
00362                 }
00363                 <span class="keywordflow">else</span>
00364                 {
00365                     addr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a>= (<span class="keyword">struct </span><a class="code" href="structpcap__addr.html">pcap_addr</a> *) malloc ( sizeof(struct pcap_addr) );
00366                     addr= addr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a>;
00367                 }
00368                 naddr++;
00369 
00370                 <span class="keywordflow">if</span> (addr == NULL)
00371                 {
00372                     <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00373                     <span class="keywordflow">goto</span> error;
00374                 }
00375                 addr-&gt;<a class="code" href="structpcap__addr.html#m0">next</a>= NULL;
00376 
00377                 <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) &amp;ifaddr.addr, 
00378                     (<span class="keyword">struct</span> sockaddr_storage **) &amp;addr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a>, errbuf) == -1)
00379                     <span class="keywordflow">goto</span> error;
00380                 <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) &amp;ifaddr.netmask, 
00381                     (<span class="keyword">struct</span> sockaddr_storage **) &amp;addr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a>, errbuf) == -1)
00382                     <span class="keywordflow">goto</span> error;
00383                 <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) &amp;ifaddr.broadaddr, 
00384                     (<span class="keyword">struct</span> sockaddr_storage **) &amp;addr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a>, errbuf) == -1)
00385                     <span class="keywordflow">goto</span> error;
00386                 <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a>( (<span class="keyword">struct</span> sockaddr_storage *) &amp;ifaddr.dstaddr, 
00387                     (<span class="keyword">struct</span> sockaddr_storage **) &amp;addr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a>, errbuf) == -1)
00388                     <span class="keywordflow">goto</span> error;
00389 
00390                 <span class="keywordflow">if</span> ( (addr-&gt;<a class="code" href="structpcap__addr.html#m1">addr</a> == NULL) &amp;&amp; (addr-&gt;<a class="code" href="structpcap__addr.html#m2">netmask</a> == NULL) &amp;&amp; 
00391                     (addr-&gt;<a class="code" href="structpcap__addr.html#m3">broadaddr</a> == NULL) &amp;&amp; (addr-&gt;<a class="code" href="structpcap__addr.html#m4">dstaddr</a> == NULL) )
00392                 {
00393                     free(addr);
00394                     addr= NULL;
00395                     <span class="keywordflow">if</span> (naddr == 1)
00396                         naddr= 0;   <span class="comment">// the first item of the list had NULL addresses</span>
00397                 }
00398             }
00399         }
00400     }
00401 
00402     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
00403     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00404     {
00405         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, ntohl(header.plen) - nread, errbuf) == 1)
00406             <span class="keywordflow">return</span> -1;
00407     }
00408 
00409     <span class="comment">// Control connection has to be closed only in case the remote machine is in passive mode</span>
00410     <span class="keywordflow">if</span> (!active)
00411     {
00412         <span class="comment">// DO not send RPCAP_CLOSE, since we did not open a pcap_t; no need to free resources</span>
00413         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, errbuf) )
00414             <span class="keywordflow">return</span> -1;
00415     }
00416 
00417     <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
00418     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
00419 
00420     <span class="keywordflow">return</span> 0;
00421 
00422 error:
00423     <span class="comment">// In case there has been an error, I don't want to overwrite it with a new one</span>
00424     <span class="comment">// if the following call fails. I want to return always the original error.</span>
00425     <span class="comment">//</span>
00426     <span class="comment">// Take care: this connection can already be closed when we try to close it.</span>
00427     <span class="comment">// This happens because a previous error in the rpcapd, which requested to</span>
00428     <span class="comment">// closed the connection. In that case, we already recognized that into the</span>
00429     <span class="comment">// rpspck_isheaderok() and we already acknowledged the closing.</span>
00430     <span class="comment">// In that sense, this call is useless here (however it is needed in case</span>
00431     <span class="comment">// the client generates the error).</span>
00432 
00433     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
00434     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00435     {
00436         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, ntohl(header.plen) - nread, fakeerrbuf) == 1)
00437             <span class="keywordflow">return</span> -1;
00438     }
00439 
00440     <span class="comment">// Control connection has to be closed only in case the remote machine is in passive mode</span>
00441     <span class="keywordflow">if</span> (!active)
00442         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
00443 
00444     <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
00445     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
00446 
00447     <span class="keywordflow">return</span> -1;
00448 }
00449 
00450 
00451 
00452 
<a name="l00495"></a><a class="code" href="pcap-new_8c.html#a4">00495</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a4">pcap_createsrcstr</a>(<span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> type, <span class="keyword">const</span> <span class="keywordtype">char</span> *host, <span class="keyword">const</span> <span class="keywordtype">char</span> *port, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *errbuf)
00496 {
00497     <span class="keywordflow">switch</span> (type)
00498     {
00499         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a1">PCAP_SRC_FILE</a>:
00500         {
00501             strncpy(source, PCAP_SRC_FILE_KEY, PCAP_BUF_SIZE);
00502             <span class="keywordflow">if</span> ((name) &amp;&amp; (*name) )
00503             {
00504                 strncat(source, name, PCAP_BUF_SIZE);
00505                 <span class="keywordflow">return</span> 0;
00506             }
00507             <span class="keywordflow">else</span>
00508             {
00509                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The file name cannot be NULL."</span>);
00510                 <span class="keywordflow">return</span> -1;
00511             }
00512         }
00513         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>:
00514         {
00515             strncpy(source, PCAP_SRC_IF_KEY, PCAP_BUF_SIZE);
00516             <span class="keywordflow">if</span> ((host) &amp;&amp; (*host) )
00517             {
00518                 <span class="keywordflow">if</span> ( (strcspn(host, <span class="stringliteral">"aAbBcCdDeEfFgGhHjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"</span>)) == strlen(host) )
00519                 {
00520                     <span class="comment">// the host name does not contains alphabetic chars. So, it is a numeric address</span>
00521                     <span class="comment">// In this case we have to include it between square brackets</span>
00522                     strncat(source, <span class="stringliteral">"["</span>, PCAP_BUF_SIZE);
00523                     strncat(source, host, PCAP_BUF_SIZE);
00524                     strncat(source, <span class="stringliteral">"]"</span>, PCAP_BUF_SIZE);
00525                 }
00526                 <span class="keywordflow">else</span>
00527                     strncat(source, host, PCAP_BUF_SIZE);
00528 
00529                 <span class="keywordflow">if</span> ((port) &amp;&amp; (*port) )
00530                 {
00531                     strncat(source, <span class="stringliteral">":"</span>, PCAP_BUF_SIZE);
00532                     strncat(source, port, PCAP_BUF_SIZE);
00533                 }
00534 
00535                 strncat(source, <span class="stringliteral">"/"</span>, PCAP_BUF_SIZE);
00536             }
00537             <span class="keywordflow">else</span>
00538             {
00539                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The host name cannot be NULL."</span>);
00540                 <span class="keywordflow">return</span> -1;
00541             }
00542 
00543             <span class="keywordflow">if</span> ((name) &amp;&amp; (*name) )
00544             {
00545                 strncat(source, name, PCAP_BUF_SIZE);
00546                 <span class="keywordflow">return</span> 0;
00547             }
00548             <span class="keywordflow">else</span>
00549             {
00550                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The interface name cannot be NULL."</span>);
00551                 <span class="keywordflow">return</span> -1;
00552             }
00553         }
00554         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a2">PCAP_SRC_IFLOCAL</a>:
00555         {
00556             strncpy(source, PCAP_SRC_IF_KEY, PCAP_BUF_SIZE);
00557             <span class="keywordflow">if</span> ((name) &amp;&amp; (*name) )
00558             {
00559                 strncat(source, name, PCAP_BUF_SIZE);
00560                 <span class="keywordflow">return</span> 0;
00561             }
00562             <span class="keywordflow">else</span>
00563             {
00564                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The interface name cannot be NULL."</span>);
00565                 <span class="keywordflow">return</span> -1;
00566             }
00567         }
00568         <span class="keywordflow">default</span>:
00569         {
00570             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The interface type is not valid."</span>);
00571             <span class="keywordflow">return</span> -1;
00572         }
00573     }
00574 }
00575 
00576 
00577 
00578 
<a name="l00636"></a><a class="code" href="pcap-new_8c.html#a5">00636</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a5">pcap_parsesrcstr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> *type, <span class="keywordtype">char</span> *host, <span class="keywordtype">char</span> *port, <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *errbuf)
00637 {
00638 <span class="keywordtype">char</span> *ptr;
00639 <span class="keywordtype">int</span> ntoken;
00640 <span class="keywordtype">char</span> tmpname[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];
00641 <span class="keywordtype">char</span> tmphost[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];
00642 <span class="keywordtype">char</span> tmpport[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];
00643 <span class="keywordtype">int</span> tmptype;
00644 
00645     <span class="comment">// Initialization stuff</span>
00646     tmpname[0]= 0;
00647     tmphost[0]= 0;
00648     tmpport[0]= 0;
00649 
00650     <span class="keywordflow">if</span> (host)
00651         *<a class="code" href="wpcap__remote_8htm.html#a3">host</a>= 0;
00652     <span class="keywordflow">if</span> (port) 
00653         *<a class="code" href="rpcapd_8c.html#a8">port</a>= 0;
00654     <span class="keywordflow">if</span> (name)
00655         *name= 0;
00656 
00657     <span class="comment">// Look for a 'rpcap://' identifier</span>
00658     <span class="keywordflow">if</span> ( (ptr= strstr(source, PCAP_SRC_IF_KEY)) != NULL)
00659     {
00660         ptr+= strlen(PCAP_SRC_IF_KEY);
00661 
00662         <span class="keywordflow">if</span> (strchr(ptr, <span class="charliteral">'['</span>)) <span class="comment">// This is probably a numeric address</span>
00663         {
00664             ntoken= sscanf(ptr, <span class="stringliteral">"[%[1234567890:.]]:%[^/]/%s"</span>, tmphost, tmpport, tmpname);
00665 
00666             <span class="keywordflow">if</span> (ntoken == 1)    <span class="comment">// probably the port is missing</span>
00667                 ntoken= sscanf(ptr, <span class="stringliteral">"[%[1234567890:.]]/%s"</span>, tmphost, tmpname);
00668 
00669             tmptype= <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>;
00670         }
00671         <span class="keywordflow">else</span>
00672         {
00673             ntoken= sscanf(ptr, <span class="stringliteral">"%[^/:]:%[^/]/%s"</span>, tmphost, tmpport, tmpname);
00674 
00675             <span class="keywordflow">if</span> (ntoken == 1)
00676             {
00677                 <span class="comment">// This can be due to two reasons:</span>
00678                 <span class="comment">// - we want a remote capture, but the network port is missing</span>
00679                 <span class="comment">// - we want to do a local capture</span>
00680                 <span class="comment">// To distinguish between the two, we look for the '/' char</span>
00681                 <span class="keywordflow">if</span> (strchr(ptr, <span class="charliteral">'/'</span>))
00682                 {
00683                     <span class="comment">// We're on a remote capture</span>
00684                     sscanf(ptr, <span class="stringliteral">"%[^/]/%s"</span>, tmphost, tmpname);
00685                     tmptype= <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>;
00686                 }
00687                 <span class="keywordflow">else</span>
00688                 {
00689                     <span class="comment">// We're on a local capture</span>
00690                     <span class="keywordflow">if</span> (*ptr)
00691                         strncpy(tmpname, ptr, PCAP_BUF_SIZE);
00692 
00693                     <span class="comment">// Clean the host name, since it is a remote capture</span>
00694                     <span class="comment">// NOTE: the host name has been assigned in the previous "ntoken= sscanf(...)" line</span>
00695                     tmphost[0]= 0;
00696 
00697                     tmptype= <a class="code" href="group__remote__struct.html#a2">PCAP_SRC_IFLOCAL</a>;
00698                 }
00699             }
00700             <span class="keywordflow">else</span>
00701                 tmptype= <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>;
00702         }
00703 
00704         <span class="keywordflow">if</span> (tmpname[0])
00705         {
00706             <span class="keywordflow">if</span> (host)
00707                 strcpy(host, tmphost);
00708             <span class="keywordflow">if</span> (port) 
00709                 strcpy(port, tmpport);
00710             <span class="keywordflow">if</span> (name)
00711                 strcpy(name, tmpname);
00712             <span class="keywordflow">if</span> (type)
00713                 *type= tmptype;
00714 
00715             <span class="keywordflow">return</span> 0;
00716         }
00717         <span class="keywordflow">else</span>
00718         {
00719             <span class="keywordflow">if</span> (errbuf)
00720                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The interface name has not been specified."</span>);
00721 
00722             <span class="keywordflow">return</span> -1;
00723         }
00724     }
00725 
00726     <span class="comment">// Look for a 'file://' identifier</span>
00727     <span class="keywordflow">if</span> ( (ptr= strstr(source, PCAP_SRC_FILE_KEY)) != NULL)
00728     {
00729         ptr+= strlen(PCAP_SRC_FILE_KEY);
00730         <span class="keywordflow">if</span> (*ptr)
00731         {
00732             <span class="keywordflow">if</span> (name)
00733                 strncpy(name, ptr, PCAP_BUF_SIZE);
00734 
00735             <span class="keywordflow">if</span> (type)
00736                 *type= <a class="code" href="group__remote__struct.html#a1">PCAP_SRC_FILE</a>;
00737 
00738             <span class="keywordflow">return</span> 0;
00739         }
00740         <span class="keywordflow">else</span>
00741         {
00742             <span class="keywordflow">if</span> (errbuf)
00743                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The file name has not been specified."</span>);
00744 
00745             <span class="keywordflow">return</span> -1;
00746         }
00747 
00748     }
00749 
00750     <span class="comment">// Backward compatibility; the user didn't use the 'rpcap://, file://'  specifiers</span>
00751     <span class="keywordflow">if</span> ( (source) &amp;&amp; (*source) )
00752     {
00753         <span class="keywordflow">if</span> (name)
00754             strncpy(name, source, PCAP_BUF_SIZE);
00755 
00756         <span class="keywordflow">if</span> (type)
00757             *type= <a class="code" href="group__remote__struct.html#a2">PCAP_SRC_IFLOCAL</a>;
00758 
00759         <span class="keywordflow">return</span> 0;
00760     }
00761     <span class="keywordflow">else</span>
00762     {
00763         <span class="keywordflow">if</span> (errbuf)
00764             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The interface name has not been specified."</span>);
00765 
00766         <span class="keywordflow">return</span> -1;
00767     }
00768 };
00769 
00770 
00771 
<a name="l00881"></a><a class="code" href="pcap-new_8c.html#a6">00881</a> <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *<a class="code" href="pcap-new_8c.html#a6">pcap_open</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *source, <span class="keywordtype">int</span> snaplen, <span class="keywordtype">int</span> flags, <span class="keywordtype">int</span> read_timeout, <span class="keyword">struct</span> <a class="code" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <span class="keywordtype">char</span> *errbuf)
00882 {
00883 <span class="keywordtype">char</span> <a class="code" href="wpcap__remote_8htm.html#a3">host</a>[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>], <a class="code" href="rpcapd_8c.html#a8">port</a>[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>], name[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];
00884 <span class="keywordtype">int</span> type;
00885 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;
00886 
00887     <span class="keywordflow">if</span> (strlen(source) &gt; <a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>)
00888     {
00889         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The source string is too long. Cannot handle it correctly."</span>);
00890         <span class="keywordflow">return</span> NULL;
00891     }
00892 
00893     <span class="comment">// determine the type of the source (NULL, file, local, remote)</span>
00894     <span class="keywordflow">if</span> (<a class="code" href="pcap-new_8c.html#a5">pcap_parsesrcstr</a>(source, &amp;type, host, port, name, errbuf) == -1)
00895         <span class="keywordflow">return</span> NULL;
00896 
00897 
00898     <span class="keywordflow">switch</span> (type) 
00899     {
00900         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a1">PCAP_SRC_FILE</a>:
00901             fp = <a class="code" href="savefile_8c.html#a57">pcap_open_offline</a>(name, NULL);
00902             <span class="keywordflow">break</span>;
00903 
00904         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>:
00905             <span class="comment">// Although we already have host, port and iface, we prefer TO PASS only 'pars' to the </span>
00906             <span class="comment">// pcap_open_remote() so that it has to call the pcap_parsesrcstr() again.</span>
00907             <span class="comment">// This is less optimized, but much clearer.</span>
00908             fp= <a class="code" href="pcap-remote_8c.html#a15">pcap_opensource_remote</a>(source, auth, errbuf);
00909 
00910             <span class="keywordflow">if</span> (fp == NULL)
00911                 <span class="keywordflow">return</span> NULL;
00912 
00913             fp-&gt;snapshot= snaplen;
00914 <span class="preprocessor">#ifdef WIN32</span>
00915 <span class="preprocessor"></span>            fp-&gt;timeout= read_timeout;
00916 <span class="preprocessor">#else</span>
00917 <span class="preprocessor"></span>            fp-&gt;md.timeout= read_timeout;
00918 <span class="preprocessor">#endif</span>
00919 <span class="preprocessor"></span>            fp-&gt;rmt_flags= flags;
00920             <span class="keywordflow">break</span>;
00921 
00922         <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a2">PCAP_SRC_IFLOCAL</a>:
00923             fp= <a class="code" href="Pcap-win32_8c.html#a7">pcap_open_live</a>(name, snaplen, (flags &amp; PCAP_OPENFLAG_PROMISCUOUS), read_timeout, errbuf);
00924             <span class="keywordflow">break</span>;
00925 
00926         <span class="keywordflow">default</span>:
00927             strcpy(errbuf, <span class="stringliteral">"Source type not supported"</span>);
00928             <span class="keywordflow">return</span> NULL;
00929     }
00930     <span class="keywordflow">return</span> fp;
00931 }
00932 
00933 
00934 
<a name="l00996"></a><a class="code" href="pcap-new_8c.html#a7">00996</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a7">pcap_remoteact_accept</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *address, <span class="keyword">const</span> <span class="keywordtype">char</span> *port, <span class="keyword">const</span> <span class="keywordtype">char</span> *hostlist, <span class="keywordtype">char</span> *connectinghost, <span class="keyword">struct</span> <a class="code" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <span class="keywordtype">char</span> *errbuf)
00997 {
00998 <span class="comment">// socket-related variables</span>
00999 <span class="keyword">struct </span>addrinfo hints;          <span class="comment">// temporary struct to keep settings needed to open the new socket</span>
01000 <span class="keyword">struct </span>addrinfo *addrinfo;      <span class="comment">// keeps the addrinfo chain; required to open a new socket</span>
01001 <span class="keyword">struct </span>sockaddr_storage from;   <span class="comment">// generic sockaddr_storage variable</span>
01002 socklen_t fromlen;              <span class="comment">// keeps the length of the sockaddr_storage variable</span>
01003 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockctrl;                <span class="comment">// keeps the main socket identifier</span>
01004 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp, *prev;    <span class="comment">// temp var needed to scan he host list chain</span>
01005 
01006     *connectinghost= 0;     <span class="comment">// just in case</span>
01007 
01008     <span class="comment">// Prepare to open a new server socket</span>
01009     memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));
01010                                     <span class="comment">// WARNING Currently it supports only ONE socket family among ipv4 and IPv6 </span>
01011     hints.ai_family = AF_INET;      <span class="comment">// PF_UNSPEC to have both IPv4 and IPv6 server</span>
01012     hints.ai_flags = AI_PASSIVE;    <span class="comment">// Ready to a bind() socket</span>
01013     hints.ai_socktype = SOCK_STREAM;
01014 
01015     <span class="comment">// Warning: this call can be the first one called by the user.</span>
01016     <span class="comment">// For this reason, we have to initialize the WinSock support.</span>
01017     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a9">sock_init</a>(errbuf) == -1)
01018         <span class="keywordflow">return</span> -1;
01019 
01020     <span class="comment">// Do the work</span>
01021     <span class="keywordflow">if</span> ((<a class="code" href="rpcapd_8c.html#a8">port</a> == NULL) || (<a class="code" href="rpcapd_8c.html#a8">port</a>[0] == 0) )
01022     {   
01023         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(address, RPCAP_DEFAULT_NETPORT_ACTIVE, &amp;hints, &amp;addrinfo, errbuf) == -1)
01024         {
01025             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01026             <span class="keywordflow">return</span> -2;
01027         }
01028     }
01029     <span class="keywordflow">else</span>
01030     {
01031         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(address, port, &amp;hints, &amp;addrinfo, errbuf) == -1)
01032         {
01033             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01034             <span class="keywordflow">return</span> -2;
01035         }
01036     }
01037 
01038 
01039     <span class="keywordflow">if</span> ( (<a class="code" href="pcap-new_8c.html#a2">sockmain</a>= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_SERVER, 1, errbuf)) == -1)
01040     {
01041         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01042         <span class="keywordflow">return</span> -2;
01043     }
01044 
01045     <span class="comment">// Connection creation</span>
01046     fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
01047 
01048     sockctrl= accept(sockmain, (<span class="keyword">struct</span> sockaddr *) &amp;from, &amp;fromlen);
01049 
01050     <span class="comment">// We're not using sock_close, since we do not want to send a shutdown</span>
01051     <span class="comment">// (which is not allowed on a non-connected socket)</span>
01052     closesocket(sockmain);
01053     <a class="code" href="pcap-new_8c.html#a2">sockmain</a>= 0;
01054 
01055     <span class="keywordflow">if</span> (sockctrl == -1)
01056     {
01057         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"accept(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01058         <span class="keywordflow">return</span> -2;
01059     }
01060 
01061     <span class="comment">// Get the numeric for of the name of the connecting host</span>
01062     <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;from, fromlen, connectinghost, 
01063             RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST) )
01064     {
01065         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01066         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_REMOTEACCEPT, fakeerrbuf);
01067         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
01068         <span class="keywordflow">return</span> -1;
01069     }
01070 
01071     <span class="comment">// checks if the connecting host is among the ones allowed</span>
01072     <span class="keywordflow">if</span> ( (hostlist) &amp;&amp; (<a class="code" href="fileconf_8c.html#a0">hostlist</a>[0]) )
01073     {
01074         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a19">sock_check_hostlist</a>((<span class="keywordtype">char</span> *) hostlist, RPCAP_HOSTLIST_SEP, &amp;from, errbuf) )
01075         {
01076             <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_REMOTEACCEPT, fakeerrbuf);
01077             <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
01078             <span class="keywordflow">return</span> -1;
01079         }
01080     }
01081 
01082     <span class="comment">// Send authentication to the remote machine</span>
01083     <span class="keywordflow">if</span> ( <a class="code" href="pcap-remote_8c.html#a21">rpcap_sendauth</a>(sockctrl, auth, errbuf) == -1)
01084     {
01085         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_REMOTEACCEPT, fakeerrbuf);
01086         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
01087         <span class="keywordflow">return</span> -3;
01088     }
01089 
01090     <span class="comment">// Checks that this host does not already have a cntrl connection in place</span>
01091 
01092     <span class="comment">// Initialize pointers</span>
01093     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
01094     prev= NULL;
01095     
01096     <span class="keywordflow">while</span> (temp)
01097     {
01098         <span class="comment">// This host already has an active connection in place, so I don't have to update the host list</span>
01099         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a20">sock_cmpaddr</a>(&amp;temp-&gt;<a class="code" href="structactivehosts.html#m0">host</a>, &amp;from) == 0)
01100             <span class="keywordflow">return</span> sockctrl;
01101 
01102         prev= temp;
01103         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01104     }
01105 
01106     <span class="comment">// The host does not exist in the list; so I have to update the list</span>
01107     <span class="keywordflow">if</span> (prev)
01108     {
01109         prev-&gt;<a class="code" href="structactivehosts.html#m2">next</a>= (<span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *) malloc (sizeof (struct activehosts) );
01110         temp= prev-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01111     }
01112     <span class="keywordflow">else</span>
01113     {
01114         <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>= (<span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *) malloc (sizeof (struct activehosts) );
01115         temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
01116     }
01117 
01118     <span class="keywordflow">if</span> (temp == NULL)
01119     {
01120         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
01121         <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_REMOTEACCEPT, fakeerrbuf);
01122         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
01123         <span class="keywordflow">return</span> -1;
01124     }
01125 
01126     memcpy(&amp;temp-&gt;<a class="code" href="structactivehosts.html#m0">host</a>, &amp;from, fromlen);
01127     temp-&gt;<a class="code" href="structactivehosts.html#m1">sockctrl</a>= sockctrl;
01128     temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>= NULL;
01129 
01130     <span class="keywordflow">return</span> sockctrl;
01131 }
01132 
01133 
01134 
<a name="l01153"></a><a class="code" href="pcap-new_8c.html#a8">01153</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a8">pcap_remoteact_close</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *host, <span class="keywordtype">char</span> *errbuf)
01154 {
01155 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp, *prev;    <span class="comment">// temp var needed to scan the host list chain</span>
01156 <span class="keyword">struct </span>addrinfo hints, *addrinfo, *ai_next; <span class="comment">// temp var needed to translate between hostname to its address</span>
01157 <span class="keywordtype">int</span> retval;
01158 
01159     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
01160     prev= NULL;
01161 
01162     <span class="comment">// retrieve the network address corresponding to 'host'</span>
01163     addrinfo = NULL;
01164     memset(&amp;hints, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> addrinfo) );
01165     hints.ai_family = PF_UNSPEC;
01166     hints.ai_socktype= SOCK_STREAM;
01167 
01168     retval = getaddrinfo(host, <span class="stringliteral">"0"</span>, &amp;hints, &amp;addrinfo);
01169     <span class="keywordflow">if</span> (retval != 0)
01170     {
01171         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo() %s"</span>, gai_strerror(retval));
01172         <span class="keywordflow">return</span> -1;
01173     }
01174 
01175     <span class="keywordflow">while</span> (temp)
01176     {
01177         ai_next= addrinfo;
01178         <span class="keywordflow">while</span>(ai_next)
01179         {
01180             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a20">sock_cmpaddr</a>(&amp;temp-&gt;<a class="code" href="structactivehosts.html#m0">host</a>, (<span class="keyword">struct</span> sockaddr_storage *) ai_next-&gt;ai_addr ) == 0)
01181             {
01182             <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;
01183 
01184                 <span class="comment">// Close this connection</span>
01185                 <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( &amp;header, RPCAP_MSG_CLOSE, 0, 0);
01186 
01187                 <span class="comment">// I don't check for errors, since I'm going to close everything</span>
01188                 <a class="code" href="sockutils_8c.html#a14">sock_send</a>(temp-&gt;<a class="code" href="structactivehosts.html#m1">sockctrl</a>, (<span class="keywordtype">char</span> *) &amp;header, sizeof (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf);
01189 
01190                 <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a12">sock_close</a>(temp-&gt;<a class="code" href="structactivehosts.html#m1">sockctrl</a>, errbuf) )
01191                 {
01192                     <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
01193                     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
01194 
01195                     <span class="keywordflow">return</span> -1;
01196                 }
01197 
01198                 <span class="keywordflow">if</span> (prev)
01199                     prev-&gt;<a class="code" href="structactivehosts.html#m2">next</a>= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01200                 <span class="keywordflow">else</span>
01201                     <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01202 
01203                 freeaddrinfo(addrinfo);
01204 
01205                 free(temp);
01206 
01207                 <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
01208                 <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
01209 
01210                 <span class="keywordflow">return</span> 0;
01211             }
01212 
01213             ai_next= ai_next-&gt;ai_next;
01214         }
01215         prev= temp;
01216         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01217     }
01218 
01219     <span class="keywordflow">if</span> (addrinfo)
01220         freeaddrinfo(addrinfo);
01221 
01222     <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
01223     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
01224 
01225     <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The host you want to close the active connection is not known"</span>);
01226     <span class="keywordflow">return</span> -1;
01227 }
01228 
01229 
<a name="l01249"></a><a class="code" href="pcap-new_8c.html#a9">01249</a> <span class="keywordtype">void</span> <a class="code" href="group__remote__func.html#a9">pcap_remoteact_cleanup</a>()
01250 {
01251     <span class="comment">// Very dirty, but it works</span>
01252     <span class="keywordflow">if</span> (sockmain)
01253     {
01254         closesocket(sockmain);
01255 
01256         <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
01257         <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
01258     }
01259 
01260 }
01261 
01262 
<a name="l01285"></a><a class="code" href="pcap-new_8c.html#a10">01285</a> <span class="keywordtype">int</span> <a class="code" href="pcap-new_8c.html#a10">pcap_remoteact_list</a>(<span class="keywordtype">char</span> *hostlist, <span class="keywordtype">char</span> sep, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *errbuf)
01286 {
01287 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp;   <span class="comment">// temp var needed to scan the host list chain</span>
01288 <span class="keywordtype">int</span> len;
01289 <span class="keywordtype">char</span> hoststr[<a class="code" href="group__remote__struct.html#a11">RPCAP_HOSTLIST_SIZE</a> + 1];
01290 
01291     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
01292 
01293     len= 0;
01294     *<a class="code" href="fileconf_8c.html#a0">hostlist</a>= 0;
01295 
01296     <span class="keywordflow">while</span> (temp)
01297     {
01298         <span class="comment">// Get the numeric for of the name of the connecting host</span>
01299         <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;temp-&gt;<a class="code" href="structactivehosts.html#m0">host</a>, sizeof (<span class="keyword">struct</span> sockaddr_storage), hoststr, 
01300                 RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST) )
01301         {
01302             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01303             <span class="keywordflow">return</span> -1;
01304         }
01305 
01306         len= len + strlen(hoststr) + 1 <span class="comment">/* the separator */</span>;
01307 
01308         <span class="keywordflow">if</span> (len &gt;= <a class="code" href="gencode_8c.html#a27">size</a>)
01309         {
01310             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The string you provided is not able to keep "</span>
01311                 <span class="stringliteral">"the hostnames for all the active connections"</span>);
01312             <span class="keywordflow">return</span> -1;
01313         }
01314 
01315         strcat(hostlist, hoststr);
01316         <a class="code" href="fileconf_8c.html#a0">hostlist</a>[len - 1]= sep;
01317         <a class="code" href="fileconf_8c.html#a0">hostlist</a>[len]= 0;
01318 
01319         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
01320     }
01321 
01322     <span class="keywordflow">return</span> 0;
01323 }
01324 
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
