<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pcap-new.c File Reference</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pcap-new.c File Reference</h1><code>#include &lt;pcap-int.h&gt;</code><br>
<code>#include &lt;<a class="el" href="pcap-remote_8h-source.html">pcap-remote.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="sockutils_8h-source.html">sockutils.h</a>&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>

<p>
<a href="pcap-new_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a3">pcap_findalldevs_ex</a> (char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, char *<a class="el" href="rpcapd_8c.html#a8">port</a>, SOCKET sockctrl, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <a class="el" href="structpcap__if.html">pcap_if_t</a> **alldevs, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It creates a list of network devices that can be opened with <a class="el" href="group__remote__func.html#a3">pcap_open()</a>.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a4">pcap_createsrcstr</a> (char *source, int type, const char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, const char *<a class="el" href="rpcapd_8c.html#a8">port</a>, const char *name, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Accepts a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a5">pcap_parsesrcstr</a> (const char *source, int *type, char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, char *<a class="el" href="rpcapd_8c.html#a8">port</a>, char *name, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Parses the source string and returns the pieces in which the source can be split.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a6">pcap_open</a> (const char *source, int <a class="el" href="gencode_8c.html#a23">snaplen</a>, int flags, int read_timeout, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It opens a generic source in order to capture / send (WinPcap only) traffic.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a7">pcap_remoteact_accept</a> (const char *<a class="el" href="rpcapd_8c.html#a7">address</a>, const char *<a class="el" href="rpcapd_8c.html#a8">port</a>, const char *<a class="el" href="rpcapd_8c.html#a0">hostlist</a>, char *connectinghost, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It blocks until a network connection is accepted (active mode only).</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a8">pcap_remoteact_close</a> (const char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It drops an active connection (active mode only).</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a9">pcap_remoteact_cleanup</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cleans the socket that is currently used in waiting active connections.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a10">pcap_remoteact_list</a> (char *<a class="el" href="rpcapd_8c.html#a0">hostlist</a>, char sep, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the hostname of the host that have an active connection with us (active mode only).</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>char&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a0">fakeerrbuf</a> [PCAP_ERRBUF_SIZE+1]</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structactivehosts.html">activehosts</a> *&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a1">activeHosts</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Keeps a list of all the opened connections in the active mode.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>SOCKET&nbsp;</td><td valign=bottom><a class="el" href="pcap-new_8c.html#a2">sockmain</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Keeps the main socket identifier when we want to accept a new remote connection (active mode only).</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a4" doxytag="pcap-new.c::pcap_createsrcstr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_createsrcstr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accepts a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').
<p>
This function is provided in order to help the user to create the source string according to the new format. An unique source string is used in order to make easy for old applications to use the remote facilities. Think about tcpdump, for example, which has only one way to specify the interface on which the capture has to be started. However, GUI-based programs can find more useful to specify hostname, port and interface name separately. In that case, they can use this function to create the source string before passing it to the <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>source:</em>&nbsp;</td><td>a user-allocated buffer that will contain the complete source string wen the function returns. This function assumes that the allocated buffer is at least PCAP_BUF_SIZE bytes.</td></tr>
    <tr><td valign=top><em>type:</em>&nbsp;</td><td>its value tells the type of the source we want to create. It can assume the following values:<ul>
<li>PCAP_SRC_FILE: if we want a local file</li><li>PCAP_SRC_IFLOCAL: if we want a local interface</li><li>PCAP_SRC_IFREMOTE: if we want a remote interface</li></ul>
</td></tr>
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>an user-allocated buffer that keeps the host (e.g. "foo.bar.com") we want to connect to. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>an user-allocated buffer that keeps the network port (e.g. "2002") we want to use for the RPCAP protocol. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td valign=top><em>name:</em>&nbsp;</td><td>an user-allocated buffer that keeps the interface name we want to use (e.g. "eth0").</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The string containing the complete source is returned in the 'source' variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>If the source is longer than PCAP_BUF_SIZE, the excess characters are truncated. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00495">495</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="remote-ext_8h-source.html#l00083">PCAP_SRC_FILE</a>, <a class="el" href="remote-ext_8h-source.html#l00091">PCAP_SRC_IFLOCAL</a>, <a class="el" href="remote-ext_8h-source.html#l00099">PCAP_SRC_IFREMOTE</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="pcap-new.c::pcap_findalldevs_ex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_findalldevs_ex </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sockctrl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structpcap__if.html">pcap_if_t</a> **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>alldevs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It creates a list of network devices that can be opened with <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a>.
<p>
This function is a superset of the old 'pcap_findalldevs()', which is obsolete, and which allows listing only the devices present on the local machine. Vice versa, <a class="el" href="pcap-new_8c.html#a3">pcap_findalldevs_ex()</a> allows listing the devices present on a remote machine as well. Moreover, <a class="el" href="pcap-new_8c.html#a3">pcap_findalldevs_ex()</a> is platform independent, since it relies on the standard <a class="el" href="group__wpcap__fn.html#a7">pcap_findalldevs()</a> to get addresses on the local machine.<p>
In case the function has to list the interfaces on a remote machine, it opens a new control connection toward that machine, it retrieves the interfaces, and it drops the connection. However, if this function detects that the remote machine is in 'active' mode, the connection is not dropped (see the 'sockctrl' parameters for more details). In the same way, if we're in active mode and the connection is already opened, it uses the existing socket.<p>
This function can rely on the <a class="el" href="pcap-new_8c.html#a4">pcap_createsrcstr()</a> to create the string that keeps the capture device according to the new syntax, and the <a class="el" href="pcap-new_8c.html#a5">pcap_parsesrcstr()</a> for the other way round.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>a char* buffer that keeps the address of the remote host on which we want to see the interface list. It can be NULL: in this case the function queries the local host for the locally installed interfaces. The address can be both numeric (e.g. '10.11.12.13', '1:2:3::4') and literal (e.g. 'foo.bar.com').</td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host. This parameter is not meaningful in case of a query to the local host: in that case it can be NULL.</td></tr>
    <tr><td valign=top><em>sockctrl:</em>&nbsp;</td><td>Socket to be used for the control connection. This parameter is meaningful only if the control connection is already open when the <a class="el" href="group__wpcap__fn.html#a7">pcap_findalldevs()</a> is called. This can be the case in which the 'ative' mode is used, in which the capturing machine opens a control connection toward the client in order to bypass in-middle firewalls. In that case, the control connection is already open, and we have to use this one instead of opening a new one.</td></tr>
  </table>
</dl>
In case this parameter is non-zero, the 'host' and 'port' parameters are meaningless: the software will always try to retrieve the network adapters using this control connection, despite the value assumed by 'host' and 'port'. In case this parameter is non-zero, the socket is not closed at the end of the function and it remains open for future use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>a char* buffer (e.g. "2003") that keeps the network port on which we want to connect to. It can be NULL: in this case the function uses the standard port, defined in RPCAP_DEFAULT_NETPORT.</td></tr>
    <tr><td valign=top><em>alldevs:</em>&nbsp;</td><td>a 'struct pcap_if_t' pointer, which will be properly allocated inside this function. When the function returns, it is set to point to the first element of the interface list; each element of the list is of type 'struct pcap_if_t'.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The list of the devices is returned in the 'alldevs' variable. When the function returns correctly, 'alldevs' cannot be NULL. In other words, this function returns '-1' also in case the system does not have any interface to list.</dd></dl>
The error message is returned in the 'errbuf' variable. An error could be due to several reasons:<ul>
<li>libpcap/WinPcap was not installed on the local/remote host</li><li>the user does not have enough privileges to list the devices</li><li>a network problem</li><li>the RPCAP version negotiation failed</li><li>other errors (not enough memory and others).</li></ul>
<p>
<dl compact><dt><b>Warning:</b></dt><dd>There may be network devices that cannot be opened with <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a> by the process calling <a class="el" href="group__wpcap__fn.html#a7">pcap_findalldevs()</a>, because, for example, that process might not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.<p>
The interface list must be deallocated manually by using the <a class="el" href="group__wpcap__fn.html#a8">pcap_freealldevs()</a>. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00150">150</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="incs_2pcap_8h-source.html#l00163">pcap_addr::addr</a>, <a class="el" href="incs_2pcap_8h-source.html#l00165">pcap_addr::broadaddr</a>, <a class="el" href="incs_2pcap_8h-source.html#l00166">pcap_addr::dstaddr</a>, <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="pcap-remote_8h-source.html#l00159">rpcap_findalldevs_if::namelen</a>, <a class="el" href="incs_2pcap_8h-source.html#l00164">pcap_addr::netmask</a>, <a class="el" href="incs_2pcap_8h-source.html#l00162">pcap_addr::next</a>, <a class="el" href="funcs_2pcap_8h.html#a7">pcap_findalldevs()</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="rpcapd_8c-source.html#l00067">port</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8c-source.html#l00133">rpcap_deseraddr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00278">RPCAP_MSG_FINDALLIF_REPLY</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="pcap-new.c::pcap_open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#a2">pcap_t</a>* pcap_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>snaplen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>read_timeout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It opens a generic source in order to capture / send (WinPcap only) traffic.
<p>
The <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a> replaces all the pcap_open_xxx() functions with a single call.<p>
This function hides the differences between the different pcap_open_xxx() functions so that the programmer does not have to manage different opening function. In this way, the 'true' open function is decided according to the source type, which is included into the source string (in the form of source prefix).<p>
This function can rely on the <a class="el" href="pcap-new_8c.html#a4">pcap_createsrcstr()</a> to create the string that keeps the capture device according to the new syntax, and the <a class="el" href="pcap-new_8c.html#a5">pcap_parsesrcstr()</a> for the other way round.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>source:</em>&nbsp;</td><td>zero-terminated string containing the source name to open. The source name has to include the format prefix according to the syntax proposed by WinPcap. It cannot be NULL. On on Linux systems with 2.2 or later kernels, a device argument of "any" (i.e. rpcap://any) can be used to capture packets from all interfaces. <br>
 In case the <a class="el" href="pcap-new_8c.html#a4">pcap_createsrcstr()</a> is not used, remember that the new source syntax allows for these formats to be used in the <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a>:<ul>
<li><a href="file://filename">file://filename</a> [we want to open a local file]</li><li>rpcap://host.foo.bar/adaptername [everything literal, no port number]</li><li>rpcap://host.foo.bar:1234/adaptername [everything literal, with port number]</li><li>rpcap://10.11.12.13/adaptername [IPv4 numeric, no port number]</li><li>rpcap://10.11.12.13:1234/adaptername [IPv4 numeric, with port number]</li><li>rpcap://[10.11.12.13]:1234/adaptername [IPv4 numeric with IPv6 format, with port number]</li><li>rpcap://[1:2:3::4]/adaptername [IPv6 numeric, no port number]</li><li>rpcap://[1:2:3::4]:1234/adaptername [IPv6 numeric, with port number]</li><li>rpcap://adaptername [local adapter, opened without using the RPCAP protocol]</li><li>adaptername [to open a local adapter; kept for compability, but it is strongly discouraged]</li><li>(NULL) [to open the first local adapter; kept for compability, but it is strongly discouraged]</li></ul>
</td></tr>
  </table>
</dl>
The following formats are not allowed:<ul>
<li>rpcap:// [to open the first local adapter]</li><li>rpcap://hostname/ [to open the first remote adapter]</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>snaplen:</em>&nbsp;</td><td>length of the packet that has to be retained. For each packet received by the filter, only the first 'snaplen' bytes are stored in the buffer and passed to the user application. For instance, snaplen equal to 100 means that only the first 100 bytes of each packet are stored.</td></tr>
    <tr><td valign=top><em>flags:</em>&nbsp;</td><td>keeps several flags that can be needed for capturing packets. The allowed flags are the following:<ul>
<li>PCAP_OPENFLAG_PROMISCUOUS: if the adapter has to go in promiscuous mode. It is '1' if you have to open the adapter in promiscuous mode, '0' otherwise. Note that even if this parameter is false, the interface could well be in promiscuous mode for some other reason (for example because another capture process with promiscuous mode enabled is currently using that interface). On on Linux systems with 2.2 or later kernels (that have the "any" device), this flag does not work on the "any" device; if an argument of "any" is supplied, the 'promisc' flag is ignored.</li><li>PCAP_OPENFLAG_SERVEROPEN_DP: it specifies who is responsible for opening the data connection in case of a remote capture (it means 'server open data path'). If it is '1', it specifies if the data connection has to be intitiated by the capturing device (which becomes like 'active'). If '0', the connection will be initiated by the client workstation. This flag is used to overcome the problem of firewalls, which allow only outgoing connections. In that case, the capturing device can open a connection toward the client workstation in order to allow the data trasfer. In fact, the data connection is opened using a random port (while the control connection uses a standard port), so it is hard to configure a firewall to permit traffic on the data path. This flag is meaningless if the source is not a remote interface. Addictionally, it is meaningless if the data connection is done using the UDP protocol, since in this case the connection wil always be opened by the server. In these cases, it is simply ignored.</li><li>PCAP_OPENFLAG_UDP_DP: it specifies if the data trasfer (in case of a remote capture) has to be done with UDP protocol. If it is '1' if you want a UDP data connection, '0' if you want a TCP data connection; control connection is always TCP-based. A UDP connection is much lighter, but it does not guarantee that all the captured packets arrive to the client workstation. Moreover, it could be harmful in case of network congestion. This flag is meaningless if the source is not a remote interface. In that case, it is simply ignored.</li></ul>
</td></tr>
    <tr><td valign=top><em>read_timeout:</em>&nbsp;</td><td>read timeout in milliseconds. The read timeout is used to arrange that the read not necessarily return immediately when a packet is seen, but that it waits for some amount of time to allow more packets to arrive and to read multiple packets from the OS kernel in one operation. Not all platforms support a read timeout; on platforms that don't, the read timeout is ignored.</td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a 'struct pcap_rmtauth' that keeps the information required to authenticate the user on a remote machine. In case this is not a remote capture, this pointer can be set to NULL.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer which will contain the error in case this function fails. The <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a> and findalldevs() are the only two functions which have this parameter, since they do not have (yet) a pointer to a pcap_t structure, which reserves space for the error string. Since these functions do not have (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of errors), they need an explicit 'errbuf' variable. 'errbuf' may also be set to warning text when <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a> succeds; to detect this case the caller should store a zero-length string in 'errbuf' before calling <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a> and display the warning to the user if 'errbuf' is no longer a zero-length string.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a 'pcap_t' which can be used as a parameter to the following calls (<a class="el" href="group__wpcap__fn.html#a14">pcap_compile()</a> and so on) and that specifies an opened WinPcap session. In case of problems, it returns NULL and the 'errbuf' variable keeps the error message.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>The source cannot be larger than PCAP_BUF_SIZE. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00881">881</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="Pcap-win32_8c-source.html#l00144">pcap_open_live()</a>, <a class="el" href="savefile_8c-source.html#l00387">pcap_open_offline()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00636">pcap_parsesrcstr()</a>, <a class="el" href="remote-ext_8h-source.html#l00083">PCAP_SRC_FILE</a>, <a class="el" href="remote-ext_8h-source.html#l00091">PCAP_SRC_IFLOCAL</a>, <a class="el" href="remote-ext_8h-source.html#l00099">PCAP_SRC_IFREMOTE</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="rpcapd_8c-source.html#l00067">port</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, and <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="pcap-new.c::pcap_parsesrcstr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_parsesrcstr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Parses the source string and returns the pieces in which the source can be split.
<p>
This call is the other way round of <a class="el" href="pcap-new_8c.html#a4">pcap_createsrcstr()</a>. It accepts a null-terminated string and it returns the parameters related to the source. This includes:<ul>
<li>the type of the source (file, winpcap on a remote adapter, winpcap on local adapter), which is determined by the source prefix (PCAP_SRC_IF_KEY and so on)</li><li>the host on which the capture has to be started (only for remote captures)</li><li>the 'raw' name of the source (file name, name of the remote adapter, name of the local adapter), without the source prefix. The string returned does not include the type of the source itself (i.e. the string returned does not include "file://" or rpcap:// or such).</li></ul>
<p>
The user can omit some parameters in case it is not interested in them.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>source:</em>&nbsp;</td><td>a null-terminated string containing the WinPcap source</td></tr>
    <tr><td valign=top><em>type:</em>&nbsp;</td><td>pointer to an integer, which is used to return the code corrisponding to the selected source. The code will be one of the following:<ul>
<li>PCAP_SRC_FILE</li><li>PCAP_SRC_IFLOCAL</li><li>PCAP_SRC_IFREMOTE In case the source string does not exists (i.e. 'source == NULL') or it is empty ('*source == NULL'), it returns PCAP_SRC_IF_LOCAL (i.e. you are ready to call <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a> ). This behavior is kept only for compatibility with older applications (e.g. tcpdump); therefore we suggest to move to the new syntax for sources.</li></ul>
</td></tr>
  </table>
</dl>
This parameter can be NULL in case the user is not interested in that.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the host name on which the capture has to be started. This value is meaningful only in case of remote capture; otherwise, the returned string will be empty (""). This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the port that has to be used by the RPCAP protocol to contact the other host. This value is meaningful only in case of remote capture and if the user wants to use a non-standard port; otherwise, the returned string will be empty (""). In case of remote capture, an emply string means "use the standard RPCAP port". This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td valign=top><em>name:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the source name, without the source prefix. If the name does not exist (for example because source contains 'rpcap://' that means 'default local adapter'), it returns NULL. This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). This parameter can be NULL in case the user is not interested in that.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The requested values (host name, network port, type of the source) are returned into the proper variables passed by reference. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00636">636</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="remote-ext_8h-source.html#l00083">PCAP_SRC_FILE</a>, <a class="el" href="remote-ext_8h-source.html#l00091">PCAP_SRC_IFLOCAL</a>, <a class="el" href="remote-ext_8h-source.html#l00099">PCAP_SRC_IFREMOTE</a>, <a class="el" href="rpcapd_8c-source.html#l00067">port</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00881">pcap_open()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00144">pcap_open_live()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="pcap-new.c::pcap_remoteact_accept"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_remoteact_accept </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>address</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connectinghost</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It blocks until a network connection is accepted (active mode only).
<p>
This function has been defined to allow the client dealing with the 'active mode'. In other words, in the 'active mode' the server opens the connection toward the client, so that the client has to open a socket in order to wait for connections. When a new connection is accepted, the RPCAP protocol starts as usual; the only difference is that the connection is initiated by the server.<p>
This function accepts only ONE connection, then it closes the waiting socket. This means that if some error occurs, the application has to call it again in order to accept another connection.<p>
This function returns when a new connection (coming from a valid host 'connectinghost') is accepted; it returns error otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>address:</em>&nbsp;</td><td>a string that keeps the network address we have to bind to; usually it is NULL (it means 'bind on all local addresses').</td></tr>
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>a string that keeps the network port on which we have to bind to; usually it is NULL (it means 'bind on the predefined port', i.e. RPCAP_DEFAULT_NETPORT_ACTIVE).</td></tr>
    <tr><td valign=top><em>hostlist:</em>&nbsp;</td><td>a string that keeps the host name of the host from whom we are expecting a connection; it can be NULL (it means 'accept connection from everyone'). Host names are separated by a whatever character in the RPCAP_HOSTLIST_SEP list.</td></tr>
    <tr><td valign=top><em>connectinghost:</em>&nbsp;</td><td>a user-allocated buffer that will contain the name of the host is trying to connect to us. This variable must be at least RPCAP_HOSTLIST_SIZE bytes..</td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The SOCKET identifier of the new control connection if everything is fine, a negative number if some errors occurred. The error message is returned into the errbuf variable. In case it returns '-1', this means 'everything is fine', but the host cannot be admitted. In case it returns '-2', in means 'unrecoverable error' (for example it is not able to bind the socket, or something like that). In case it returns '-3', it means 'authentication failed'. The authentication check is performed only if the connecting host is among the ones that are allowed to connect to this host.</dd></dl>
The host that is connecting to us is returned into the hostlist variable, which ust be allocated by the user. This variable contains the host name both in case the host is allowed, and in case the connection is refused.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Although this function returns the socket established by the new control connection, this value should not be used. This value will be stored into some libpcap internal variables and it will be managed automatically by the library. In other words, all the following calls to findalldevs() and <a class="el" href="pcap-new_8c.html#a6">pcap_open()</a> will check if the host is among one that already has a control connection in place; if so, that one will be used.<p>
This function has several problems if used inside a thread, which is stopped when this call is blocked into the accept(). In this case, the socket on which we accept connections is not freed (thread termination is a very dirty job), so that we are no longer able to accept other connections until the program (i.e. the process) stops. In order to solve the problem, call the <a class="el" href="pcap-new_8c.html#a9">pcap_remoteact_cleanup()</a>. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00996">996</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00132">activehosts::host</a>, <a class="el" href="fileconf_8c-source.html#l00044">hostlist</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="rpcapd_8c-source.html#l00067">port</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>, <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>, and <a class="el" href="pcap-new_8c-source.html#l00060">sockmain</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="pcap-new.c::pcap_remoteact_cleanup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_remoteact_cleanup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cleans the socket that is currently used in waiting active connections.
<p>
This function does a very dirty job. The fact is that is the waiting socket is not freed if the pcap_remoteaccept() is killed inside a new thread. This function is able to clean the socket in order to allow the next calls to <a class="el" href="pcap-new_8c.html#a7">pcap_remoteact_accept()</a> to work.<p>
This function is useful *only* if you launch <a class="el" href="pcap-new_8c.html#a7">pcap_remoteact_accept()</a> inside a new thread, and you stops (not very gracefully) the thread (for example because the user changed idea, and it does no longer want to wait for an active connection). So, basically, the flow should be the following:<ul>
<li>launch a new thread</li><li>call the pcap_remoteact_accept</li><li>if this new thread is killed, call <a class="el" href="pcap-new_8c.html#a9">pcap_remoteact_cleanup()</a>.</li></ul>
<p>
This function has no effects in other cases.<p>
<dl compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l01249">1249</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="pcap-new.c::pcap_remoteact_close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_remoteact_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It drops an active connection (active mode only).
<p>
This function has been defined to allow the client dealing with the 'active mode'. This function closes an active connection that is still in place and it purges the host name from the 'activeHost' list. From this point on, the client will not have any connection with that host in place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>a string that keeps the host name of the host for which we want to close the active connection.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l01153">1153</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00132">activehosts::host</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="pcap-new.c::pcap_remoteact_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_remoteact_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sep</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the hostname of the host that have an active connection with us (active mode only).
<p>
This function has been defined to allow the client dealing with the 'active mode'. This function returns the list of hosts that are currently having an active connection with us. This function is useful in order to delete an active connection that is still in place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>hostlist:</em>&nbsp;</td><td>a user-allocated string that will keep the list of host that are currently connected with us.</td></tr>
    <tr><td valign=top><em>sep:</em>&nbsp;</td><td>the character that has to be sued as a separator between the hosts (',' for example).</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>size of the hostlist buffer.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l01285">1285</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00132">activehosts::host</a>, <a class="el" href="fileconf_8c-source.html#l00044">hostlist</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="remote-ext_8h-source.html#l00218">RPCAP_HOSTLIST_SIZE</a>, <a class="el" href="gencode_8c-source.html#l04255">size</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a1" doxytag="pcap-new.c::activeHosts"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structactivehosts.html">activehosts</a>* activeHosts
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Keeps a list of all the opened connections in the active mode.
<p>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00052">52</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-new_8c-source.html#l01285">pcap_remoteact_list()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="pcap-new.c::fakeerrbuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char fakeerrbuf[PCAP_ERRBUF_SIZE + 1]
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00048">48</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="pcap-new.c::sockmain"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SOCKET sockmain
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Keeps the main socket identifier when we want to accept a new remote connection (active mode only).
<p>
See the documentation of <a class="el" href="pcap-new_8c.html#a7">pcap_remoteact_accept()</a> and <a class="el" href="pcap-new_8c.html#a9">pcap_remoteact_cleanup()</a> for more details. 
<p>
Definition at line <a class="el" href="pcap-new_8c-source.html#l00060">60</a> of file <a class="el" href="pcap-new_8c-source.html">pcap-new.c</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
