<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pcap-remote.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pcap-remote.c</h1><a href="pcap-remote_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2002 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 
00034 <span class="preprocessor">#include &lt;string.h&gt;</span>     <span class="comment">// for strlen(), ...</span>
00035 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>     <span class="comment">// for malloc(), free(), ...</span>
00036 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>     <span class="comment">// for functions with variable number of arguments</span>
00037 <span class="preprocessor">#include &lt;errno.h&gt;</span>      <span class="comment">// for the errno variable</span>
00038 <span class="preprocessor">#include &lt;<a class="code" href="funcs_2pcap_8h.html">pcap.h</a>&gt;</span>
00039 <span class="preprocessor">#include &lt;pcap-int.h&gt;</span>
00040 <span class="preprocessor">#include &lt;<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>&gt;</span>
00041 <span class="preprocessor">#include &lt;<a class="code" href="sockutils_8h.html">sockutils.h</a>&gt;</span>
00042 
00043 
<a name="l00065"></a><a class="code" href="pcap-remote_8c.html#a0">00065</a> <span class="preprocessor">#define PCAP_STATS_STANDARD 0   </span>
<a name="l00066"></a><a class="code" href="pcap-remote_8c.html#a1">00066</a> <span class="preprocessor">#define PCAP_STATS_EX 1         </span>
00069 <span class="preprocessor"></span><span class="comment">/*</span>
00070 <span class="comment">    \brief Global variable; needed to keep the message due to an error that we want to discard.</span>
00071 <span class="comment">    </span>
00072 <span class="comment">    This can happen, for instance, because we already have an error message and we want to keep </span>
00073 <span class="comment">    the first one.</span>
00074 <span class="comment">*/</span>
<a name="l00075"></a><a class="code" href="pcap-remote_8c.html#a2">00075</a> <span class="keywordtype">char</span> <a class="code" href="sockutils_8c.html#a6">fakeerrbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];
00076 
00077 
<a name="l00079"></a><a class="code" href="pcap-remote_8c.html#a3">00079</a> <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *<a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
00080 
00081 
00082 <span class="comment">/****************************************************</span>
00083 <span class="comment"> *                                                  *</span>
00084 <span class="comment"> * Locally defined functions                        *</span>
00085 <span class="comment"> *                                                  *</span>
00086 <span class="comment"> ****************************************************/</span>
00087 <span class="keywordtype">void</span> <a class="code" href="group__remote__pri__func.html#a26">rpcap_thrdatamain_stream</a>(<span class="keywordtype">void</span> *ptr);
00088 <span class="keywordtype">void</span> <a class="code" href="group__remote__pri__func.html#a27">rpcap_thrdatamain_dgram</a>(<span class="keywordtype">void</span> *ptr);
00089 <span class="keywordtype">int</span> <a class="code" href="group__remote__pri__func.html#a32">rpcap_checkver</a>(SOCKET sock, <span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *header, <span class="keywordtype">char</span> *errbuf);
00090 <span class="keyword">struct </span><a class="code" href="structpcap__stat.html">pcap_stat</a> *<a class="code" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a>(<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct pcap_stat *ps, int mode);
00091 <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a8">pcap_pack_bpffilter</a>(pcap_t *fp, <span class="keywordtype">char</span> *sendbuf, <span class="keywordtype">int</span> *sendbufidx, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *prog);
00092 
00093 
00094 
00095 
00096 <span class="comment">/****************************************************</span>
00097 <span class="comment"> *                                                  *</span>
00098 <span class="comment"> * Function bodies                                 *</span>
00099 <span class="comment"> *                                                  *</span>
00100 <span class="comment"> ****************************************************/</span>
00101 
<a name="l00133"></a><a class="code" href="pcap-remote_8c.html#a9">00133</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a>(<span class="keyword">struct</span> sockaddr_storage *sockaddrin, <span class="keyword">struct</span> sockaddr_storage **sockaddrout, <span class="keywordtype">char</span> *errbuf)
00134 {
00135     <span class="comment">// Warning: we support only AF_INET and AF_INET6</span>
00136     <span class="keywordflow">if</span> ( ntohs(sockaddrin-&gt;ss_family) == AF_INET)
00137     {
00138     <span class="keyword">struct </span>sockaddr_in *sockaddr;
00139     
00140         sockaddr= (<span class="keyword">struct </span>sockaddr_in *) sockaddrin;
00141         sockaddr-&gt;sin_family= ntohs(sockaddr-&gt;sin_family);
00142         sockaddr-&gt;sin_port= ntohs(sockaddr-&gt;sin_port);
00143 
00144         (*sockaddrout)= (<span class="keyword">struct </span>sockaddr_storage *) malloc ( sizeof(struct sockaddr_in) );
00145         <span class="keywordflow">if</span> ( (*sockaddrout) == NULL)
00146         {
00147             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00148             <span class="keywordflow">return</span> -1;
00149         }
00150         memcpy( *sockaddrout, sockaddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in) );
00151         <span class="keywordflow">return</span> 0;
00152     }
00153     <span class="keywordflow">if</span> ( ntohs(sockaddrin-&gt;ss_family) == AF_INET6)
00154     {
00155     <span class="keyword">struct </span>sockaddr_in6 *sockaddr;
00156     
00157         sockaddr= (<span class="keyword">struct </span>sockaddr_in6 *) sockaddrin;
00158         sockaddr-&gt;sin6_family= ntohs(sockaddr-&gt;sin6_family);
00159         sockaddr-&gt;sin6_port= ntohs(sockaddr-&gt;sin6_port);
00160         sockaddr-&gt;sin6_flowinfo= ntohl(sockaddr-&gt;sin6_flowinfo);
00161         sockaddr-&gt;sin6_scope_id= ntohl(sockaddr-&gt;sin6_scope_id);
00162 
00163         (*sockaddrout)= (<span class="keyword">struct </span>sockaddr_storage *) malloc ( sizeof(struct sockaddr_in6) );
00164         <span class="keywordflow">if</span> ( (*sockaddrout) == NULL)
00165         {
00166             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00167             <span class="keywordflow">return</span> -1;
00168         }
00169         memcpy( *sockaddrout, sockaddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6) );
00170         <span class="keywordflow">return</span> 0;
00171     }
00172 
00173     <span class="comment">// It is neither AF_INET nor AF_INET6</span>
00174     *sockaddrout= NULL;
00175     <span class="keywordflow">return</span> 0;
00176 }
00177 
00178 
00179 
<a name="l00203"></a><a class="code" href="pcap-remote_8c.html#a10">00203</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a10">pcap_read_nocb_remote</a>(pcap_t *p, <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, u_char **pkt_data)
00204 {
00205 <span class="keywordtype">int</span> cc;
00206 <span class="keyword">register</span> u_char *ep, *bp;
00207 
00208     cc= p-&gt;cc;
00209     bp= p-&gt;bp;
00210 
00211     ep = bp + cc;
00212 
00213     <span class="keywordflow">if</span> (bp &lt; ep) 
00214     {
00215         <span class="keyword">register</span> <span class="keywordtype">int</span> caplen, hdrlen;
00216 again:
00217         caplen = ((<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *)bp)-&gt;caplen;
00218         hdrlen= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>);
00219             
00220         <span class="comment">/*</span>
00221 <span class="comment">         * XXX A bpf_hdr matches a pcap_pkthdr.</span>
00222 <span class="comment">         */</span>
00223         *pkt_header = (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *) bp;
00224         *pkt_data = bp + hdrlen;
00225         bp += BPF_WORDALIGN(caplen + hdrlen);
00226         
00227         p-&gt;bp = bp;
00228         p-&gt;cc = ep - bp;
00229         <span class="keywordflow">return</span> (1);
00230     }
00231     <span class="keywordflow">else</span>
00232     {
00233         p-&gt;cc = 0;
00234         <span class="comment">// If there are no packets, the read thread must be suspended</span>
00235 <span class="comment">// another horrible difference...</span>
00236 <span class="preprocessor">#ifdef linux</span>
00237 <span class="preprocessor"></span>        <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(p-&gt;md.timeout);
00238 <span class="preprocessor">#endif</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00240 <span class="preprocessor"></span>        <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(p-&gt;timeout);
00241 <span class="preprocessor">#endif</span>
00242 <span class="preprocessor"></span>        <span class="comment">// check if now if have data; otherwise returns</span>
00243         cc= p-&gt;cc;
00244         bp= p-&gt;bp;
00245 
00246         ep = bp + cc;
00247 
00248         <span class="keywordflow">if</span> (bp &lt; ep) 
00249             <span class="keywordflow">goto</span> again;
00250 
00251         <span class="keywordflow">return</span> (0);
00252     }
00253 }
00254 
00255 
<a name="l00270"></a><a class="code" href="pcap-remote_8c.html#a11">00270</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a11">pcap_read_remote</a>(pcap_t *p, <span class="keywordtype">int</span> cnt, pcap_handler callback, u_char *user)
00271 {
00272 <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header;
00273 u_char *pkt_data;
00274 <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00275 
00276     <span class="keywordflow">while</span> ( (++<a class="code" href="bpf__image_8c.html#a1">n</a> &lt;= cnt) || (cnt &lt; 0) )
00277     {
00278         <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a10">pcap_read_nocb_remote</a>(p, &amp;pkt_header, &amp;pkt_data) )
00279             (*callback)(user, pkt_header, pkt_data);
00280         <span class="keywordflow">else</span>
00281             <span class="keywordflow">return</span> <a class="code" href="bpf__image_8c.html#a1">n</a>;
00282     }
00283     <span class="keywordflow">return</span> <a class="code" href="bpf__image_8c.html#a1">n</a>;
00284 }
00285 
00286 
<a name="l00300"></a><a class="code" href="pcap-remote_8c.html#a12">00300</a> <span class="keywordtype">void</span> <a class="code" href="pcap-remote_8c.html#a12">pcap_close_remote</a>(pcap_t *fp)
00301 {
00302 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;     <span class="comment">// header of the RPCAP packet</span>
00303 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp;       <span class="comment">// temp var needed to scan the host list chain, to detect if we're in active mode</span>
00304 <span class="keywordtype">int</span> active= 0;                  <span class="comment">// active mode or not?</span>
00305 
00306     <span class="comment">// detect if we're in active mode</span>
00307     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
00308     <span class="keywordflow">while</span> (temp)
00309     {
00310         <span class="keywordflow">if</span> (temp-&gt;<a class="code" href="structactivehosts.html#m1">sockctrl</a> == fp-&gt;rmt_sockctrl)
00311         {
00312             active= 1;
00313             <span class="keywordflow">break</span>;
00314         }
00315         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
00316     }
00317 
00318     <span class="keywordflow">if</span> (!active)
00319     {
00320         <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( &amp;header, RPCAP_MSG_CLOSE, 0, 0);
00321 
00322         <span class="comment">// I don't check for errors, since I'm going to close everything</span>
00323         <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, sizeof (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), fakeerrbuf);
00324     }
00325     <span class="keywordflow">else</span>
00326     {
00327         <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( &amp;header, RPCAP_MSG_ENDCAP_REQ, 0, 0);
00328 
00329         <span class="comment">// I don't check for errors, since I'm going to close everything</span>
00330         <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, sizeof (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), fakeerrbuf);
00331 
00332         <span class="comment">// wait for the answer</span>
00333         <span class="comment">// Don't check what we got, since the present libpcap does not uses this pcap_t anymore</span>
00334         <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), fakeerrbuf);
00335 
00336         <span class="keywordflow">if</span> ( ntohl(header.plen) != 0)
00337             <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, ntohl(header.plen), fakeerrbuf);
00338     }
00339 
00340 
00341     <span class="keywordflow">if</span> (fp-&gt;rmt_threaddata)
00342     {
00343         pthread_cancel(fp-&gt;rmt_threaddata);
00344         fp-&gt;rmt_threaddata= 0;
00345     }
00346 
00347     <span class="keywordflow">if</span> (fp-&gt;rmt_sockdata)
00348     {
00349         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(fp-&gt;rmt_sockdata, fakeerrbuf);
00350         fp-&gt;rmt_sockdata= 0;
00351     }
00352 
00353     <span class="keywordflow">if</span> ( (!active) &amp;&amp; (fp-&gt;rmt_sockctrl) )
00354         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(fp-&gt;rmt_sockctrl, fakeerrbuf);
00355 
00356     fp-&gt;rmt_sockctrl= 0;
00357 
00358     <span class="comment">// To avoid inconsistencies in the number of sock_init()</span>
00359     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
00360 }
00361 
00362 
00363 
<a name="l00373"></a><a class="code" href="pcap-remote_8c.html#a13">00373</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a13">pcap_stats_remote</a>(pcap_t *p, <span class="keyword">struct</span> pcap_stat *ps)
00374 {
00375 <span class="keyword">struct </span>pcap_stat *retval;
00376 
00377     retval= <a class="code" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a>(p, ps, PCAP_STATS_STANDARD);
00378 
00379     <span class="keywordflow">if</span> (retval)
00380         <span class="keywordflow">return</span> 0;
00381     <span class="keywordflow">else</span>
00382         <span class="keywordflow">return</span> -1;
00383 }
00384 
00385 
00386 
<a name="l00396"></a><a class="code" href="pcap-remote_8c.html#a14">00396</a> <span class="keyword">struct </span>pcap_stat *<a class="code" href="group__remote__pri__func.html#a14">pcap_stats_ex_remote</a>(<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p)
00397 {
00398     <span class="comment">// '0' (third param) means 'standard pcap_stats()'</span>
00399     <span class="keywordflow">return</span> (<a class="code" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a>(p, &amp;(p-&gt;md.stat), PCAP_STATS_EX));
00400 }
00401 
00402 
00403 
<a name="l00434"></a><a class="code" href="group__remote__pri__func.html#a20">00434</a> <span class="keyword">struct </span>pcap_stat *<a class="code" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a>(<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct pcap_stat *ps, int mode)
00435 {
00436 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;         <span class="comment">// header of the RPCAP packet</span>
00437 <span class="keyword">struct </span><a class="code" href="structrpcap__stats.html">rpcap_stats</a> netstats;        <span class="comment">// statistics sent on the network</span>
00438 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread= 0;              <span class="comment">// number of bytes of the payload read from the socket</span>
00439 <span class="keywordtype">int</span> retval;                         <span class="comment">// temp variable which stores functions return value</span>
00440 
00441     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>(&amp;header, RPCAP_MSG_STATS_REQ, 0, 0);
00442 
00443     <span class="comment">// Send the PCAP_STATS command</span>
00444     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a14">sock_send</a>(p-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, sizeof (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), p-&gt;errbuf) )
00445         <span class="keywordflow">goto</span> error;
00446 
00447     <span class="comment">// Receive the RPCAP stats reply message</span>
00448     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(p-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), p-&gt;errbuf) == -1)
00449         <span class="keywordflow">goto</span> error;
00450 
00451     <span class="comment">// Checks if the message is correct</span>
00452     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(p-&gt;errbuf, p-&gt;rmt_sockctrl, &amp;header, RPCAP_MSG_STATS_REPLY, RPCAP_MSG_ERROR, 0);
00453 
00454     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a29">RPCAP_MSG_STATS_REPLY</a>)        <span class="comment">// the message is not the one expected</span>
00455     {
00456         <span class="keywordflow">switch</span> (retval)
00457         {
00458             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error</span>
00459             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint send a message that is not allowed here</span>
00460             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00461                 <span class="keywordflow">goto</span> error;
00462 
00463             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:       <span class="comment">// The other endpoint reported an error</span>
00464                 <span class="comment">// Update nread, since the rpcap_checkmsg() already purged the buffer</span>
00465                 nread = ntohl(header.plen);
00466 
00467                 <span class="comment">// Do nothing; just exit; the error code is already into the errbuf</span>
00468                 <span class="keywordflow">goto</span> error;
00469 
00470             <span class="keywordflow">default</span>:
00471             {
00472                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Internal error"</span>);
00473                 <span class="keywordflow">goto</span> error;
00474             };
00475         }
00476     }
00477 
00478     <span class="keywordflow">if</span> ( (nread= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(p-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;netstats, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__stats.html">rpcap_stats</a>), p-&gt;errbuf)) == -1)
00479         <span class="keywordflow">goto</span> error;
00480 
00481     <span class="keywordflow">if</span> (mode == <a class="code" href="pcap-remote_8c.html#a0">PCAP_STATS_STANDARD</a>)
00482     {
00483         ps-&gt;<a class="code" href="structpcap__stat.html#m1">ps_drop</a>= ntohl(netstats.krnldrop);
00484         ps-&gt;<a class="code" href="structpcap__stat.html#m2">ps_ifdrop</a>= ntohl(netstats.ifdrop);
00485         ps-&gt;<a class="code" href="structpcap__stat.html#m0">ps_recv</a>= ntohl(netstats.ifrecv);
00486     }
00487     <span class="keywordflow">else</span>
00488     {
00489         ps-&gt;ps_capt= p-&gt;md.TotCapt;
00490         ps-&gt;<a class="code" href="structpcap__stat.html#m1">ps_drop</a>= ntohl(netstats.krnldrop);
00491         ps-&gt;<a class="code" href="structpcap__stat.html#m2">ps_ifdrop</a>= ntohl(netstats.ifdrop);
00492         ps-&gt;ps_netdrop= p-&gt;md.TotNetDrops;
00493         ps-&gt;<a class="code" href="structpcap__stat.html#m0">ps_recv</a>= ntohl(netstats.ifrecv);
00494         ps-&gt;ps_sent= ntohl(netstats.svrcapt);
00495     }
00496 
00497     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
00498     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00499     {
00500         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(p-&gt;rmt_sockctrl, ntohl(header.plen) - nread, fakeerrbuf) == 1)
00501             <span class="keywordflow">goto</span> error;
00502     }
00503 
00504     <span class="keywordflow">return</span> ps;
00505 
00506 error:
00507     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00508         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(p-&gt;rmt_sockctrl, ntohl(header.plen) - nread, fakeerrbuf);
00509 
00510     <span class="keywordflow">return</span> NULL;
00511 }
00512 
00513 
00514 
00515 
<a name="l00554"></a><a class="code" href="pcap-remote_8c.html#a15">00554</a> <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *<a class="code" href="pcap-remote_8c.html#a15">pcap_opensource_remote</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *source, <span class="keyword">struct</span> <a class="code" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <span class="keywordtype">char</span> *errbuf)
00555 {
00556 <span class="keywordtype">char</span> <a class="code" href="wpcap__remote_8htm.html#a3">host</a>[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>], ctrlport[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>], iface[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];
00557 
00558 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];<span class="comment">// temporary buffer in which data to be sent is buffered</span>
00559 <span class="keywordtype">int</span> sendbufidx= 0;              <span class="comment">// index which keeps the number of bytes currently buffered</span>
00560 pthread_t threaddata= 0;        <span class="comment">// handle to the receiving thread</span>
00561 <span class="keyword">struct </span>pcap *fp= NULL;          <span class="comment">// pcap_t main variable</span>
00562 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread= 0;          <span class="comment">// number of bytes of the payload read from the socket</span>
00563 <span class="keywordtype">int</span> retval;                     <span class="comment">// store the return value of the functions</span>
00564 <span class="keywordtype">int</span> active= 0;                      <span class="comment">// '1' if we're in active mode</span>
00565 
00566 <span class="comment">// socket-related variables</span>
00567 <span class="keyword">struct </span>addrinfo hints;          <span class="comment">// temp, needed to open a socket connection</span>
00568 <span class="keyword">struct </span>addrinfo *addrinfo;      <span class="comment">// temp, needed to open a socket connection</span>
00569 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockctrl= 0;             <span class="comment">// socket descriptor of the control connection</span>
00570 
00571 <span class="comment">// RPCAP-related variables</span>
00572 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;         <span class="comment">// header of the RPCAP packet</span>
00573 <span class="keyword">struct </span><a class="code" href="structrpcap__openreply.html">rpcap_openreply</a> openreply;   <span class="comment">// open reply message</span>
00574 
00575 
00576     <span class="comment">// determine the type of the source (NULL, file, local, remote)</span>
00577     <span class="comment">// You must have a valid source string even if we're in active mode, because otherwise</span>
00578     <span class="comment">// the call to the following funciton will fail.</span>
00579     <span class="keywordflow">if</span> (<a class="code" href="pcap-new_8c.html#a5">pcap_parsesrcstr</a>(source, &amp;retval, host, ctrlport, iface, errbuf) == -1)
00580         <span class="keywordflow">return</span> NULL;
00581 
00582     <span class="keywordflow">if</span> ( retval != <a class="code" href="group__remote__struct.html#a3">PCAP_SRC_IFREMOTE</a>)
00583     {
00584         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"This function is able to open only remote interfaces"</span>);
00585         <span class="keywordflow">return</span> NULL;
00586     }
00587 
00588     addrinfo= NULL;
00589 
00590     <span class="comment">// Warning: this call can be the first one called by the user.</span>
00591     <span class="comment">// For this reason, we have to initialize the WinSock support.</span>
00592     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a9">sock_init</a>(errbuf) == -1)
00593         <span class="keywordflow">return</span> NULL;
00594 
00595     retval= <a class="code" href="pcap-remote_8c.html#a24">rpcap_remoteact_getsock</a>(host, errbuf);
00596 
00597     <span class="keywordflow">if</span> (retval == -1)
00598         <span class="keywordflow">return</span> NULL;
00599 
00600     <span class="comment">// The capturing machine is in active mode</span>
00601     <span class="keywordflow">if</span> (retval)
00602     {
00603         sockctrl= retval;
00604         active= 1;
00605     }
00606     <span class="keywordflow">else</span>
00607     {
00608         memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo) );
00609         hints.ai_family = PF_UNSPEC;
00610         hints.ai_socktype = SOCK_STREAM;
00611 
00612         <span class="keywordflow">if</span> ( (ctrlport == NULL) || (ctrlport[0] == 0) )
00613         {
00614             <span class="comment">// the user chose not to specify the port</span>
00615             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(host, RPCAP_DEFAULT_NETPORT, &amp;hints, &amp;addrinfo, errbuf) == -1)
00616                 <span class="keywordflow">return</span> NULL;
00617         }
00618         <span class="keywordflow">else</span>
00619         {
00620             <span class="comment">// the user chose not to specify the port</span>
00621             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(host, ctrlport, &amp;hints, &amp;addrinfo, errbuf) == -1)
00622                 <span class="keywordflow">return</span> NULL;
00623         }
00624 
00625         <span class="keywordflow">if</span> ( (sockctrl= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_CLIENT, 0, errbuf)) == -1)
00626             <span class="keywordflow">goto</span> error;
00627 
00628         freeaddrinfo(addrinfo);
00629         addrinfo= NULL;
00630 
00631         <span class="keywordflow">if</span> ( <a class="code" href="pcap-remote_8c.html#a21">rpcap_sendauth</a>(sockctrl, auth, errbuf) == -1)
00632             <span class="keywordflow">goto</span> error;
00633     }
00634 
00635 
00636     <span class="comment">// Now it's time to start playing with the RPCAP protocol</span>
00637     <span class="comment">// RPCAP open command: create the request message</span>
00638     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) )
00639         <span class="keywordflow">goto</span> error;
00640 
00641     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_OPEN_REQ, 0, strlen(iface) );
00642 
00643     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(iface, strlen(iface), sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) )
00644         <span class="keywordflow">goto</span> error;
00645 
00646     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sockctrl, sendbuf, sendbufidx, errbuf) )
00647         <span class="keywordflow">goto</span> error;
00648 
00649     <span class="comment">// Receive the RPCAP open reply message</span>
00650     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), errbuf) == -1)
00651         <span class="keywordflow">goto</span> error;
00652 
00653     <span class="comment">// Checks if the message is correct</span>
00654     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, sockctrl, &amp;header, RPCAP_MSG_OPEN_REPLY, RPCAP_MSG_ERROR, 0);
00655 
00656     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a25">RPCAP_MSG_OPEN_REPLY</a>)     <span class="comment">// the message is not the one expected</span>
00657     {
00658         <span class="keywordflow">switch</span> (retval)
00659         {
00660             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error</span>
00661             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint send a message that is not allowed here</span>
00662             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00663                 <span class="keywordflow">goto</span> error;
00664 
00665             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:       <span class="comment">// The other endpoint reported an error</span>
00666                 <span class="comment">// Update nread, since the rpcap_checkmsg() already purged the buffer</span>
00667                 nread = ntohl(header.plen);
00668                 <span class="comment">// Do nothing; just exit; the error code is already into the errbuf</span>
00669                 <span class="keywordflow">goto</span> error;
00670 
00671             <span class="keywordflow">default</span>:
00672             {
00673                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Internal error"</span>);
00674                 <span class="keywordflow">goto</span> error;
00675             };
00676         }
00677     }
00678 
00679 
00680     <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sockctrl, (<span class="keywordtype">char</span> *) &amp;openreply, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__openreply.html">rpcap_openreply</a>), errbuf)) == -1)
00681         <span class="keywordflow">goto</span> error;
00682 
00683     <span class="comment">// Allocates a pcap_t struct for this end of the connection</span>
00684     fp = (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *) malloc( <span class="keyword">sizeof</span>(pcap_t) );
00685     <span class="keywordflow">if</span> (fp == NULL)
00686     {
00687         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00688         <span class="keywordflow">goto</span> error;
00689     }
00690 
00691     memset(fp, 0, <span class="keyword">sizeof</span>(pcap_t));
00692 
00693     <span class="comment">// Set proper fields into the pcap_t struct</span>
00694     fp-&gt;linktype= ntohl(openreply.linktype);
00695     fp-&gt;tzoff= ntohl(openreply.tzoff);
00696     fp-&gt;rmt_sockctrl= sockctrl;
00697     fp-&gt;rmt_clientside= 1;
00698 
00699 
00700     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
00701     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00702     {
00703         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, ntohl(header.plen) - nread, fakeerrbuf) == 1)
00704             <span class="keywordflow">goto</span> error;
00705     }
00706     <span class="keywordflow">return</span> fp;
00707 
00708 error:
00709 <span class="comment">// When the connection has been established, we have to close it. So, at the</span>
00710 <span class="comment">// beginning of this function, if an error occur we return immediately with</span>
00711 <span class="comment">// a return NULL; when the connection is established, we have to come here </span>
00712 <span class="comment">// ('goto error;') in order to close everything properly.</span>
00713 
00714     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
00715     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
00716         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sockctrl, ntohl(header.plen) - nread, fakeerrbuf);
00717 
00718     <span class="keywordflow">if</span> (addrinfo)
00719         freeaddrinfo(addrinfo);
00720 
00721     <span class="keywordflow">if</span> (!active)
00722         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
00723 
00724     <span class="keywordflow">if</span> (fp)
00725     {
00726         <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
00727         fp= NULL;
00728     }
00729 
00730     <span class="keywordflow">return</span> NULL;
00731 }
00732 
00733 
00734 
00735 
00736 
00737 
00738 
<a name="l00761"></a><a class="code" href="pcap-remote_8c.html#a16">00761</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a16">pcap_startcapture_remote</a>(pcap_t *fp)
00762 {
00763 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];<span class="comment">// temporary buffer in which data to be sent is buffered</span>
00764 <span class="keywordtype">int</span> sendbufidx= 0;              <span class="comment">// index which keeps the number of bytes currently buffered</span>
00765 <span class="keywordtype">char</span> portdata[<a class="code" href="group__remote__struct.html#a0">PCAP_BUF_SIZE</a>];   <span class="comment">// temp variable needed to keep the network port for the the data connection</span>
00766 pthread_t threaddata= 0;        <span class="comment">// handle to the receiving thread</span>
00767 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread= 0;          <span class="comment">// number of bytes of the payload read from the socket</span>
00768 <span class="keywordtype">int</span> retval;                     <span class="comment">// store the return value of the functions</span>
00769 <span class="keywordtype">int</span> active= 0;                  <span class="comment">// '1' if we're in active mode</span>
00770 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp;       <span class="comment">// temp var needed to scan the host list chain, to detect if we're in active mode</span>
00771 <span class="keywordtype">char</span> <a class="code" href="wpcap__remote_8htm.html#a3">host</a>[INET6_ADDRSTRLEN + 1];    <span class="comment">// numeric name of the other host</span>
00772 
00773 <span class="comment">// socket-related variables</span>
00774 <span class="keyword">struct </span>addrinfo hints;          <span class="comment">// temp, needed to open a socket connection</span>
00775 <span class="keyword">struct </span>addrinfo *addrinfo;      <span class="comment">// temp, needed to open a socket connection</span>
00776 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockdata= 0;             <span class="comment">// socket descriptor of the data connection</span>
00777 <span class="keyword">struct </span>sockaddr_storage saddr;  <span class="comment">// temp, needed to retrieve the network data port chosen on the local machine</span>
00778 socklen_t saddrlen;             <span class="comment">// temp, needed to retrieve the network data port chosen on the local machine</span>
00779 <span class="keywordtype">int</span> ai_family;                  <span class="comment">// temp, keeps the address family used by the control connection</span>
00780 
00781 <span class="comment">// RPCAP-related variables</span>
00782 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;                 <span class="comment">// header of the RPCAP packet</span>
00783 <span class="keyword">struct </span><a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a> *startcapreq;      <span class="comment">// start capture request message</span>
00784 <span class="keyword">struct </span><a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a> startcapreply;   <span class="comment">// start capture reply message</span>
00785 
00786 
00787     <span class="comment">// detect if we're in active mode</span>
00788     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
00789     <span class="keywordflow">while</span> (temp)
00790     {
00791         <span class="keywordflow">if</span> (temp-&gt;sockctrl == fp-&gt;rmt_sockctrl)
00792         {
00793             active= 1;
00794             <span class="keywordflow">break</span>;
00795         }
00796         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
00797     }
00798 
00799     addrinfo= NULL;
00800 
00801     <span class="comment">// Gets the complete sockaddr structure used in the ctrl connection</span>
00802     <span class="comment">// This is needed to get the address family of the control socket</span>
00803     <span class="comment">// Tip: I cannot save the ai_family of the ctrl sock in the pcap_t struct,</span>
00804     <span class="comment">// since the ctrl socket can already be open in case of active mode;</span>
00805     <span class="comment">// so I would have to call getpeername() anyway</span>
00806     saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
00807     <span class="keywordflow">if</span> (getpeername(fp-&gt;rmt_sockctrl, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen) == -1)
00808     {
00809         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getsockname(): "</span>, fp-&gt;errbuf, PCAP_ERRBUF_SIZE);
00810         <span class="keywordflow">goto</span> error;
00811     }
00812     ai_family= ((<span class="keyword">struct </span>sockaddr_storage *) &amp;saddr)-&gt;ss_family;
00813 
00814     <span class="comment">// Get the numeric address of the remote host we are connected to</span>
00815     <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;saddr, saddrlen, host, 
00816             <span class="keyword">sizeof</span>(host), NULL, 0, NI_NUMERICHOST) )
00817     {
00818         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, fp-&gt;errbuf, PCAP_ERRBUF_SIZE);
00819         <span class="keywordflow">goto</span> error;
00820     }
00821 
00822     <span class="comment">/*</span>
00823 <span class="comment">        Data connection is opened by the server toward the client if:</span>
00824 <span class="comment">        - we're using TCP, and the user wants us to be in active mode</span>
00825 <span class="comment">        - we're using UDP</span>
00826 <span class="comment">    */</span>
00827     <span class="keywordflow">if</span> ( (active) || (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) )
00828     {
00829         <span class="comment">// We have to create a new socket to receive packets</span>
00830         <span class="comment">// We have to do that immediately, since we have to tell the other </span>
00831         <span class="comment">// end which network port we picked up</span>
00832         memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo) );
00833         <span class="comment">// TEMP addrinfo is NULL in case of active</span>
00834         hints.ai_family = ai_family;    <span class="comment">// Use the same address family of the control socket</span>
00835         hints.ai_socktype = (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) ? SOCK_DGRAM : SOCK_STREAM;
00836         hints.ai_flags = AI_PASSIVE;    <span class="comment">// Data connection is opened by the server toward the client</span>
00837 
00838         <span class="comment">// Let's the server pick up a free network port for us</span>
00839         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(NULL, <span class="stringliteral">"0"</span>, &amp;hints, &amp;addrinfo, fp-&gt;errbuf) == -1)
00840             <span class="keywordflow">goto</span> error;
00841 
00842         <span class="keywordflow">if</span> ( (sockdata= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_SERVER, 1 <span class="comment">/* max 1 connection in queue */</span>, fp-&gt;errbuf)) == -1)
00843             <span class="keywordflow">goto</span> error;
00844 
00845         <span class="comment">// addrinfo is no longer used</span>
00846         freeaddrinfo(addrinfo);
00847         addrinfo= NULL;
00848 
00849         <span class="comment">// get the complete sockaddr structure used in the data connection</span>
00850         saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
00851         <span class="keywordflow">if</span> (getsockname(sockdata, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen) == -1)
00852         {
00853             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getsockname(): "</span>, fp-&gt;errbuf, PCAP_ERRBUF_SIZE);
00854             <span class="keywordflow">goto</span> error;
00855         }
00856 
00857         <span class="comment">// Get the local port the system picked up</span>
00858         <span class="keywordflow">if</span> (getnameinfo( (<span class="keyword">struct</span> sockaddr *) &amp;saddr, saddrlen, NULL, 
00859                 0, portdata, <span class="keyword">sizeof</span>(portdata), NI_NUMERICSERV) )
00860         {
00861             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"getnameinfo(): "</span>, fp-&gt;errbuf, PCAP_ERRBUF_SIZE);
00862             <span class="keywordflow">goto</span> error;
00863         }
00864     }
00865 
00866     <span class="comment">// Now it's time to start playing with the RPCAP protocol</span>
00867     <span class="comment">// RPCAP start ca[ture command: create the request message</span>
00868     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) )
00869         <span class="keywordflow">goto</span> error;
00870 
00871     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_STARTCAP_REQ, 0,
00872         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a>) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filter.html">rpcap_filter</a>) + fp-&gt;fcode.bf_len * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a>) );
00873 
00874     <span class="comment">// Fill the structure needed to open an adapter remotely</span>
00875     startcapreq= (<span class="keyword">struct </span><a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a> *) &amp;sendbuf[sendbufidx];
00876 
00877     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreq.html">rpcap_startcapreq</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) )
00878         <span class="keywordflow">goto</span> error;
00879 
00880     memset(startcapreq, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_startcapreq) );
00881 
00882     <span class="comment">// By default, apply half the timeout on one side, half of the other</span>
00883 <span class="preprocessor">#ifdef linux</span>
00884 <span class="preprocessor"></span>    fp-&gt;md.timeout= fp-&gt;md.timeout/2;
00885     startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m1">read_timeout</a>= htonl(fp-&gt;md.timeout);
00886 <span class="preprocessor">#endif</span>
00887 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00888 <span class="preprocessor"></span>    fp-&gt;timeout= fp-&gt;timeout/2;
00889     startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m1">read_timeout</a>= htonl(fp-&gt;timeout);
00890 <span class="preprocessor">#endif</span>
00891 <span class="preprocessor"></span>
00892     <span class="comment">// portdata on the openreq is meaningful only if we're in active mode</span>
00893     <span class="keywordflow">if</span> ( (active) || (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) )
00894     {
00895         sscanf(portdata, <span class="stringliteral">"%d"</span>, &amp;(startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m3">portdata</a>));
00896         startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m3">portdata</a>= htons(startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m3">portdata</a>);
00897     }
00898 
00899     startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m0">snaplen</a>= htonl(fp-&gt;snapshot);
00900     startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>= 0;
00901     <span class="keywordflow">if</span> (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a6">PCAP_OPENFLAG_PROMISCUOUS</a>)
00902         startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>|= <a class="code" href="group__remote__pri__struct.html#a31">RPCAP_STARTCAPREQ_FLAG_PROMISC</a>;
00903     <span class="keywordflow">if</span> (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>)
00904         startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>|= <a class="code" href="group__remote__pri__struct.html#a32">RPCAP_STARTCAPREQ_FLAG_DGRAM</a>;
00905     <span class="keywordflow">if</span> (active)
00906         startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>|= <a class="code" href="group__remote__pri__struct.html#a33">RPCAP_STARTCAPREQ_FLAG_SERVEROPEN</a>;
00907 
00908     startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>= htons(startcapreq-&gt;<a class="code" href="structrpcap__startcapreq.html#m2">flags</a>);
00909 
00910     <span class="comment">// Pack the capture filter</span>
00911     <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a8">pcap_pack_bpffilter</a>(fp, &amp;sendbuf[sendbufidx], &amp;sendbufidx, &amp;fp-&gt;fcode) )
00912         <span class="keywordflow">goto</span> error;
00913 
00914     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, sendbuf, sendbufidx, fp-&gt;errbuf) )
00915         <span class="keywordflow">goto</span> error;
00916 
00917 
00918     <span class="comment">// Receive the RPCAP start capture reply message</span>
00919     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), fp-&gt;errbuf) == -1)
00920         <span class="keywordflow">goto</span> error;
00921 
00922     <span class="comment">// Checks if the message is correct</span>
00923     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(fp-&gt;errbuf, fp-&gt;rmt_sockctrl, &amp;header, RPCAP_MSG_STARTCAP_REPLY, RPCAP_MSG_ERROR, 0);
00924 
00925     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a26">RPCAP_MSG_STARTCAP_REPLY</a>)     <span class="comment">// the message is not the one expected</span>
00926     {
00927         <span class="keywordflow">switch</span> (retval)
00928         {
00929             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error</span>
00930             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint send a message that is not allowed here</span>
00931             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
00932                 <span class="keywordflow">goto</span> error;
00933 
00934             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:       <span class="comment">// The other endpoint reported an error</span>
00935                 <span class="comment">// Update nread, since the rpcap_checkmsg() already purged the buffer</span>
00936                 nread = ntohl(header.plen);
00937                 <span class="comment">// Do nothing; just exit; the error code is already into the errbuf</span>
00938                 <span class="keywordflow">goto</span> error;
00939 
00940             <span class="keywordflow">default</span>:
00941             {
00942                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(fp-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Internal error"</span>);
00943                 <span class="keywordflow">goto</span> error;
00944             };
00945         }
00946     }
00947 
00948 
00949     <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;startcapreply, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__startcapreply.html">rpcap_startcapreply</a>), fp-&gt;errbuf)) == -1)
00950         <span class="keywordflow">goto</span> error;
00951 
00952     <span class="comment">// Data connection is opened by the client toward the server</span>
00953     <span class="comment">// This happens because (a) we're not in active mode, and (b) we're not using UDP</span>
00954     <span class="comment">// So, let's start the connection</span>
00955     <span class="keywordflow">if</span> ( (!active) &amp;&amp; !(fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) )
00956     {
00957         memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo) );
00958         hints.ai_family = ai_family;        <span class="comment">// Use the same address family of the control socket</span>
00959         hints.ai_socktype = (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) ? SOCK_DGRAM : SOCK_STREAM;
00960 
00961         sprintf(portdata, <span class="stringliteral">"%d"</span>, ntohs(startcapreply.portdata) );
00962 
00963         <span class="comment">// Let's the server pick up a free network port for us</span>
00964         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(host, portdata, &amp;hints, &amp;addrinfo, fp-&gt;errbuf) == -1)
00965             <span class="keywordflow">goto</span> error;
00966 
00967         <span class="keywordflow">if</span> ( (sockdata= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_CLIENT, 0, fp-&gt;errbuf)) == -1)
00968             <span class="keywordflow">goto</span> error;
00969 
00970         <span class="comment">// addrinfo is no longer used</span>
00971         freeaddrinfo(addrinfo);
00972         addrinfo= NULL;
00973     }
00974 
00975 
00976     <span class="comment">// Allocates WinPcap/libpcap user buffer</span>
00977     <span class="comment">// It has the same size of the one used on the other side of the connection</span>
00978     fp-&gt;bufsize= ntohl(startcapreply.bufsize);
00979 
00980     <span class="comment">/*</span>
00981 <span class="comment">        Warning: on some kernels (e.g. linux), the size of the user buffer does not take</span>
00982 <span class="comment">        into account the pcap_header and such, and it is set equal to the snaplen.</span>
00983 <span class="comment">        In our view, this is wrong (the meaning of the bufsize becames a bit strange).</span>
00984 <span class="comment">        So, in our view, bufsize is the whole size of the user buffer.</span>
00985 <span class="comment">        In case the bufsize returned is too small, adjust it accordingly.</span>
00986 <span class="comment">    */</span>
00987     <span class="keywordflow">if</span> (fp-&gt;bufsize &lt;= fp-&gt;snapshot)
00988         fp-&gt;bufsize+= <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>);
00989 
00990     fp-&gt;buffer = (u_char *) malloc(fp-&gt;bufsize);
00991     <span class="keywordflow">if</span> (fp-&gt;buffer == NULL)
00992     {
00993         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(fp-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc: %s"</span>, <a class="code" href="group__wpcap__fn.html#a28">pcap_strerror</a>(errno));
00994         <span class="keywordflow">goto</span> error;
00995     }
00996 
00997     <span class="comment">// The server is trying to connect to me; so it have to block on an accept() call</span>
00998     <span class="comment">// However, if the data connection is UDP, I don't have to call accept()</span>
00999     <span class="keywordflow">if</span> ( (active) &amp;&amp; !(fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>) )
01000     {
01001     <a class="code" href="group__remote__struct.html#a12">SOCKET</a> socktemp;    <span class="comment">// We need another socket, since we're going to accept() a connection</span>
01002 
01003         <span class="comment">// Connection creation</span>
01004         saddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
01005 
01006         socktemp= accept(sockdata, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, &amp;saddrlen);
01007         
01008         <span class="keywordflow">if</span> (socktemp == -1)
01009         {
01010             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"accept(): "</span>, fp-&gt;errbuf, PCAP_ERRBUF_SIZE);
01011             <span class="keywordflow">goto</span> error;
01012         }
01013 
01014         <span class="comment">// Now that I accepted the connection, the server socket is no longer needed</span>
01015         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockdata, fp-&gt;errbuf);
01016         sockdata= socktemp;
01017     }
01018 
01019     fp-&gt;rmt_sockdata= sockdata;
01020 
01021     <span class="comment">// Now we have to create a new thread to receive packets</span>
01022     <span class="keywordflow">if</span> (fp-&gt;rmt_flags &amp; <a class="code" href="group__remote__struct.html#a8">PCAP_OPENFLAG_UDP_DP</a>)
01023     {
01024         <span class="keywordflow">if</span> ( pthread_create( &amp;threaddata, NULL, (<span class="keywordtype">void</span> *) &amp;rpcap_thrdatamain_dgram, (<span class="keywordtype">void</span> *) fp) )
01025         {
01026             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(fp-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error creating the data thread"</span>);
01027             <span class="keywordflow">goto</span> error;
01028         }
01029     }
01030     <span class="keywordflow">else</span>
01031     {
01032         <span class="keywordflow">if</span> ( pthread_create( &amp;threaddata, NULL, (<span class="keywordtype">void</span> *) &amp;rpcap_thrdatamain_stream, (<span class="keywordtype">void</span> *) fp) )
01033         {
01034             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(fp-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error creating the data thread"</span>);
01035             <span class="keywordflow">goto</span> error;
01036         }
01037     }
01038 
01039     fp-&gt;rmt_threaddata= threaddata;
01040 
01041     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
01042     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
01043     {
01044         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, ntohl(header.plen) - nread, fakeerrbuf) == 1)
01045             <span class="keywordflow">goto</span> error;
01046     }
01047     <span class="keywordflow">return</span> 0;
01048 
01049 error:
01050 <span class="comment">// When the connection has been established, we have to close it. So, at the</span>
01051 <span class="comment">// beginning of this function, if an error occur we return immediately with</span>
01052 <span class="comment">// a return NULL; when the connection is established, we have to come here </span>
01053 <span class="comment">// ('goto error;') in order to close everything properly.</span>
01054 
01055     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
01056     <span class="keywordflow">if</span> (nread != ntohl(header.plen))
01057         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, ntohl(header.plen) - nread, fakeerrbuf);
01058 
01059     <span class="keywordflow">if</span> (threaddata)
01060         pthread_cancel(threaddata);
01061 
01062     <span class="keywordflow">if</span> ((sockdata) &amp;&amp; (sockdata != -1))     <span class="comment">// we can be here because sockdata said 'error'</span>
01063         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockdata, fakeerrbuf);
01064 
01065     <span class="keywordflow">if</span> (!active)
01066         <a class="code" href="sockutils_8c.html#a12">sock_close</a>(fp-&gt;rmt_sockctrl, fakeerrbuf);
01067 
01068     <span class="keywordflow">if</span> (fp)
01069     {
01070         <a class="code" href="pcap_8c.html#a30">pcap_close</a>(fp);
01071         fp= NULL;
01072     }
01073 
01074     <span class="keywordflow">return</span> -1;
01075 }
01076 
01077 
01078 
01079 
01080 
<a name="l01104"></a><a class="code" href="pcap-remote_8c.html#a8">01104</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a8">pcap_pack_bpffilter</a>(pcap_t *fp, <span class="keywordtype">char</span> *sendbuf, <span class="keywordtype">int</span> *sendbufidx, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *prog)
01105 {
01106 <span class="keyword">struct </span><a class="code" href="structrpcap__filter.html">rpcap_filter</a> *filter;
01107 <span class="keyword">struct </span><a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a> *insn;
01108 <span class="keyword">struct </span><a class="code" href="structbpf__insn.html">bpf_insn</a> *bf_insn;
01109 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
01110 
01111     filter= (<span class="keyword">struct </span><a class="code" href="structrpcap__filter.html">rpcap_filter</a> *) sendbuf;
01112 
01113     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filter.html">rpcap_filter</a>), NULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) )
01114         <span class="keywordflow">return</span> -1;
01115 
01116     filter-&gt;<a class="code" href="structrpcap__filter.html#m0">filtertype</a>= htons(RPCAP_UPDATEFILTER_BPF);
01117     filter-&gt;<a class="code" href="structrpcap__filter.html#m2">nitems</a>= htonl( (int32) prog-&gt;<a class="code" href="structbpf__program.html#m0">bf_len</a>);
01118 
01119     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, prog-&gt;<a class="code" href="structbpf__program.html#m0">bf_len</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a>), NULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) )
01120         <span class="keywordflow">return</span> -1;
01121     
01122     insn= (<span class="keyword">struct </span>rpcap_filterbpf_insn *) (filter + 1);
01123     bf_insn= prog-&gt;<a class="code" href="structbpf__program.html#m1">bf_insns</a>;
01124 
01125     <span class="keywordflow">for</span> (i= 0; i &lt; prog-&gt;<a class="code" href="structbpf__program.html#m0">bf_len</a>; i++)
01126     {
01127         insn-&gt;<a class="code" href="structrpcap__filterbpf__insn.html#m0">code</a>= htons(bf_insn-&gt;code);
01128         insn-&gt;<a class="code" href="structrpcap__filterbpf__insn.html#m2">jf</a>= bf_insn-&gt;jf;
01129         insn-&gt;<a class="code" href="structrpcap__filterbpf__insn.html#m1">jt</a>= bf_insn-&gt;jt;
01130         insn-&gt;<a class="code" href="structrpcap__filterbpf__insn.html#m3">k</a>= htonl(bf_insn-&gt;k);
01131 
01132         insn++;
01133         bf_insn++;
01134     }
01135     <span class="keywordflow">return</span> 0;
01136 }
01137 
01138 
01139 
01140 
01141 
<a name="l01161"></a><a class="code" href="pcap-remote_8c.html#a17">01161</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a17">pcap_updatefilter_remote</a>(pcap_t *fp, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *prog)
01162 {
01163 <span class="keywordtype">int</span> retval;                     <span class="comment">// general variable used to keep the return value of other functions</span>
01164 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];<span class="comment">// temporary buffer in which data to be sent is buffered</span>
01165 <span class="keywordtype">int</span> sendbufidx= 0;              <span class="comment">// index which keeps the number of bytes currently buffered</span>
01166 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;     <span class="comment">// To keep the reply message</span>
01167 
01168 
01169     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gt;errbuf) )
01170         <span class="keywordflow">return</span> -1;
01171 
01172     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_UPDATEFILTER_REQ, 0,
01173         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filter.html">rpcap_filter</a>) + prog-&gt;<a class="code" href="structbpf__program.html#m0">bf_len</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__filterbpf__insn.html">rpcap_filterbpf_insn</a>));
01174 
01175     <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a8">pcap_pack_bpffilter</a>(fp, &amp;sendbuf[sendbufidx], &amp;sendbufidx, prog) )
01176         <span class="keywordflow">return</span> -1;
01177 
01178     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(fp-&gt;rmt_sockctrl, sendbuf, sendbufidx, fp-&gt;errbuf) )
01179         <span class="keywordflow">return</span> -1;
01180 
01181     <span class="comment">// Waits for the answer</span>
01182     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockctrl, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), fp-&gt;errbuf) == -1)
01183         <span class="keywordflow">return</span> -1;
01184 
01185     <span class="comment">// Checks if the message is correct</span>
01186     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(fp-&gt;errbuf, fp-&gt;rmt_sockctrl, &amp;header, RPCAP_MSG_UPDATEFILTER_REPLY, 0);
01187 
01188     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a27">RPCAP_MSG_UPDATEFILTER_REPLY</a>)     <span class="comment">// the message is not the one expected</span>
01189     {
01190         <span class="keywordflow">switch</span> (retval)
01191         {
01192             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error</span>
01193             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint sent a message that is not allowed here</span>
01194             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
01195                 <span class="comment">// Do nothing; just exit from here; the error code is already into the errbuf</span>
01196                 <span class="keywordflow">return</span> -1;
01197 
01198             <span class="keywordflow">default</span>:
01199             {
01200                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error"</span>, 0);
01201                 <span class="keywordflow">return</span> -1;
01202             };
01203         }
01204     }
01205 
01206     <span class="keywordflow">if</span> (ntohl(header.plen) != 0)    <span class="comment">// the message has an unexpected size</span>
01207     {
01208         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockctrl, ntohl(header.plen), fp-&gt;errbuf) == -1)
01209             <span class="keywordflow">return</span> -1;
01210     }
01211 
01212     <span class="keywordflow">return</span> 0;
01213 }
01214 
01215 
01216 
01217 
<a name="l01228"></a><a class="code" href="pcap-remote_8c.html#a18">01228</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a18">pcap_setfilter_remote</a>(pcap_t *fp, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *prog)
01229 {
01230     <span class="keywordflow">if</span> (!fp-&gt;rmt_capstarted)
01231     {
01232         <span class="comment">// copy filter into the pcap_t structure</span>
01233         <span class="keywordflow">if</span> (install_bpf_program(fp, prog) == -1)
01234             <span class="keywordflow">return</span> -1;
01235         <span class="keywordflow">return</span> 0;
01236     }
01237 
01238     <span class="comment">// we have to update a filter during run-time</span>
01239     <span class="keywordflow">if</span> (<a class="code" href="pcap-remote_8c.html#a17">pcap_updatefilter_remote</a>(fp, prog) )
01240         <span class="keywordflow">return</span> -1;
01241 
01242     <span class="keywordflow">return</span> 0;
01243 }
01244 
01245 
01246 
<a name="l01252"></a><a class="code" href="pcap-remote_8c.html#a19">01252</a> <span class="keywordtype">void</span> <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(<span class="keywordtype">int</span> msec)
01253 {
01254 <span class="preprocessor">#ifdef WIN32</span>
01255 <span class="preprocessor"></span>    Sleep(msec);
01256 <span class="preprocessor">#else</span>
01257 <span class="preprocessor"></span><span class="keyword">struct </span>timespec abstime;
01258 <span class="keyword">struct </span>timeval now;
01259 
01260     pthread_cond_t cond;
01261     pthread_mutex_t mutex;
01262     pthread_mutexattr_t attr;
01263 
01264     pthread_mutexattr_init(&amp;attr);
01265     pthread_mutex_init(&amp;mutex, &amp;attr);
01266     pthread_mutex_lock(&amp;mutex);
01267 
01268     pthread_cond_init(&amp;cond, NULL);
01269 
01270     gettimeofday(&amp;now, NULL);
01271     
01272     abstime.tv_sec = now.tv_sec + msec/1000;
01273     abstime.tv_nsec = now.tv_usec * 1000 + (msec%1000) * 1000 * 1000;
01274 
01275     pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;abstime);
01276 
01277     pthread_mutex_destroy(&amp;mutex);
01278     pthread_cond_destroy(&amp;cond);
01279 <span class="preprocessor">#endif</span>
01280 <span class="preprocessor"></span>}
01281 
01282 
01283 
<a name="l01298"></a><a class="code" href="group__remote__pri__func.html#a26">01298</a> <span class="keywordtype">void</span> <a class="code" href="group__remote__pri__func.html#a26">rpcap_thrdatamain_stream</a>(<span class="keywordtype">void</span> *ptr)
01299 {
01300 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// error buffer</span>
01301 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;                         <span class="comment">// pointer to a 'pcap' structure</span>
01302 <span class="keywordtype">int</span> retval;                         <span class="comment">// general variable used to keep the return value of other functions</span>
01303 <span class="keyword">struct </span><a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a> net_pkt_header; <span class="comment">// header of the packet</span>
01304 <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header;     <span class="comment">// pointer to the buffer that contains the header of the current packet</span>
01305 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;         <span class="comment">// general header according to the RPCAP format</span>
01306 <span class="keywordtype">int</span> cc;                             <span class="comment">// number of bytes of data available into the user buffer</span>
01307 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread;                 <span class="comment">// number of bytes (of payload) currently read from the network (referred to the current pkt)</span>
01308 <span class="keywordtype">int</span> pending= 0;                     <span class="comment">// '1' if we've already read the pkt header, but there was not enough space to read the pkt data</span>
01309 
01310 <span class="comment">// Structures needed for the select() call</span>
01311 fd_set rfds;                        <span class="comment">// set of socket descriptors we have to check</span>
01312 <span class="keyword">struct </span>timeval tv;                  <span class="comment">// maximum time the select() can block waiting for data</span>
01313 
01314     fp= (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *) ptr;
01315 
01316     *<a class="code" href="inet_8c.html#a5">errbuf</a>= 0; <span class="comment">// Initialize errbuf</span>
01317 
01318     <span class="comment">// Modify thread params so that it can be killed at any time</span>
01319     <span class="keywordflow">if</span> (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL) )
01320         <span class="keywordflow">goto</span> error;
01321     <span class="keywordflow">if</span> (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL) )
01322         <span class="keywordflow">goto</span> error;
01323 
01324     <span class="comment">// Watch out sockdata to see if it has input</span>
01325     FD_ZERO(&amp;rfds);
01326 
01327     <span class="comment">// We do not have to block on the select()</span>
01328     tv.tv_sec = 0;
01329     tv.tv_usec = 0;
01330 
01331     <span class="comment">/*</span>
01332 <span class="comment">        The algorithm chosen to manage ths user buffer is quite simple, although</span>
01333 <span class="comment">        not completely optimized. For instance, this is the same algorithm that</span>
01334 <span class="comment">        is implemented when a packet is read from the kernel.</span>
01335 <span class="comment"></span>
01336 <span class="comment">        The producer (i.e. this thread) reads data from the network only when the</span>
01337 <span class="comment">        user has already consumed all the data into the buffer.</span>
01338 <span class="comment">        When data is read, it is copied at the beginning of the buffer.</span>
01339 <span class="comment">        So, this is not a circular buffer.</span>
01340 <span class="comment">        This job ends when (1) there is no data coming from the network, (2)</span>
01341 <span class="comment">        the user buffer is completely full.</span>
01342 <span class="comment"></span>
01343 <span class="comment">        The consumer (i.e. the thread that calls pcap_next_ex) can read only when</span>
01344 <span class="comment">        the producer finished its job. In other words, even if there is already </span>
01345 <span class="comment">        data into the user buffer, the consumer cannot read it because the producer</span>
01346 <span class="comment">        updates the status variables (fp-&gt;cc, fp-&gt;bp) only when it ends its job.</span>
01347 <span class="comment">        This is the reason we do not need spinlocks.</span>
01348 <span class="comment"></span>
01349 <span class="comment">        This algorithm has two main drawbacks:</span>
01350 <span class="comment">        - even if there is data into the user buffer, the application could not be </span>
01351 <span class="comment">        able to see it</span>
01352 <span class="comment">        - the producer reads the data from the network all at once, so the resulting</span>
01353 <span class="comment">        behaviour is that all of a sudden the socket buffer is emptied and the TCP</span>
01354 <span class="comment">        starts sending several acknowledges at the same time. This could lead to</span>
01355 <span class="comment">        bursty traffic patterns.</span>
01356 <span class="comment">    */</span>
01357     <span class="keywordflow">while</span> (1)
01358     {
01359         <span class="keywordflow">if</span> (fp-&gt;cc == 0) 
01360         {
01361             u_char *bp= fp-&gt;buffer;
01362             cc= 0;
01363 
01364             <span class="comment">/*</span>
01365 <span class="comment">                We will exit from this cycle while when:</span>
01366 <span class="comment">                - the socket does not have data in it</span>
01367 <span class="comment">                - the buffer does not have space left</span>
01368 <span class="comment"></span>
01369 <span class="comment">                In all cases, the pcap status variables will be updated</span>
01370 <span class="comment">                before calling 'break'.</span>
01371 <span class="comment">            */</span>
01372             <span class="keywordflow">while</span> (1)
01373             {
01374 again:
01375                 <span class="comment">// 'fp-&gt;rmt_sockdata' has always to be set before calling the select(),</span>
01376                 <span class="comment">// since it is cleared by the select()</span>
01377                 FD_SET(fp-&gt;rmt_sockdata, &amp;rfds);
01378 
01379                 retval = select(fp-&gt;rmt_sockdata + 1, &amp;rfds, NULL, NULL, &amp;tv);
01380                 <span class="keywordflow">if</span> (retval == -1)
01381                 {
01382                     <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"select(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01383                         <span class="keywordflow">goto</span> error;
01384                 }
01385 
01386                 <span class="comment">// There is no data waiting</span>
01387                 <span class="keywordflow">if</span> (retval == 0)
01388                 {
01389                     <span class="comment">// Update the pcap_t pointers so that the user application can read from the buffer</span>
01390                     fp-&gt;bp= fp-&gt;buffer;
01391                     fp-&gt;cc= cc;
01392 
01393                     <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(100);   <span class="comment">// Suspend 100 ms</span>
01394                     <span class="keywordflow">break</span>;
01395                 }
01396 
01397                 <span class="keywordflow">if</span> (!pending)
01398                 {
01399                     <span class="comment">// I'm going to read a new packet; so I reset the number of bytes (payload only) read</span>
01400                     nread= 0;
01401 
01402                     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockdata, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), errbuf) == -1)
01403                         <span class="keywordflow">goto</span> error;
01404 
01405                     <span class="comment">// Checks if the message is correct</span>
01406                     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, fp-&gt;rmt_sockdata, &amp;header, RPCAP_MSG_PACKET, 0);
01407 
01408                     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a20">RPCAP_MSG_PACKET</a>)     <span class="comment">// the message is not the one expected</span>
01409                     {
01410                         <span class="keywordflow">switch</span> (retval)
01411                         {
01412                             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error                                  </span>
01413                                 <span class="keywordflow">goto</span> error; <span class="comment">// Do nothing; just exit from here; the error code is already into the errbuf</span>
01414 
01415                             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint sent a message that is not allowed here</span>
01416                             <span class="keywordflow">case</span> -1:        <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
01417                                 <span class="keywordflow">goto</span> again;
01418 
01419                             <span class="keywordflow">default</span>:
01420                             {
01421                                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error"</span>, 1);
01422                                 <span class="keywordflow">goto</span> error;
01423                             };
01424                         }
01425                     }
01426 
01427                     <span class="comment">// Read the RPCAP packet header from the network</span>
01428                     <span class="keywordflow">if</span> ( (nread= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockdata, (<span class="keywordtype">char</span> *) &amp;net_pkt_header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a>), errbuf)) == -1)
01429                         <span class="keywordflow">goto</span> error;
01430                 }
01431 
01432                 <span class="keywordflow">if</span> ( (cc + ntohl(net_pkt_header.<a class="code" href="structrpcap__pkthdr.html#m2">caplen</a>) + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>) ) &lt;= ( (unsigned) fp-&gt;bufsize) )
01433                 {
01434                     pending= 0;
01435 
01436                     pkt_header= (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *) bp;
01437                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>= ntohl(net_pkt_header.<a class="code" href="structrpcap__pkthdr.html#m2">caplen</a>);
01438                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>= ntohl(net_pkt_header.<a class="code" href="structrpcap__pkthdr.html#m3">len</a>);
01439                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec= ntohl(net_pkt_header.<a class="code" href="structrpcap__pkthdr.html#m0">timestamp_sec</a>);
01440                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec= ntohl(net_pkt_header.<a class="code" href="structrpcap__pkthdr.html#m1">timestamp_usec</a>);
01441 
01442                     <span class="comment">// I don't update the counter of the packets dropped by the network since we're using TCP;</span>
01443                     <span class="comment">// therefore no packets are dropped. Just update the number of packets received correctly</span>
01444                     fp-&gt;md.TotCapt++;
01445 
01446                     <span class="comment">// Copies the packet into the data buffer</span>
01447                     <span class="keywordflow">if</span> ( (nread+= <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(fp-&gt;rmt_sockdata, (<span class="keywordtype">char</span> *) bp + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>), pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>, errbuf)) == -1)
01448                         <span class="keywordflow">goto</span> error;
01449 
01450                     bp += BPF_WORDALIGN(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pcap_pkthdr));
01451                     cc += BPF_WORDALIGN(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pcap_pkthdr));
01452 
01453                     <span class="comment">// Checks if all the data has been read; if not, discard the data in excess</span>
01454                     <span class="keywordflow">if</span> (nread != ntohl(header.<a class="code" href="structrpcap__header.html#m3">plen</a>))
01455                         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(fp-&gt;rmt_sockdata, ntohl(header.<a class="code" href="structrpcap__header.html#m3">plen</a>) - nread, fakeerrbuf);
01456 
01457                 }
01458                 <span class="keywordflow">else</span>
01459                 {
01460                     pending= 1;
01461 
01462                     <span class="comment">// Update the pcap_t pointers so that the user application can read from the buffer</span>
01463                     fp-&gt;bp= fp-&gt;buffer;
01464                     fp-&gt;cc= cc;
01465 
01466                     <span class="keywordflow">break</span>;
01467                 }
01468             } <span class="comment">// end while (1)</span>
01469         }
01470         <span class="keywordflow">else</span>
01471         {
01472             <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(100);   <span class="comment">// Suspend 100 ms</span>
01473         }
01474 
01475     }   <span class="comment">// end main while(1)</span>
01476 
01477 error:
01478     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Exiting from the child data thread"</span>, 1);
01479     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01480 
01481     <span class="comment">// Removes the descriptor s from set</span>
01482     FD_CLR(fp-&gt;rmt_sockdata, &amp;rfds);
01483 
01484     closesocket(fp-&gt;rmt_sockdata);
01485     fp-&gt;rmt_sockdata= 0;
01486     fp-&gt;rmt_threaddata= 0;
01487 }
01488 
01489 
01490 
<a name="l01514"></a><a class="code" href="group__remote__pri__func.html#a27">01514</a> <span class="keywordtype">void</span> <a class="code" href="group__remote__pri__func.html#a27">rpcap_thrdatamain_dgram</a>(<span class="keywordtype">void</span> *ptr)
01515 {
01516 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// error buffer</span>
01517 <span class="keywordtype">char</span> netbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];     <span class="comment">// size of the network buffer in which the packet is copied</span>
01518 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *fp;                         <span class="comment">// pointer to a 'pcap' structure</span>
01519 <span class="keywordtype">int</span> retval;                         <span class="comment">// general variable used to keep the return value of other functions</span>
01520 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> *header;        <span class="comment">// general header according to the RPCAP format</span>
01521 <span class="keyword">struct </span><a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a> *net_pkt_header;<span class="comment">// header of the packet</span>
01522 <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header;     <span class="comment">// pointer to the buffer that contains the header of the current packet</span>
01523 <span class="keywordtype">int</span> cc;                             <span class="comment">// number of bytes of data available into the user buffer</span>
01524 <span class="keywordtype">int</span> pending= 0;                     <span class="comment">// '1' if we've already read the pkt header, but there was not enough space to read the pkt data</span>
01525 
01526 <span class="comment">// Structures needed for the select() call</span>
01527 fd_set rfds;                        <span class="comment">// set of socket descriptors we have to check</span>
01528 <span class="keyword">struct </span>timeval tv;                  <span class="comment">// maximum time the select() can block waiting for data</span>
01529 
01530 
01531     <span class="comment">// See the rpcap_thrdatamain_stream() for any comment about the code</span>
01532     fp= (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *) ptr;
01533 
01534     *<a class="code" href="inet_8c.html#a5">errbuf</a>= 0; <span class="comment">// Initialize errbuf</span>
01535 
01536     <span class="comment">// Modify thread params so that it can be killed at any time</span>
01537     <span class="keywordflow">if</span> (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL) )
01538         <span class="keywordflow">goto</span> error;
01539     <span class="keywordflow">if</span> (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL) )
01540         <span class="keywordflow">goto</span> error;
01541 
01542     <span class="comment">// Watch out sockdata to see if it has input</span>
01543     FD_ZERO(&amp;rfds);
01544 
01545     <span class="comment">// We do not have to block here</span>
01546     tv.tv_sec = 0;
01547     tv.tv_usec = 0;
01548 
01549     <span class="keywordflow">while</span> (1)
01550     {
01551         <span class="keywordflow">if</span> (fp-&gt;cc == 0) 
01552         {
01553             u_char *bp= fp-&gt;buffer;
01554             cc= 0;
01555 
01556             <span class="keywordflow">while</span> (1)
01557             {
01558 again:
01559                 FD_SET(fp-&gt;rmt_sockdata, &amp;rfds);
01560 
01561                 retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);
01562                 <span class="keywordflow">if</span> (retval == -1)
01563                 {
01564                     <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"select(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
01565                         <span class="keywordflow">goto</span> error;
01566                 }
01567 
01568                 <span class="comment">// There is no data waiting</span>
01569                 <span class="keywordflow">if</span> (retval == 0)
01570                 {
01571                     <span class="comment">// Update the pcap_t pointers so that the user application can read from the buffer</span>
01572                     fp-&gt;bp= fp-&gt;buffer;
01573                     fp-&gt;cc= cc;
01574 
01575                     <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(100);   <span class="comment">// Suspend 100 ms</span>
01576                     <span class="keywordflow">break</span>;
01577                 }
01578 
01579                 <span class="keywordflow">if</span> (!pending)
01580                 {
01581                     <span class="comment">// Read the entire message from the network</span>
01582                     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a17">sock_recv_dgram</a>(fp-&gt;rmt_sockdata, netbuf, RPCAP_NETBUF_SIZE, errbuf) == -1)
01583                         <span class="keywordflow">goto</span> error;
01584                     header= (<span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> *) netbuf;
01585 
01586                     <span class="comment">// Checks if the message is correct</span>
01587                     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, fp-&gt;rmt_sockdata, (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *) netbuf, RPCAP_MSG_PACKET, 0);
01588 
01589                     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a20">RPCAP_MSG_PACKET</a>)     <span class="comment">// the message is not the one expected</span>
01590                     {
01591                         <span class="keywordflow">switch</span> (retval)
01592                         {
01593                             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error                          </span>
01594                                 <span class="keywordflow">goto</span> error; <span class="comment">// Do nothing; just exit from here; the error code is already into the errbuf</span>
01595 
01596                             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint sent a message that is not allowed here</span>
01597                             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
01598                                 <span class="keywordflow">goto</span> again;
01599 
01600                             <span class="keywordflow">default</span>:
01601                             {
01602                                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error"</span>, 0);
01603                                 <span class="keywordflow">goto</span> error;
01604                             };
01605                         }
01606                     }
01607 
01608                     <span class="comment">// Set a pointer to the RPCAP packet header</span>
01609                     net_pkt_header= (<span class="keyword">struct </span><a class="code" href="structrpcap__pkthdr.html">rpcap_pkthdr</a> *) (netbuf + sizeof(struct rpcap_header));
01610                 }
01611 
01612                 <span class="keywordflow">if</span> ( (cc + ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m2">caplen</a>) + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>) ) &lt;= ( (unsigned) fp-&gt;bufsize) )
01613                 {
01614                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> npkt;
01615                     pending= 0;
01616 
01617                     pkt_header= (<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *) bp;
01618                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>= ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m2">caplen</a>);
01619                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>= ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m3">len</a>);
01620                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec= ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m0">timestamp_sec</a>);
01621                     pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec= ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m1">timestamp_usec</a>);
01622 
01623                     <span class="comment">// Update the number of packets received correctly</span>
01624                     fp-&gt;md.TotCapt++;
01625 
01626                     <span class="comment">// We're using UDP, so I need to update the counter of the packets dropped by the network</span>
01627                     npkt= ntohl(net_pkt_header-&gt;<a class="code" href="structrpcap__pkthdr.html#m4">npkt</a>);
01628 
01629                     <span class="keywordflow">if</span> (fp-&gt;md.TotCapt != npkt)
01630                     {
01631                         fp-&gt;md.TotNetDrops+= (npkt - fp-&gt;md.TotCapt);
01632                         fp-&gt;md.TotCapt= npkt;
01633                     }
01634 
01635                     <span class="comment">// Copies the packet into the data buffer</span>
01636                     memcpy( bp + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>), netbuf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>);
01637 
01638                     bp += BPF_WORDALIGN(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pcap_pkthdr));
01639                     cc += BPF_WORDALIGN(pkt_header-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pcap_pkthdr));
01640                 }
01641                 <span class="keywordflow">else</span>
01642                 {
01643                     pending= 1;
01644 
01645                     <span class="comment">// Update the pcap_t pointers so that the user application can read from the buffer</span>
01646                     fp-&gt;bp= fp-&gt;buffer;
01647                     fp-&gt;cc= cc;
01648 
01649                     <span class="keywordflow">break</span>;
01650                 }
01651             } <span class="comment">// end while (1)</span>
01652         }
01653         <span class="keywordflow">else</span>
01654         {
01655             <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(100);   <span class="comment">// Suspend 100 ms</span>
01656         }
01657     }   <span class="comment">// end main while(1)</span>
01658 
01659 error:
01660     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Exiting from the child data thread"</span>, 1);
01661     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01662 
01663     <span class="comment">// Removes the descriptor s from set</span>
01664     FD_CLR(fp-&gt;rmt_sockdata, &amp;rfds);
01665 
01666     closesocket(fp-&gt;rmt_sockdata);
01667     fp-&gt;rmt_sockdata= 0;
01668     fp-&gt;rmt_threaddata= 0;
01669 }
01670 
01671 
01672 
01673 
01674 
01675 
01676 <span class="comment">/*********************************************************</span>
01677 <span class="comment"> *                                                       *</span>
01678 <span class="comment"> * Miscellaneous functions                               *</span>
01679 <span class="comment"> *                                                       *</span>
01680 <span class="comment"> *********************************************************/</span>
01681 
01682 
<a name="l01707"></a><a class="code" href="pcap-remote_8c.html#a20">01707</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(SOCKET sock, <span class="keywordtype">char</span> *error, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> errcode, <span class="keywordtype">char</span> *errbuf)
01708 {
01709 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];            <span class="comment">// temporary buffer in which data to be sent is buffered</span>
01710 <span class="keywordtype">int</span> sendbufidx= 0;                          <span class="comment">// index which keeps the number of bytes currently buffered</span>
01711 <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> length;
01712 
01713     length= (uint16) strlen(error);
01714 
01715     <span class="keywordflow">if</span> (length &gt; <a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>)
01716         length= <a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>;
01717 
01718     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *) sendbuf, RPCAP_MSG_ERROR, errcode, length);
01719 
01720     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) )
01721         <span class="keywordflow">return</span> -1;
01722 
01723     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(error, length, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) )
01724         <span class="keywordflow">return</span> -1;
01725 
01726     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sock, sendbuf, sendbufidx, errbuf) )
01727         <span class="keywordflow">return</span> -1;
01728 
01729     <span class="keywordflow">return</span> 0;
01730 }
01731 
01732 
01733 
<a name="l01752"></a><a class="code" href="pcap-remote_8c.html#a21">01752</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a21">rpcap_sendauth</a>(SOCKET sock, <span class="keyword">struct</span> <a class="code" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <span class="keywordtype">char</span> *errbuf)
01753 {
01754 <span class="keywordtype">char</span> sendbuf[<a class="code" href="group__remote__pri__struct.html#a12">RPCAP_NETBUF_SIZE</a>];    <span class="comment">// temporary buffer in which data that has to be sent is buffered</span>
01755 <span class="keywordtype">int</span> sendbufidx= 0;                  <span class="comment">// index which keeps the number of bytes currently buffered</span>
01756 <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> length;                      <span class="comment">// length of the payload of this message</span>
01757 <span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a> *rpauth;
01758 <a class="code" href="group__remote__pri__struct.html#a1">uint16</a> auth_type;
01759 <span class="keyword">struct </span><a class="code" href="structrpcap__header.html">rpcap_header</a> header;
01760 <span class="keywordtype">int</span> retval;                         <span class="comment">// temp variable which stores functions return value</span>
01761 
01762     <span class="keywordflow">if</span> (auth)
01763     {
01764     auth_type= auth-&gt;<a class="code" href="structpcap__rmtauth.html#m0">type</a>;
01765 
01766         <span class="keywordflow">switch</span> (auth-&gt;<a class="code" href="structpcap__rmtauth.html#m0">type</a>)
01767         {
01768             <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a9">RPCAP_RMTAUTH_NULL</a>:
01769                 length= <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a>);
01770                 <span class="keywordflow">break</span>;
01771 
01772             <span class="keywordflow">case</span> <a class="code" href="group__remote__struct.html#a10">RPCAP_RMTAUTH_PWD</a>:
01773                 length= <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a>);
01774                 <span class="keywordflow">if</span> (auth-&gt;<a class="code" href="structpcap__rmtauth.html#m1">username</a>) length+= strlen(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m1">username</a>);
01775                 <span class="keywordflow">if</span> (auth-&gt;<a class="code" href="structpcap__rmtauth.html#m2">password</a>) length+= strlen(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m2">password</a>);
01776                 <span class="keywordflow">break</span>;
01777 
01778             <span class="keywordflow">default</span>:
01779                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Authentication type not recognized."</span>);
01780                 <span class="keywordflow">return</span> -1;
01781         }
01782     }
01783     <span class="keywordflow">else</span>
01784     {
01785         auth_type= <a class="code" href="group__remote__struct.html#a9">RPCAP_RMTAUTH_NULL</a>;
01786         length= <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a>);
01787     }
01788 
01789 
01790     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) )
01791         <span class="keywordflow">return</span> -1;
01792 
01793     <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>( (<span class="keyword">struct</span> rpcap_header *) sendbuf, RPCAP_MSG_AUTH_REQ, 0, length);
01794 
01795     rpauth= (<span class="keyword">struct </span><a class="code" href="structrpcap__auth.html">rpcap_auth</a> *) &amp;sendbuf[sendbufidx];
01796 
01797     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(NULL, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrpcap__auth.html">rpcap_auth</a>), NULL, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf) )
01798         <span class="keywordflow">return</span> -1;
01799 
01800     memset(rpauth, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> rpcap_auth) );
01801 
01802     rpauth-&gt;<a class="code" href="structrpcap__auth.html#m0">type</a>= htons(auth_type);
01803 
01804     <span class="keywordflow">if</span> (auth_type == <a class="code" href="group__remote__struct.html#a10">RPCAP_RMTAUTH_PWD</a>)
01805     {
01806 
01807         <span class="keywordflow">if</span> (auth-&gt;<a class="code" href="structpcap__rmtauth.html#m1">username</a>)
01808             rpauth-&gt;<a class="code" href="structrpcap__auth.html#m2">slen1</a>= strlen(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m1">username</a>);
01809         <span class="keywordflow">else</span>
01810             rpauth-&gt;<a class="code" href="structrpcap__auth.html#m2">slen1</a>= 0;
01811 
01812         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m1">username</a>, rpauth-&gt;<a class="code" href="structrpcap__auth.html#m2">slen1</a>, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) )
01813             <span class="keywordflow">return</span> -1;
01814 
01815         <span class="keywordflow">if</span> (auth-&gt;<a class="code" href="structpcap__rmtauth.html#m2">password</a>)
01816             rpauth-&gt;<a class="code" href="structrpcap__auth.html#m3">slen2</a>= strlen(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m2">password</a>);
01817         <span class="keywordflow">else</span>
01818             rpauth-&gt;<a class="code" href="structrpcap__auth.html#m3">slen2</a>= 0;
01819 
01820         <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(auth-&gt;<a class="code" href="structpcap__rmtauth.html#m2">password</a>, rpauth-&gt;<a class="code" href="structrpcap__auth.html#m3">slen2</a>, sendbuf, &amp;sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf) )
01821             <span class="keywordflow">return</span> -1;
01822 
01823         rpauth-&gt;<a class="code" href="structrpcap__auth.html#m2">slen1</a>= htons (rpauth-&gt;<a class="code" href="structrpcap__auth.html#m2">slen1</a>);
01824         rpauth-&gt;<a class="code" href="structrpcap__auth.html#m3">slen2</a>= htons (rpauth-&gt;<a class="code" href="structrpcap__auth.html#m3">slen2</a>);
01825     }
01826 
01827     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a14">sock_send</a>(sock, sendbuf, sendbufidx, errbuf) )
01828         <span class="keywordflow">return</span> -1;
01829 
01830     <span class="keywordflow">if</span> ( <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sock, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpcap_header), errbuf) == -1)
01831         <span class="keywordflow">return</span> -1;
01832 
01833     retval= <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(errbuf, sock, &amp;header, RPCAP_MSG_AUTH_REPLY, RPCAP_MSG_ERROR, 0);
01834 
01835     <span class="keywordflow">if</span> (retval != <a class="code" href="group__remote__pri__struct.html#a28">RPCAP_MSG_AUTH_REPLY</a>)     <span class="comment">// the message is not the one expected</span>
01836     {
01837         <span class="keywordflow">switch</span> (retval)
01838         {
01839             <span class="keywordflow">case</span> -3:        <span class="comment">// Unrecoverable network error</span>
01840             <span class="keywordflow">case</span> -2:        <span class="comment">// The other endpoint sent a message that is not allowed here</span>
01841             <span class="keywordflow">case</span> -1:    <span class="comment">// The other endpoint has a version number that is not compatible with our</span>
01842                 <span class="comment">// Do nothing; just exit from here; the error code is already into the errbuf</span>
01843                 <span class="keywordflow">return</span> -1;
01844 
01845             <span class="keywordflow">case</span> <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>:
01846             {
01847                 <span class="keywordflow">return</span> -1;
01848             };
01849 
01850             <span class="keywordflow">default</span>:
01851             {
01852                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Internal error"</span>, 0);
01853                 <span class="keywordflow">return</span> -1;
01854             };
01855         }
01856     }
01857 
01858     <span class="keywordflow">if</span> (ntohl(header.plen) )
01859     {
01860         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sock, ntohl(header.plen), errbuf) )
01861             <span class="keywordflow">return</span> -1;
01862     }
01863     
01864     <span class="keywordflow">return</span> 0;
01865 }
01866 
01867 
01868 
<a name="l01890"></a><a class="code" href="pcap-remote_8c.html#a22">01890</a> <span class="keywordtype">void</span> <a class="code" href="pcap-remote_8c.html#a22">rpcap_createhdr</a>(<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *header, uint8 type, uint16 value, uint32 length)
01891 {
01892     memset(header, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a>) );
01893 
01894     header-&gt;<a class="code" href="structrpcap__header.html#m0">ver</a>= <a class="code" href="group__remote__pri__struct.html#a7">RPCAP_VERSION</a>;
01895     header-&gt;<a class="code" href="structrpcap__header.html#m1">type</a>= type;
01896     header-&gt;<a class="code" href="structrpcap__header.html#m2">value</a>= htons(value);
01897     header-&gt;<a class="code" href="structrpcap__header.html#m3">plen</a>= htonl(length);
01898 }
01899 
01900 
01901 
<a name="l01945"></a><a class="code" href="pcap-remote_8c.html#a23">01945</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a>(<span class="keywordtype">char</span> *errbuf, SOCKET sock, <span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *header, uint8 first, ...)
01946 {
01947 va_list ap;
01948 <a class="code" href="group__remote__pri__struct.html#a0">uint8</a> type;
01949 <a class="code" href="group__remote__pri__struct.html#a3">int32</a> len;
01950 
01951     va_start(ap, first);
01952 
01953     <span class="comment">// Check if the present version of the protocol can handle this message</span>
01954     <span class="keywordflow">if</span> ( <a class="code" href="group__remote__pri__func.html#a32">rpcap_checkver</a>(sock, header, errbuf) )
01955     {
01956         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
01957 
01958         va_end(ap);
01959         <span class="keywordflow">return</span> -1;
01960     }
01961 
01962     type= first;
01963 
01964     <span class="keywordflow">while</span> ( type != 0 )
01965     {
01966         <span class="comment">// The message matches with one of the types listed</span>
01967         <span class="comment">// There is no need of conversions since both values are uint8</span>
01968 
01969         <span class="comment">// Check if the other side reported an error.</span>
01970         <span class="comment">// If yes, it retrieves it and it returns it back to the caller</span>
01971         <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structrpcap__header.html#m1">type</a> == <a class="code" href="group__remote__pri__struct.html#a14">RPCAP_MSG_ERROR</a>)
01972         {
01973             len= ntohl(header-&gt;<a class="code" href="structrpcap__header.html#m3">plen</a>);
01974 
01975             <span class="keywordflow">if</span> (len &gt;= <a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a>)
01976             {
01977                 <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sock, errbuf, PCAP_ERRBUF_SIZE -1, errbuf) )
01978                     <span class="keywordflow">return</span> -3;
01979                 <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sock, len - (PCAP_ERRBUF_SIZE - 1), fakeerrbuf);
01980 
01981                 <span class="comment">// Put '\0' at the end of the string</span>
01982                 <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> - 1]= 0;
01983             }
01984             <span class="keywordflow">else</span>
01985             {
01986                 <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sock, errbuf, len, errbuf) == -1)
01987                     <span class="keywordflow">return</span> -3;
01988 
01989                 <span class="comment">// Put '\0' at the end of the string</span>
01990                 <a class="code" href="inet_8c.html#a5">errbuf</a>[len]= 0;
01991             }
01992 
01993 
01994             va_end(ap);
01995             <span class="keywordflow">return</span> header-&gt;<a class="code" href="structrpcap__header.html#m1">type</a>;
01996         }
01997 
01998         <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structrpcap__header.html#m1">type</a> == type)
01999         {
02000             va_end(ap);
02001             <span class="keywordflow">return</span> header-&gt;<a class="code" href="structrpcap__header.html#m1">type</a>;
02002         }
02003         
02004         <span class="comment">// get next argument</span>
02005         type= va_arg(ap, <span class="keywordtype">int</span>);
02006     }
02007 
02008     <span class="comment">// we already have an error, so please discard this one</span>
02009     <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sock, ntohl(header-&gt;<a class="code" href="structrpcap__header.html#m3">plen</a>), fakeerrbuf);
02010 
02011     <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"The other endpoint sent a message that is not allowed here."</span>);
02012     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
02013 
02014     va_end(ap);
02015     <span class="keywordflow">return</span> -2;
02016 }
02017 
02018 
02019 
<a name="l02043"></a><a class="code" href="group__remote__pri__func.html#a32">02043</a> <span class="keywordtype">int</span> <a class="code" href="group__remote__pri__func.html#a32">rpcap_checkver</a>(SOCKET sock, <span class="keyword">struct</span> <a class="code" href="structrpcap__header.html">rpcap_header</a> *header, <span class="keywordtype">char</span> *errbuf)
02044 {
02045     <span class="comment">/*</span>
02046 <span class="comment">    This is a sample function.</span>
02047 <span class="comment"></span>
02048 <span class="comment">    In the real world, you have to check at the type code, </span>
02049 <span class="comment">    and decide accordingly.</span>
02050 <span class="comment">    */</span>
02051 
02052     <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structrpcap__header.html#m0">ver</a> != <a class="code" href="group__remote__pri__struct.html#a7">RPCAP_VERSION</a>)
02053     {
02054         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Incompatible version number: message discarded."</span>);
02055 
02056         <span class="comment">// we already have an error, so please discard this one</span>
02057         <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(sock, ntohl(header-&gt;<a class="code" href="structrpcap__header.html#m3">plen</a>), fakeerrbuf);
02058         <span class="keywordflow">return</span> -1;
02059     }
02060 
02061     <span class="keywordflow">return</span> 0;
02062 }
02063 
02064 
02065 
<a name="l02086"></a><a class="code" href="pcap-remote_8c.html#a24">02086</a> <span class="keywordtype">int</span> <a class="code" href="pcap-remote_8c.html#a24">rpcap_remoteact_getsock</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *host, <span class="keywordtype">char</span> *errbuf)
02087 {
02088 <span class="keyword">struct </span><a class="code" href="structactivehosts.html">activehosts</a> *temp;                   <span class="comment">// temp var needed to scan the host list chain</span>
02089 <span class="keyword">struct </span>addrinfo hints, *addrinfo, *ai_next; <span class="comment">// temp var needed to translate between hostname to its address</span>
02090 <span class="keywordtype">int</span> retval;
02091 
02092     <span class="comment">// retrieve the network address corresponding to 'host'</span>
02093     addrinfo = NULL;
02094     memset(&amp;hints, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> addrinfo) );
02095     hints.ai_family = PF_UNSPEC;
02096     hints.ai_socktype= SOCK_STREAM;
02097 
02098     retval = getaddrinfo(host, <span class="stringliteral">"0"</span>, &amp;hints, &amp;addrinfo);
02099     <span class="keywordflow">if</span> (retval != 0)
02100     {
02101         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo() %s"</span>, gai_strerror(retval));
02102         <span class="keywordflow">return</span> -1;
02103     }
02104 
02105     temp= <a class="code" href="pcap-remote_8c.html#a3">activeHosts</a>;
02106 
02107     <span class="keywordflow">while</span> (temp)
02108     {
02109         ai_next= addrinfo;
02110         <span class="keywordflow">while</span>(ai_next)
02111         {
02112             <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a20">sock_cmpaddr</a>(&amp;temp-&gt;<a class="code" href="structactivehosts.html#m0">host</a>, (<span class="keyword">struct</span> sockaddr_storage *) ai_next-&gt;ai_addr ) == 0)
02113                 <span class="keywordflow">return</span> (temp-&gt;<a class="code" href="structactivehosts.html#m1">sockctrl</a> );
02114 
02115             ai_next= ai_next-&gt;ai_next;
02116         }
02117         temp= temp-&gt;<a class="code" href="structactivehosts.html#m2">next</a>;
02118     }
02119 
02120     <span class="keywordflow">if</span> (addrinfo)
02121         freeaddrinfo(addrinfo);
02122 
02123     <span class="comment">// The host you want to get the socket ID does not have an active connection</span>
02124     <span class="keywordflow">return</span> 0;
02125 }
02126 
02127 
02128 
02129 
02130 
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
