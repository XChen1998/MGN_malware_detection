<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pcap-remote.c File Reference</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pcap-remote.c File Reference</h1><code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;stdarg.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &lt;<a class="el" href="funcs_2pcap_8h-source.html">pcap.h</a>&gt;</code><br>
<code>#include &lt;pcap-int.h&gt;</code><br>
<code>#include &lt;<a class="el" href="pcap-remote_8h-source.html">pcap-remote.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="sockutils_8h-source.html">sockutils.h</a>&gt;</code><br>

<p>
<a href="pcap-remote_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a0">PCAP_STATS_STANDARD</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a1">PCAP_STATS_EX</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a26">rpcap_thrdatamain_stream</a> (void *ptr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a TCP data connection.</em> <a href="group__remote__pri__func.html#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a27">rpcap_thrdatamain_dgram</a> (void *ptr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Main function of the thread which waits for data packets (i.e. packets which carry a captured packet) in case of a UDP data connection.</em> <a href="group__remote__pri__func.html#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a32">rpcap_checkver</a> (SOCKET sock, struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks if the version contained into the message is compatible with the one handled by this implementation.</em> <a href="group__remote__pri__func.html#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps, int mode)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="group__remote__pri__func.html#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a8">pcap_pack_bpffilter</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp, char *sendbuf, int *sendbufidx, struct <a class="el" href="structbpf__program.html">bpf_program</a> *prog)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Takes a bpf program and sends it to the other host.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a9">rpcap_deseraddr</a> (struct sockaddr_storage *sockaddrin, struct sockaddr_storage **sockaddrout, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It traslates (i.e. de-serializes) a 'sockaddr_storage' structure from the network byte order to the host byte order.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a10">pcap_read_nocb_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, u_char **pkt_data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It reads a packet from the network socket. This does not make used of callback (hence the "nocb" string into its name).</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a11">pcap_read_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcap__fn.html#a0">pcap_handler</a> callback, u_char *user)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It reads a packet from the network socket.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a12">pcap_close_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends a CLOSE command to the capture server.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a13">pcap_stats_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a14">pcap_stats_ex_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *p)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves network statistics from the other peer.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a15">pcap_opensource_remote</a> (const char *source, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It opens a remote adapter by opening an RPCAP connection and so on.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a16">pcap_startcapture_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It starts a remote capture.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a17">pcap_updatefilter_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp, struct <a class="el" href="structbpf__program.html">bpf_program</a> *prog)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Update a filter on a remote host.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a18">pcap_setfilter_remote</a> (<a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *fp, struct <a class="el" href="structbpf__program.html">bpf_program</a> *prog)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a filter to a remote host.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a19">pthread_suspend</a> (int msec)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Suspends a pthread for msec milliseconds.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a20">rpcap_senderror</a> (SOCKET sock, char *error, unsigned short errcode, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends a RPCAP error to the other peer.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a21">rpcap_sendauth</a> (SOCKET sock, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sends the authentication message.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a22">rpcap_createhdr</a> (struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, <a class="el" href="group__remote__pri__struct.html#a0">uint8</a> type, <a class="el" href="group__remote__pri__struct.html#a1">uint16</a> value, <a class="el" href="group__remote__pri__struct.html#a2">uint32</a> length)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Creates a structure of type <a class="el" href="structrpcap__header.html">rpcap_header</a>.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a23">rpcap_checkmsg</a> (char *<a class="el" href="inet_8c.html#a5">errbuf</a>, SOCKET sock, struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *header, <a class="el" href="group__remote__pri__struct.html#a0">uint8</a> first,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks if the header of the received message is correct.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a24">rpcap_remoteact_getsock</a> (const char *<a class="el" href="wpcap__remote_8htm.html#a3">host</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It returns the socket currently used for this active connection (active mode only).</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>char&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a2">fakeerrbuf</a> [PCAP_ERRBUF_SIZE+1]</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structactivehosts.html">activehosts</a> *&nbsp;</td><td valign=bottom><a class="el" href="pcap-remote_8c.html#a3">activeHosts</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Keeps a list of all the opened connections in the active mode.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file keeps all the new funtions that are needed for the RPCAP protocol. Almost all the pcap functions need to be modified in order to become compatible with the RPCAP protocol. However, you can find here only the ones that are completely new.<p>
This file keeps also the functions that are 'private', i.e. are needed by the RPCAP protocol but are not exported to the user.<p>
<dl compact><dt><b>Warning:</b></dt><dd>All the RPCAP functions that are allowed to return a buffer containing the error description can return max PCAP_ERRBUF_SIZE characters. However there is no guarantees that the string will be zero-terminated. Best practice is to define the errbuf variable as a char of size 'PCAP_ERRBUF_SIZE+1' and to insert manually a NULL character at the end of the buffer. This will guarantee that no buffer overflows occur even if we use the printf() to show the error on the screen.</dd></dl>

<p>
Definition in file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.<hr><h2>Define Documentation</h2>
<a name="a1" doxytag="pcap-remote.c::PCAP_STATS_EX"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PCAP_STATS_EX&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used by pcap_stats_remote to see if we want standard or extended statistics 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00066">66</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="pcap-remote.c::PCAP_STATS_STANDARD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PCAP_STATS_STANDARD&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used by pcap_stats_remote to see if we want standard or extended statistics 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00065">65</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a12" doxytag="pcap-remote.c::pcap_close_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_close_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends a CLOSE command to the capture server.
<p>
This function is called when the user wants to close a pcap_t adapter. In case we're capturing from the network, it sends a command to the other peer that says 'ok, let's stop capturing'. This function is called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a30">pcap_close()</a>.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a30">pcap_close()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Since we're closing the connection, we do not check for errors. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00300">300</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="pcap-remote.c::pcap_opensource_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#a2">pcap_t</a>* pcap_opensource_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It opens a remote adapter by opening an RPCAP connection and so on.
<p>
This function does basically the job of <a class="el" href="group__wpcap__fn.html#a1">pcap_open_live()</a> for a remote interface. In other words, we have a pcap_read for win32, which reads packets from NPF, another for LINUX, and so on. Now, we have a <a class="el" href="pcap-remote_8c.html#a15">pcap_opensource_remote()</a> as well. The difference, here, is the capture thread does not start until the <a class="el" href="pcap-remote_8c.html#a16">pcap_startcapture_remote()</a> is called.<p>
This is because, in remote capture, we cannot start capturing data as soon ad the 'open adapter' command is sent. Suppose the remote adapter is already overloaded; if we start a capture (which, by default, has a NULL filter) the new traffic can saturate the network.<p>
Instead, we want to "open" the adapter, then send a "start capture" command only when we're ready to start the capture. This funtion does this job: it sends a "open adapter" command (according to the RPCAP protocol), but it does not start the capture.<p>
Since the other libpcap functions do not share this way of life, we have to make some dirty things in order to make everyting working.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>source:</em>&nbsp;</td><td>see <a class="el" href="group__remote__func.html#a3">pcap_open()</a>. </td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>see <a class="el" href="group__remote__func.html#a3">pcap_open()</a>.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be either a network problem, an RPCAP problem (e.g. authentication failed), and more.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a 'pcap_t' which can be used as a parameter to the following calls (<a class="el" href="group__wpcap__fn.html#a14">pcap_compile()</a> and so on) and that specifies an opened WinPcap session. In case of problems, it returns NULL and the 'errbuf' variable keeps the error message.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>In case we call the <a class="el" href="group__wpcap__fn.html#a14">pcap_compile()</a> and the capture is not started, the filter will be saved into the pcap_t structure, and it will be sent to the other host later (when the <a class="el" href="pcap-remote_8c.html#a16">pcap_startcapture_remote()</a> is called). </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00554">554</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>, <a class="el" href="pcap-new_8c-source.html#l00636">pcap_parsesrcstr()</a>, <a class="el" href="remote-ext_8h-source.html#l00099">PCAP_SRC_IFREMOTE</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00279">RPCAP_MSG_OPEN_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00881">pcap_open()</a>, and <a class="el" href="Pcap-win32_8c-source.html#l00144">pcap_open_live()</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="pcap-remote.c::pcap_pack_bpffilter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_pack_bpffilter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sendbufidx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structbpf__program.html">bpf_program</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prog</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Takes a bpf program and sends it to the other host.
<p>
This function can be called in two cases:<ul>
<li>the pcap_startcapture() is called (we have to send the filter along with the 'start capture' command)</li><li>we want to udpate the filter during a capture (i.e. the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a> is called when the capture is still on)</li></ul>
<p>
This function serializes the filter into the sending buffer ('sendbuf', passed as a parameter) and return back. It does not send anything on the network.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fp:</em>&nbsp;</td><td>the pcap_t descriptor of the device currently opened.</td></tr>
    <tr><td valign=top><em>sendbuf:</em>&nbsp;</td><td>the buffer on which the serialized data has to copied.</td></tr>
    <tr><td valign=top><em>sendbufidx:</em>&nbsp;</td><td>it is used to return the abounf of bytes copied into the buffer.</td></tr>
    <tr><td valign=top><em>prog:</em>&nbsp;</td><td>the bpf prgoram we hve to copy.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' otherwise. The error message (if one) is returned into the 'errbuf' field of the pcap_t structure. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01104">1104</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="Packet32_8h-source.html#l00105">bpf_program::bf_insns</a>, <a class="el" href="Packet32_8h-source.html#l00104">bpf_program::bf_len</a>, <a class="el" href="pcap-remote_8h-source.html#l00238">rpcap_filterbpf_insn::code</a>, <a class="el" href="pcap-remote_8h-source.html#l00229">rpcap_filter::filtertype</a>, <a class="el" href="pcap-remote_8h-source.html#l00240">rpcap_filterbpf_insn::jf</a>, <a class="el" href="pcap-remote_8h-source.html#l00239">rpcap_filterbpf_insn::jt</a>, <a class="el" href="pcap-remote_8h-source.html#l00241">rpcap_filterbpf_insn::k</a>, <a class="el" href="pcap-remote_8h-source.html#l00231">rpcap_filter::nitems</a>, and <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="pcap-remote.c::pcap_read_nocb_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_read_nocb_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pkt_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It reads a packet from the network socket. This does not make used of callback (hence the "nocb" string into its name).
<p>
This function is called by the several <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a> when they detect that we have a remote capture and they are the client side. In that case, they need to read packets from the socket.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a41">pcap_next_ex()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>By choice, this function does not make use of semaphores. A smarter implementation should put a semaphore into the data thread, and a signal will be raised as soon as there is data into the socket buffer. However this is complicated and it does not bring any advantages when reading from the network, in which network delays can be much more important than these optimizations. Therefore, we chose the following approach:<ul>
<li>the 'timeout' chosen by the user is split in two (half on the server side, with the usual meaning, and half on the client side)</li><li>this function checks for packets; if there are no packets, it waits for timeout/2 and then it checks again. If packets are still missing, it returns, otherwise it reads packets. </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00203">203</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l01252">pthread_suspend()</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00148">pcap_next_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00270">pcap_read_remote()</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="pcap-remote.c::pcap_read_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_read_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__fn.html#a0">pcap_handler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>callback</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>user</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It reads a packet from the network socket.
<p>
This function is called by the several <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a> when they detect that we have a remote capture and they are the client side. In that case, they need to read packets from the socket.<p>
This function relies on the pcap_read_nocb_remote to deliver packets. The difference, here, is that as soon as a packet is read, it is delivered to the application by means of a callback function.<p>
Parameters and return values are exactly the same of the <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00270">270</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="bpf__image_8c-source.html#l00043">n</a>, and <a class="el" href="pcap-remote_8c-source.html#l00203">pcap_read_nocb_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00079">pcap_read()</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="pcap-remote.c::pcap_setfilter_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setfilter_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structbpf__program.html">bpf_program</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prog</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a filter to a remote host.
<p>
This function is called when the user wants to set a filter. In case we're capturing from the network, it sends the filter to the other peer. This function is called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01228">1228</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00292">pcap_setfilter()</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="pcap-remote.c::pcap_startcapture_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_startcapture_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fp</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It starts a remote capture.
<p>
This function is requires since the RPCAP protocol decouples the 'open' from the 'start capture' functions. This function takes all the parameters needed (which have been stored into the pcap_t structure) and sends them to the server. If everything is fine, it creates a new child thread that reads data from the network and puts data it into the user buffer. The <a class="el" href="Pcap-win32_8c.html#a6">pcap_read()</a> will read data from the user buffer, as usual.<p>
The remote capture acts like a new "kernel", which puts packets directly into the buffer pointed by pcap_t. In fact, this function does not rely on a kernel that reads packets and put them into the user buffer; it has to do that on its own.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fp:</em>&nbsp;</td><td>the pcap_t descriptor of the device currently open.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' otherwise. The error message (if one) is returned into the 'errbuf' field of the pcap_t structure. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00761">761</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00196">rpcap_startcapreq::flags</a>, <a class="el" href="wpcap__remote_8htm-source.html#l00023">host</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="remote-ext_8h-source.html#l00073">PCAP_BUF_SIZE</a>, <a class="el" href="pcap_8c-source.html#l00653">pcap_close()</a>, <a class="el" href="remote-ext_8h-source.html#l00136">PCAP_OPENFLAG_PROMISCUOUS</a>, <a class="el" href="remote-ext_8h-source.html#l00140">PCAP_OPENFLAG_UDP_DP</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="pcap-remote_8h-source.html#l00197">rpcap_startcapreq::portdata</a>, <a class="el" href="pcap-remote_8h-source.html#l00195">rpcap_startcapreq::read_timeout</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00280">RPCAP_MSG_STARTCAP_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="pcap-remote_8h-source.html#l00287">RPCAP_STARTCAPREQ_FLAG_DGRAM</a>, <a class="el" href="pcap-remote_8h-source.html#l00286">RPCAP_STARTCAPREQ_FLAG_PROMISC</a>, <a class="el" href="pcap-remote_8h-source.html#l00288">RPCAP_STARTCAPREQ_FLAG_SERVEROPEN</a>, <a class="el" href="pcap-remote_8h-source.html#l00194">rpcap_startcapreq::snaplen</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="pcap_8c-source.html#l00148">pcap_next_ex()</a>, and <a class="el" href="Pcap-win32_8c-source.html#l00079">pcap_read()</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="pcap-remote.c::pcap_stats_ex_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpcap__stat.html">pcap_stat</a>* pcap_stats_ex_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves network statistics from the other peer.
<p>
This function is just a void cointainer, since the work is done by the <a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote()</a>. See that funcion for more details.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a44">pcap_stats_ex()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00396">396</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00396">pcap_stats_ex_remote()</a>, <a class="el" href="incs_2pcap_8h-source.html#l00070">pcap_t</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.
<p>
Referenced by <a class="el" href="Win32-Extensions_8c-source.html#l00051">pcap_stats_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00396">pcap_stats_ex_remote()</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="pcap-remote.c::pcap_stats_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_stats_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves network statistics from the other peer.
<p>
This function is just a void cointainer, since the work is done by the <a class="el" href="group__remote__pri__func.html#a20">rpcap_stats_remote()</a>. See that funcion for more details.<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a24">pcap_stats()</a>. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00373">373</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.
<p>
Referenced by <a class="el" href="Pcap-win32_8c-source.html#l00060">pcap_stats()</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="pcap-remote.c::pcap_updatefilter_remote"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_updatefilter_remote </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#a2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structbpf__program.html">bpf_program</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prog</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update a filter on a remote host.
<p>
This function is called when the user wants to update a filter. In case we're capturing from the network, it sends the filter to the other peer. This function is *not* called automatically when the user calls the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>. There will be two cases:<ul>
<li>the capture is already on: in this case, <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a> calls <a class="el" href="pcap-remote_8c.html#a17">pcap_updatefilter_remote()</a></li><li>the capture has not started yet: in this case, <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a> stores the filter into the pcap_t structure, and then the filter is sent with the pcap_startcap().</li></ul>
<p>
Parameters and return values are exactly the same of the <a class="el" href="group__wpcap__fn.html#a16">pcap_setfilter()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This function *does not* clear the packet currently into the buffers. Therefore, the user has to expect to receive some packets that are related to the previous filter. If you want to discard all the packets before applying a new filter, you have to close the current capture session and start a new one. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01161">1161</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="Packet32_8h-source.html#l00104">bpf_program::bf_len</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00281">RPCAP_MSG_UPDATEFILTER_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, and <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l01228">pcap_setfilter_remote()</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="pcap-remote.c::pthread_suspend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pthread_suspend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msec</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspends a pthread for msec milliseconds.
<p>
This fucntion is provided since pthreads do not have a suspend() call. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01252">1252</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-remote_8c-source.html#l00203">pcap_read_nocb_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="pcap-remote.c::rpcap_checkmsg"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_checkmsg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a0">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if the header of the received message is correct.
<p>
This function is a way to easily check if the message received, in a certain state of the RPCAP protocol Finite State Machine, is valid. This function accepts, as a parameter, the list of message types that are allowed in a certain situation, and it returns the one which occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be either problem occurred inside this function (e.g. a network problem in case it tries to send an error on the other peer and the send() call fails), an error message which has been sent to us from the other party, or a version error (the message receive has a version number that is incompabile with our).</td></tr>
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket that has to be used to receive data. This function can read data from socket in case the version contained into the message is not compatible with our. In that case, all the message is purged from the socket, so that the following recv() calls will return a new message.</td></tr>
    <tr><td valign=top><em>header:</em>&nbsp;</td><td>a pointer to and 'rpcap_header' structure that keeps the data received from the network (still in network byte order) and that has to be checked.</td></tr>
    <tr><td valign=top><em>first:</em>&nbsp;</td><td>this function has a variable number of parameters. From this point on, all the messages that are valid in this context must be passed as parameters. The message type list must be terminated with a '0' value, the null message type, which means 'no more types to check'. The RPCAP protocol does not define anything with message type equal to zero, so there is no ambiguity in using this value as a list terminator.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The message type of the message that has been detected. In case of errors (e.g. the header contains a type that is not listed among the allowed types), this function will return the following codes:<ul>
<li>(-1) if the version is incompatible.</li><li>(-2) if the code is not among the one listed into the parameters list</li><li>(-3) if a network error (connection reset, ...)</li><li>RPCAP_MSG_ERROR if the message is an error message (it follow that the RPCAP_MSG_ERROR could not be present in the allowed message-types list, beucase this function checks for errors anyway)</li></ul>
</dd></dl>
In case either the version is incompatible or nothing matches (i.e. it returns '-1' or '-2'), it discards the message body (i.e. it reads the remaining part of the message from the network and it discards it) so that the application is ready to receive a new message. 
<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01945">1945</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="inet_8c-source.html#l00632">errbuf</a>, <a class="el" href="pcap-remote_8h-source.html#l00115">int32</a>, <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8c-source.html#l02043">rpcap_checkver()</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="pcap-remote_8h-source.html#l00150">rpcap_header::type</a>, and <a class="el" href="pcap-remote_8h-source.html#l00112">uint8</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="pcap-remote.c::rpcap_createhdr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rpcap_createhdr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrpcap__header.html">rpcap_header</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>header</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a0">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a1">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>value</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__remote__pri__struct.html#a2">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a structure of type <a class="el" href="structrpcap__header.html">rpcap_header</a>.
<p>
This function is provided just because the creation of an rpcap header is quite a common task. It accepts all the values that appears into an <a class="el" href="structrpcap__header.html">rpcap_header</a>, and it puts them in place using the proper hton() calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>header:</em>&nbsp;</td><td>a pointer to a user-allocated buffer which will contain the serialized header, ready to be sent on the network.</td></tr>
    <tr><td valign=top><em>type:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.type field and that represents the type of the current message.</td></tr>
    <tr><td valign=top><em>value:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.value field and that has a message-dependent meaning.</td></tr>
    <tr><td valign=top><em>length:</em>&nbsp;</td><td>a value (in the host by order) which will be placed into the header.length field and that represents the payload length of the message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. The serialized header is returned into the 'header' variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01890">1890</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8h-source.html#l00152">rpcap_header::plen</a>, <a class="el" href="pcap-remote_8h-source.html#l00086">RPCAP_VERSION</a>, <a class="el" href="pcap-remote_8h-source.html#l00150">rpcap_header::type</a>, <a class="el" href="pcap-remote_8h-source.html#l00151">rpcap_header::value</a>, and <a class="el" href="pcap-remote_8h-source.html#l00149">rpcap_header::ver</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="pcap-remote.c::rpcap_deseraddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_deseraddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sockaddrin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sockaddrout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It traslates (i.e. de-serializes) a 'sockaddr_storage' structure from the network byte order to the host byte order.
<p>
It accepts a 'sockaddr_storage' structure as it is received from the network and it converts it into the host byte order (by means of a set of ntoh() ). The function will allocate the 'sockaddrout' variable according to the address family in use. In case the address does not belong to the AF_INET nor AF_INET6 families, 'sockaddrout' is not allocated and a NULL pointer is returned. This usually happens because that address does not exist on the other host, so the RPCAP daemon sent a 'sockaddr_storage' structure containing all 'zero' values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sockaddrin:</em>&nbsp;</td><td>a 'sockaddr_storage' pointer to the variable that has to be de-serialized.</td></tr>
    <tr><td valign=top><em>sockaddrout:</em>&nbsp;</td><td>a 'sockaddr_storage' pointer to the variable that will contain the de-serialized data. The structure returned can be either a 'sockaddr_in' or 'sockaddr_in6'. This variable will be allocated automatically inside this function.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. Basically, the error can be only the fact that the malloc() failed to allocate memory. The error message is returned in the 'errbuf' variable, while the deserialized address is returned into the 'sockaddrout' variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>This function supports only AF_INET and AF_INET6 address families.<p>
The sockaddrout (if not NULL) must be deallocated by the user. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00133">133</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>.    </td>
  </tr>
</table>
<a name="a24" doxytag="pcap-remote.c::rpcap_remoteact_getsock"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_remoteact_getsock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>host</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It returns the socket currently used for this active connection (active mode only).
<p>
This function is just for internal use; it returns the socket ID of the active connection currently opened.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>host:</em>&nbsp;</td><td>a string that keeps the host name of the host for which we want to get the socket ID for that active connection.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the socket identifier if everything is fine, '0' if this host is not in the active host list. It returns '-1' in case of error. The error message is returned into the errbuf variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Win32: be carefully not to assign the returning value of this call to a SOCKET directly. It should lead to wrong results, since Win32 sockets are unsigned int; therefore a negative value could not be handled correctly. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l02086">2086</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="pcap-remote_8c-source.html#l00079">activeHosts</a>, <a class="el" href="pcap-remote_8h-source.html#l00132">activehosts::host</a>, <a class="el" href="pcap-remote_8h-source.html#l00134">activehosts::next</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00133">activehosts::sockctrl</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="pcap-remote.c::rpcap_sendauth"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_sendauth </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends the authentication message.
<p>
It sends the authentication parameters on the control socket. Ths function is required in order to open the connection with the other end party.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket we are currently using.</td></tr>
    <tr><td valign=top><em>auth:</em>&nbsp;</td><td>authentication parameters that have to be sent.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be network problem ot the fact that the authorization failed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. The error message could be also 'the authentication failed'. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01752">1752</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="remote-ext_8h-source.html#l00192">pcap_rmtauth::password</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00282">RPCAP_MSG_AUTH_REPLY</a>, <a class="el" href="pcap-remote_8h-source.html#l00267">RPCAP_MSG_ERROR</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="remote-ext_8h-source.html#l00204">RPCAP_RMTAUTH_NULL</a>, <a class="el" href="remote-ext_8h-source.html#l00215">RPCAP_RMTAUTH_PWD</a>, <a class="el" href="pcap-remote_8h-source.html#l00250">rpcap_auth::slen1</a>, <a class="el" href="pcap-remote_8h-source.html#l00251">rpcap_auth::slen2</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, <a class="el" href="pcap-remote_8h-source.html#l00248">rpcap_auth::type</a>, <a class="el" href="remote-ext_8h-source.html#l00176">pcap_rmtauth::type</a>, <a class="el" href="pcap-remote_8h-source.html#l00113">uint16</a>, and <a class="el" href="remote-ext_8h-source.html#l00184">pcap_rmtauth::username</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a20" doxytag="pcap-remote.c::rpcap_senderror"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rpcap_senderror </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>error</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errcode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends a RPCAP error to the other peer.
<p>
This function has to be called when the main program detects an error. This funcion will send on the other peer the 'buffer' specified by the user. This function *does not* request a RPCAP CLOSE connection. A CLOSE command must be sent explicitely by the program, since we do not know it the error can be recovered in some way or it is a non-recoverable one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket we are currently using.</td></tr>
    <tr><td valign=top><em>error:</em>&nbsp;</td><td>an user-allocated (and '0' termined) buffer that contains the error description thas has to be transmitted on the other peer. The error message cannot be longer than PCAP_ERRBUF_SIZE.</td></tr>
    <tr><td valign=top><em>errcode:</em>&nbsp;</td><td>a integer which tells the other party the type of error we had; currently is is not too much used.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). It could be network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l01707">1707</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
References <a class="el" href="incs_2pcap_8h-source.html#l00059">PCAP_ERRBUF_SIZE</a>, <a class="el" href="pcap-remote_8c-source.html#l01890">rpcap_createhdr()</a>, <a class="el" href="pcap-remote_8h-source.html#l00096">RPCAP_NETBUF_SIZE</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>, and <a class="el" href="pcap-remote_8h-source.html#l00113">uint16</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a3" doxytag="pcap-remote.c::activeHosts"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structactivehosts.html">activehosts</a>* activeHosts
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Keeps a list of all the opened connections in the active mode.
<p>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00079">79</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-new_8c-source.html#l01285">pcap_remoteact_list()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="pcap-remote.c::fakeerrbuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char fakeerrbuf[PCAP_ERRBUF_SIZE + 1]
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="pcap-remote_8c-source.html#l00075">75</a> of file <a class="el" href="pcap-remote_8c-source.html">pcap-remote.c</a>.    </td>
  </tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
