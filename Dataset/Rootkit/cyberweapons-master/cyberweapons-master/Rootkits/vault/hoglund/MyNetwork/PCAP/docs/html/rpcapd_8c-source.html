<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>rpcapd.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>rpcapd.c</h1><a href="rpcapd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2002 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 
00034 
00035 
00036 
00037 <span class="preprocessor">#include &lt;errno.h&gt;</span>      <span class="comment">// for the errno variable</span>
00038 <span class="preprocessor">#include &lt;string.h&gt;</span>     <span class="comment">// for strtok, etc</span>
00039 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>     <span class="comment">// for malloc(), free(), ...</span>
00040 <span class="preprocessor">#include &lt;<a class="code" href="funcs_2pcap_8h.html">pcap.h</a>&gt;</span>       <span class="comment">// for PCAP_ERRBUF_SIZE</span>
00041 <span class="preprocessor">#include &lt;signal.h&gt;</span>     <span class="comment">// for signal()</span>
00042 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00043 <span class="preprocessor">#include "<a class="code" href="rpcapd_8h.html">rpcapd.h</a>"</span>
00044 <span class="preprocessor">#include "<a class="code" href="fileconf_8h.html">fileconf.h</a>"</span>   <span class="comment">// for the configuration file management</span>
00045 <span class="preprocessor">#include "<a class="code" href="pcap-remote_8h.html">pcap-remote.h</a>"</span>
00046 <span class="preprocessor">#include "<a class="code" href="daemon_8h.html">daemon.h</a>"</span>     <span class="comment">// the true main() method of this daemon</span>
00047 <span class="preprocessor">#include "<a class="code" href="utils_8h.html">utils.h</a>"</span>      <span class="comment">// Missing calls and such</span>
00048 <span class="preprocessor">#include "<a class="code" href="sockutils_8h.html">sockutils.h</a>"</span>  <span class="comment">// for socket calls</span>
00049 
00050 <span class="preprocessor">#ifndef WIN32</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>     <span class="comment">// for exit()</span>
00052 <span class="preprocessor">#include &lt;sys/wait.h&gt;</span>   <span class="comment">// waitpid()</span>
00053 <span class="preprocessor">#else</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="win32-svc_8h.html">win32-svc.h</a>"</span>  <span class="comment">// for Win32 service stuff</span>
00055 <span class="preprocessor">#endif</span>
00056 <span class="preprocessor"></span>
00057 
00058 <span class="comment">// Global variables</span>
<a name="l00059"></a><a class="code" href="rpcapd_8c.html#a0">00059</a> <span class="keywordtype">char</span> <a class="code" href="fileconf_8c.html#a0">hostlist</a>[<a class="code" href="rpcapd_8h.html#a3">MAX_HOST_LIST</a> + 1];       
<a name="l00060"></a><a class="code" href="rpcapd_8c.html#a1">00060</a> <span class="keyword">struct </span><a class="code" href="structactive__pars.html">active_pars</a> <a class="code" href="fileconf_8c.html#a1">activelist</a>[<a class="code" href="rpcapd_8h.html#a4">MAX_ACTIVE_LIST</a>];     
<a name="l00061"></a><a class="code" href="rpcapd_8c.html#a2">00061</a> <span class="keywordtype">int</span> <a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>;                    
<a name="l00062"></a><a class="code" href="rpcapd_8c.html#a3">00062</a> <a class="code" href="group__remote__struct.html#a12">SOCKET</a> <a class="code" href="pcap-new_8c.html#a2">sockmain</a>;                        
<a name="l00063"></a><a class="code" href="rpcapd_8c.html#a4">00063</a> <span class="keywordtype">char</span> <a class="code" href="fileconf_8c.html#a3">loadfile</a>[<a class="code" href="pcap__filter_8c.html#a1">MAX_LINE</a> + 1];            
<a name="l00064"></a><a class="code" href="rpcapd_8c.html#a5">00064</a> <span class="keywordtype">int</span> <a class="code" href="rpcapd_8c.html#a5">passivemode</a>= 1;                     
<a name="l00065"></a><a class="code" href="rpcapd_8c.html#a6">00065</a> <span class="keyword">struct </span>addrinfo <a class="code" href="rpcapd_8c.html#a6">mainhints</a>;              
<a name="l00066"></a><a class="code" href="rpcapd_8c.html#a7">00066</a> <span class="keywordtype">char</span> <a class="code" href="rpcapd_8c.html#a7">address</a>[<a class="code" href="pcap__filter_8c.html#a1">MAX_LINE</a> + 1];             
<a name="l00067"></a><a class="code" href="rpcapd_8c.html#a8">00067</a> <span class="keywordtype">char</span> <a class="code" href="rpcapd_8c.html#a8">port</a>[<a class="code" href="pcap__filter_8c.html#a1">MAX_LINE</a> + 1];                
00068 
<a name="l00069"></a><a class="code" href="rpcapd_8c.html#a9">00069</a> <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="utils_8c.html#a7">optarg</a>;    <span class="comment">// for getopt()</span>
00070 
00071 
00072 
00073 <span class="comment">// Function definition</span>
00074 <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a10">main_passive</a>(<span class="keywordtype">void</span> *ptr);
00075 <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a11">main_active</a>(<span class="keywordtype">void</span> *ptr);
00076 
00077 
00078 <span class="preprocessor">#ifndef WIN32</span>
00079 <span class="preprocessor"></span><span class="keywordtype">void</span> main_cleanup_childs(<span class="keywordtype">int</span> sign);
00080 <span class="preprocessor">#endif</span>
00081 <span class="preprocessor"></span>
00082 
<a name="l00086"></a><a class="code" href="rpcapd_8c.html#a12">00086</a> <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a12">printusage</a>()
00087 {
00088     <span class="keywordtype">char</span> *usagetext =
00089     <span class="stringliteral">"USAGE:\n"</span>
00090     <span class="stringliteral">" "</span>  <a class="code" href="rpcapd_8h.html#a0">PROGRAM_NAME</a> <span class="stringliteral">" [-b &lt;address&gt;] [-p &lt;port&gt;] [-6] [-l &lt;host_list&gt;] [-a &lt;host,port&gt;]\n"</span>
00091     <span class="stringliteral">"        [-n] [-v] [-d] [-s &lt;file&gt;] [-f &lt;file&gt;]\n"</span>
00092     <span class="stringliteral">"  -b &lt;address&gt;: the address to bind to (either numeric or literal).\n"</span>
00093     <span class="stringliteral">"                Default: it binds to all local IPv4 addresses\n"</span>
00094     <span class="stringliteral">"  -p &lt;port&gt;: the port to bind to. Default: it binds to port "</span> <a class="code" href="group__remote__pri__struct.html#a4">RPCAP_DEFAULT_NETPORT</a> <span class="stringliteral">"\n"</span>
00095     <span class="stringliteral">"  -4: use only IPv4 (default both IPv4 and IPv6 waiting sockets are used)\n"</span>
00096     <span class="stringliteral">"  -l &lt;host_list&gt;: a file that keeps the list of the hosts which\n"</span>
00097     <span class="stringliteral">"                  are allowed to connect to this server (if more than one,\n"</span>
00098     <span class="stringliteral">"                  list them one per line). We suggest to use \n"</span>
00099     <span class="stringliteral">"                  literal names (instead of numeric ones) in order to avoid\n"</span>
00100     <span class="stringliteral">"                  problems with different address families\n"</span>
00101     <span class="stringliteral">"  -n: permit NULL authentication (usually used with '-l')\n"</span>
00102     <span class="stringliteral">"  -a &lt;host, port&gt;: run in active mode when connecting to 'host' on port 'port'\n"</span>
00103     <span class="stringliteral">"  -v: run in active mode only (default: if '-a' is specified, it accepts passive\n"</span>
00104     <span class="stringliteral">"      connections as well\n"</span>
00105     <span class="stringliteral">"  -d: run in daemon mode (UNIX only) or as a service (Win32 only)\n"</span>
00106     <span class="stringliteral">"      Warning (Win32): this switch is provided automatically when the service\n"</span>
00107     <span class="stringliteral">"      is started from the control panel\n"</span>
00108     <span class="stringliteral">"  -s &lt;file&gt;: save the current configuration to file\n"</span>
00109     <span class="stringliteral">"  -f &lt;file&gt;: load the current configuration from file; all the switches\n"</span>
00110     <span class="stringliteral">"             specified from the command line are ignored\n"</span>
00111    <span class="stringliteral">"  -h: print this help screen\n\n"</span>;
00112 
00113     printf(usagetext);
00114 }
00115 
00116 
00117 
<a name="l00119"></a><a class="code" href="rpcapd_8c.html#a13">00119</a> <span class="keywordtype">int</span> <a class="code" href="basic__dump_8c.html#a1">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <span class="keywordtype">char</span> *envp[])
00120 {
00121 <span class="keywordtype">char</span> savefile[<a class="code" href="pcap__filter_8c.html#a1">MAX_LINE</a> + 1];        <span class="comment">// name of the file on which we have to save the configuration</span>
00122 <span class="keywordtype">int</span> isdaemon= 0;                    <span class="comment">// Not null if the user wants to run this program as a daemon</span>
00123 <span class="keywordtype">int</span> retval;                         <span class="comment">// keeps the returning value from several functions</span>
00124 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// keeps the error string, prior to be printed</span>
00125 
00126 
00127     savefile[0]= 0;
00128     <a class="code" href="fileconf_8c.html#a3">loadfile</a>[0]= 0;
00129     <a class="code" href="fileconf_8c.html#a0">hostlist</a>[0]= 0;
00130 
00131     <span class="comment">// Initialize errbuf</span>
00132     memset(errbuf, 0, <span class="keyword">sizeof</span>(errbuf) );
00133 
00134     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a9">sock_init</a>(errbuf) == -1)
00135     {
00136         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00137         exit(-1);
00138     }
00139 
00140     strncpy(address, RPCAP_DEFAULT_NETADDR, MAX_LINE);
00141     strncpy(port, RPCAP_DEFAULT_NETPORT, MAX_LINE);
00142 
00143     <span class="comment">// Prepare to open a new server socket</span>
00144     memset(&amp;mainhints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));
00145 
00146     <a class="code" href="rpcapd_8c.html#a6">mainhints</a>.ai_family = PF_UNSPEC;
00147     <a class="code" href="rpcapd_8c.html#a6">mainhints</a>.ai_flags = AI_PASSIVE;    <span class="comment">// Ready to a bind() socket</span>
00148     <a class="code" href="rpcapd_8c.html#a6">mainhints</a>.ai_socktype = SOCK_STREAM;
00149 
00150     <span class="comment">// Getting the proper command line options</span>
00151     <span class="keywordflow">while</span> ((retval = <a class="code" href="utils_8h.html#a0">getopt</a>(argc, argv, <span class="stringliteral">"b:dhp:4l:na:s:f:v"</span>)) != -1)
00152     {
00153         <span class="keywordflow">switch</span> (retval)
00154         {
00155             <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
00156                 strncpy(address, optarg, MAX_LINE);
00157                 <span class="keywordflow">break</span>;
00158             <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00159                 strncpy(port, optarg, MAX_LINE);
00160                 <span class="keywordflow">break</span>;
00161             <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
00162                 <a class="code" href="rpcapd_8c.html#a6">mainhints</a>.ai_family = PF_INET;      <span class="comment">// IPv4 server only</span>
00163                 <span class="keywordflow">break</span>;
00164             <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00165                 isdaemon= 1;
00166                 <span class="keywordflow">break</span>;
00167             <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00168                 <a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>= 1;
00169                 <span class="keywordflow">break</span>;
00170             <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
00171                 <a class="code" href="rpcapd_8c.html#a5">passivemode</a>= 0;
00172                 <span class="keywordflow">break</span>;
00173             <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00174             {
00175                 strncpy(hostlist, optarg, <span class="keyword">sizeof</span>(hostlist) );
00176                 <span class="keywordflow">break</span>;
00177             }
00178             <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00179             {
00180             <span class="keywordtype">char</span> *tmpaddress, *tmpport;
00181             <span class="keywordtype">int</span> i= 0;
00182 
00183                 tmpaddress= strtok(optarg, RPCAP_HOSTLIST_SEP);
00184 
00185                 <span class="keywordflow">while</span> ( (tmpaddress != NULL) &amp;&amp; (i &lt; <a class="code" href="rpcapd_8h.html#a4">MAX_ACTIVE_LIST</a>) )
00186                 {
00187                     tmpport= strtok(NULL, RPCAP_HOSTLIST_SEP);
00188 
00189                     <a class="code" href="sockutils_8c.html#a3">snprintf</a>(activelist[i].address, MAX_LINE, tmpaddress);
00190                     
00191                     <span class="keywordflow">if</span> ( (tmpport == NULL) || (strcmp(tmpport, <span class="stringliteral">"DEFAULT"</span>) == 0) ) <span class="comment">// the user choose a custom port</span>
00192                         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(activelist[i].port, MAX_LINE, RPCAP_DEFAULT_NETPORT_ACTIVE);
00193                     <span class="keywordflow">else</span>
00194                         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(activelist[i].port, MAX_LINE, tmpport);
00195 
00196                     tmpaddress = strtok(NULL, RPCAP_HOSTLIST_SEP);
00197 
00198                     i++;
00199                 }
00200                 
00201                 <span class="keywordflow">if</span> (i &gt; <a class="code" href="rpcapd_8h.html#a4">MAX_ACTIVE_LIST</a>)
00202                     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Only MAX_ACTIVE_LIST active connections are currently supported."</span>, 1);
00203 
00204                 <span class="comment">// I don't initialize the remaining part of the structure, since</span>
00205                 <span class="comment">// it is already zeroed (it is a global var)</span>
00206                 <span class="keywordflow">break</span>;
00207             }
00208             <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00209                 strncpy(loadfile, optarg, MAX_LINE);
00210                 <span class="keywordflow">break</span>;
00211             <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00212                 strncpy(savefile, optarg, MAX_LINE);
00213                 <span class="keywordflow">break</span>;
00214             <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00215                 <a class="code" href="rpcapd_8c.html#a12">printusage</a>();
00216                 exit(0);
00217             <span class="keywordflow">default</span>:
00218                 <span class="keywordflow">break</span>;
00219         }
00220     }
00221 
00222     <span class="keywordflow">if</span> (savefile[0])
00223     {
00224         <span class="keywordflow">if</span> (<a class="code" href="fileconf_8c.html#a6">fileconf_save</a>(savefile) )
00225             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Error when saving the configuration to file"</span>, 1);
00226     }
00227 
00228     <span class="comment">// If the file does not exist, it keeps the settings provided by the command line</span>
00229     <span class="keywordflow">if</span> (<a class="code" href="fileconf_8c.html#a3">loadfile</a>[0])
00230         <a class="code" href="fileconf_8c.html#a5">fileconf_read</a>(0);
00231 
00232 <span class="preprocessor">#ifdef linux</span>
00233 <span class="preprocessor"></span>    <span class="comment">// SIGTERM (i.e. kill -15) is not generated in WIN32, although it is included for ANSI compatibility</span>
00234     signal(SIGTERM, main_cleanup);
00235     signal(SIGCHLD, main_cleanup_childs);
00236 <span class="preprocessor">#endif</span>
00237 <span class="preprocessor"></span>
00238     <span class="comment">// forking a daemon, if it is needed</span>
00239     <span class="keywordflow">if</span> (isdaemon)
00240     {
00241 <span class="preprocessor">    #ifndef WIN32</span>
00242 <span class="preprocessor"></span>    <span class="keywordtype">int</span> pid;
00243 
00244         <span class="comment">// Unix Network Programming, pg 336</span>
00245         <span class="keywordflow">if</span> ( (pid = fork() ) != 0)
00246             exit(0);        <span class="comment">// Parent terminates</span>
00247 
00248         <span class="comment">// First child continues</span>
00249         <span class="comment">// Set daemon mode</span>
00250         setsid();
00251         
00252         <span class="comment">// generated under unix with 'kill -HUP'</span>
00253         signal(SIGHUP, fileconf_read);
00254 
00255         <span class="keywordflow">if</span> ( (pid = fork() ) != 0)
00256             exit(0);        <span class="comment">// First child terminates</span>
00257 
00258         <span class="comment">// LINUX WARNING: the current linux implementation of pthreads requires a management thread</span>
00259         <span class="comment">// to handle some hidden stuff. So, as soon as you create the first thread, two threads are</span>
00260         <span class="comment">// created. Fom this point on, the number of threads active are always one more compared</span>
00261         <span class="comment">// to the number you're expecting</span>
00262 
00263         <span class="comment">// Second child continues</span>
00264 <span class="comment">//      umask(0);</span>
00265 <span class="comment">//      chdir("/");</span>
00266 <span class="preprocessor">    #else</span>
00267 <span class="preprocessor"></span>        <span class="comment">// We use the SIGABRT signal to kill the Win32 service</span>
00268         signal(SIGABRT, main_cleanup);
00269 
00270         <span class="comment">// If this call succeeds, it is blocking on Win32</span>
00271         <span class="keywordflow">if</span> ( <a class="code" href="win32-svc_8c.html#a5">svc_start</a>() != 1)
00272             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(1, <span class="stringliteral">"Unable to start the service"</span>);
00273 
00274         <span class="comment">// When the previous call returns, the entire application has to be stopped.</span>
00275         exit(0);
00276 <span class="preprocessor">    #endif</span>
00277 <span class="preprocessor"></span>    }
00278     <span class="keywordflow">else</span>    <span class="comment">// Console mode</span>
00279     {
00280         <span class="comment">// Enable the catching of Ctrl+C</span>
00281         signal(SIGINT, main_cleanup);
00282 
00283         printf(<span class="stringliteral">"Press CTRL + C to stop the server...\n"</span>);
00284     }
00285 
00286     <span class="comment">// If we're a Win32 service, we have already called this function in the service_main</span>
00287     <a class="code" href="rpcapd_8c.html#a14">main_startup</a>();
00288 
00289     <span class="comment">// The code should never arrive here (since the main_startup is blocking)</span>
00290     <span class="comment">//  however this avoids a compiler warning</span>
00291     exit(0);
00292 }
00293 
00294 
00295 
<a name="l00296"></a><a class="code" href="rpcapd_8c.html#a14">00296</a> <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a14">main_startup</a>(<span class="keywordtype">void</span>)
00297 {
00298 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// keeps the error string, prior to be printed</span>
00299 <span class="keyword">struct </span>addrinfo *addrinfo;              <span class="comment">// keeps the addrinfo chain; required to open a new socket</span>
00300 <span class="keywordtype">int</span> i;
00301 <span class="preprocessor">#ifdef WIN32</span>
00302 <span class="preprocessor"></span>    pthread_t threadId;                 <span class="comment">// Pthread variable that keeps the thread structures</span>
00303 <span class="preprocessor">#else</span>
00304 <span class="preprocessor"></span>    pid_t pid;
00305 <span class="preprocessor">#endif</span>
00306 <span class="preprocessor"></span>
00307     i= 0;
00308     addrinfo= NULL;
00309     memset(errbuf, 0, <span class="keyword">sizeof</span>(errbuf) );
00310 
00311     <span class="comment">// Starts all the active threads</span>
00312     <span class="keywordflow">while</span> ( (<a class="code" href="fileconf_8c.html#a1">activelist</a>[i].<a class="code" href="structactive__pars.html#m0">address</a>[0] != 0) &amp;&amp; (i &lt; <a class="code" href="rpcapd_8h.html#a4">MAX_ACTIVE_LIST</a>) )
00313     {
00314         <a class="code" href="fileconf_8c.html#a1">activelist</a>[i].<a class="code" href="structactive__pars.html#m2">ai_family</a>= <a class="code" href="rpcapd_8c.html#a6">mainhints</a>.ai_family;
00315         
00316 <span class="preprocessor">#ifdef WIN32</span>
00317 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( pthread_create( &amp;threadId, NULL, (<span class="keywordtype">void</span> *) &amp;main_active, (<span class="keywordtype">void</span> *) &amp;activelist[i]) )
00318         {
00319             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Error creating the active child thread"</span>, 1);
00320             <span class="keywordflow">continue</span>;
00321         }
00322 <span class="preprocessor">#else</span>
00323 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (pid= fork() ) == 0)   <span class="comment">// I am the child</span>
00324         {
00325             <a class="code" href="rpcapd_8c.html#a11">main_active</a>( (<span class="keywordtype">void</span> *) &amp;activelist[i]);
00326             exit(0);
00327         }
00328 <span class="preprocessor">#endif</span>
00329 <span class="preprocessor"></span>        i++;
00330     }
00331 
00332     <span class="comment">/*</span>
00333 <span class="comment">        The code that manages the active connections is not blocking; </span>
00334 <span class="comment">        vice versa, the code that manages the passive connection is blocking.</span>
00335 <span class="comment">        So, if the user do not want to run in passive mode, we have to block</span>
00336 <span class="comment">        the main thread here, otherwise the program ends and all threads</span>
00337 <span class="comment">        are stopped.</span>
00338 <span class="comment"></span>
00339 <span class="comment">        WARNING: this means that in case we have only active mode, the program does</span>
00340 <span class="comment">        not terminate even if all the child thread terminates. The user has always to</span>
00341 <span class="comment">        press Ctrl+C (or send a SIGTERM) to terminate the program.</span>
00342 <span class="comment">    */</span>
00343 
00344     <span class="keywordflow">if</span> (passivemode)
00345     {
00346     <span class="keyword">struct </span>addrinfo *tempaddrinfo;
00347 
00348         <span class="comment">// Do the work</span>
00349         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>((address[0]) ? address : NULL, port, &amp;mainhints, &amp;addrinfo, errbuf) == -1)
00350         {
00351             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00352             <span class="keywordflow">return</span>;
00353         }
00354 
00355         tempaddrinfo= addrinfo;
00356 
00357         <span class="keywordflow">while</span> (tempaddrinfo)
00358         {
00359             <span class="keywordflow">if</span> ( (<a class="code" href="pcap-new_8c.html#a2">sockmain</a>= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(tempaddrinfo, SOCKOPEN_SERVER, SOCKET_MAXCONN, errbuf)) == -1)
00360             {
00361                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00362                 tempaddrinfo= tempaddrinfo-&gt;ai_next;
00363                 <span class="keywordflow">continue</span>;
00364             }
00365 
00366 <span class="preprocessor">#ifdef WIN32</span>
00367 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( pthread_create( &amp;threadId, NULL, (<span class="keywordtype">void</span> *) &amp;main_passive, (<span class="keywordtype">void</span> *) &amp;sockmain ) )
00368             {
00369                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Error creating the passive child thread"</span>, 1);
00370                 <span class="keywordflow">continue</span>;
00371             }
00372 <span class="preprocessor">#else</span>
00373 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( (pid= fork() ) == 0)   <span class="comment">// I am the child</span>
00374             {
00375                 <a class="code" href="rpcapd_8c.html#a10">main_passive</a>( (<span class="keywordtype">void</span> *) &amp;sockmain);
00376                 <span class="keywordflow">return</span>;
00377 <span class="comment">//              exit(0);</span>
00378             }
00379 <span class="preprocessor">#endif</span>
00380 <span class="preprocessor"></span><span class="comment">//          main_passive(sockmain);</span>
00381             tempaddrinfo= tempaddrinfo-&gt;ai_next;
00382         }
00383 
00384         freeaddrinfo(addrinfo);
00385     }
00386 
00387     <span class="comment">// All the previous calls are no blocking, so the main line of execution goes here</span>
00388     <span class="comment">// and I have to avoid that the program terminates</span>
00389     <span class="keywordflow">while</span> (1)
00390         <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(10*60*1000); <span class="comment">// it wakes up every 10 minutes; it seems to me reasonable</span>
00391 }
00392 
00393 
00394 <span class="comment">/*</span>
00395 <span class="comment">    \brief Closes gracefully (more or less) the program.</span>
00396 <span class="comment"></span>
00397 <span class="comment">    This function is called:</span>
00398 <span class="comment">    - when we're running in console</span>
00399 <span class="comment">    - when we're running as a Win32 service (in case we press STOP)</span>
00400 <span class="comment"></span>
00401 <span class="comment">    It is not called when we are running as a daemon on UNIX, since</span>
00402 <span class="comment">    we do not define a signal in order to terminate gracefully the daemon.</span>
00403 <span class="comment"></span>
00404 <span class="comment">    This function makes a fast cleanup (it does not clean everything, as </span>
00405 <span class="comment">    you can see from the fact that it uses kill() on UNIX), closes</span>
00406 <span class="comment">    the main socket, free winsock resources (on Win32) and exits the</span>
00407 <span class="comment">    program.</span>
00408 <span class="comment">*/</span>
<a name="l00409"></a><a class="code" href="rpcapd_8c.html#a15">00409</a> <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a15">main_cleanup</a>(<span class="keywordtype">int</span> sign)
00410 {
00411 <span class="preprocessor">#ifndef WIN32</span>
00412 <span class="preprocessor"></span>    <span class="comment">// Sends a KILL signal to all the processes</span>
00413     <span class="comment">// that share the same process group (i.e. kills all the childs)</span>
00414     kill(0, SIGKILL);
00415 <span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span>
00417     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(PROGRAM_NAME <span class="stringliteral">" is closing.\n"</span>, 1);
00418 
00419     <span class="keywordflow">if</span> (sockmain)
00420         closesocket(sockmain);
00421     <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>();
00422 
00423     <span class="comment">/*</span>
00424 <span class="comment">        This code is executed under the following conditions:</span>
00425 <span class="comment">        - SIGTERM: we're under UNIX, and the user kills us with 'kill -15' </span>
00426 <span class="comment">        (no matter is we're a daemon or in a console mode)</span>
00427 <span class="comment">        - SIGINT: we're in console mode and the user sends us a Ctrl+C </span>
00428 <span class="comment">        (SIGINT signal), no matter if we're UNIX or Win32</span>
00429 <span class="comment"></span>
00430 <span class="comment">        In all these cases, we have to terminate the program.</span>
00431 <span class="comment">        The case that still remains is if we're a Win32 service: in this case,</span>
00432 <span class="comment">        we're a child thread, and we want just to terminate ourself. This is because</span>
00433 <span class="comment">        the exit(0) will be invoked by the main thread, which is blocked waiting that</span>
00434 <span class="comment">        all childs terminates. We are forced to call exit from the main thread otherwise</span>
00435 <span class="comment">        the Win32 service control manager (SCM) does not work well.</span>
00436 <span class="comment">    */</span>
00437     <span class="keywordflow">if</span> ( (sign == SIGTERM) || (sign == SIGINT) )
00438         exit(0);
00439     <span class="keywordflow">else</span>
00440         <span class="keywordflow">return</span>;
00441 }
00442 
00443 
00444 
00445 <span class="preprocessor">#ifdef linux</span>
00446 <span class="preprocessor"></span>
00447 <span class="keywordtype">void</span> main_cleanup_childs(<span class="keywordtype">int</span> sign)
00448 {
00449 pid_t pid;
00450 <span class="keywordtype">int</span> stat;
00451 
00452     <span class="comment">// For reference, Stevens, pg 128</span>
00453 
00454     <span class="keywordflow">while</span> ( (pid= waitpid(-1, &amp;stat, WNOHANG) ) &gt; 0)
00455         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Child terminated"</span>, 1);
00456 
00457     <span class="keywordflow">return</span>;
00458 }
00459 
00460 <span class="preprocessor">#endif</span>
00461 <span class="preprocessor"></span>
00462 
00463 
00464 
00465 
<a name="l00478"></a><a class="code" href="rpcapd_8c.html#a10">00478</a> <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a10">main_passive</a>(<span class="keywordtype">void</span> *ptr)
00479 {
00480 <span class="keywordtype">char</span> <a class="code" href="sockutils_8c.html#a6">fakeerrbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// needed to keep the message due to an error that we want to discard.</span>
00481 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// keeps the error string, prior to be printed</span>
00482 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockctrl;                <span class="comment">// keeps the socket ID for this control connection</span>
00483 <span class="keyword">struct </span>sockaddr_storage from;   <span class="comment">// generic sockaddr_storage variable</span>
00484 socklen_t fromlen;              <span class="comment">// keeps the length of the sockaddr_storage variable</span>
00485 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> <a class="code" href="pcap-new_8c.html#a2">sockmain</a>;
00486 
00487 <span class="preprocessor">#ifdef linux</span>
00488 <span class="preprocessor"></span>    pid_t pid;
00489 <span class="preprocessor">#endif</span>
00490 <span class="preprocessor"></span>
00491     <a class="code" href="pcap-new_8c.html#a2">sockmain</a>= *((<a class="code" href="group__remote__struct.html#a12">SOCKET</a> *) ptr);
00492     <span class="comment">// Initialize errbuf</span>
00493     memset(errbuf, 0, <span class="keyword">sizeof</span>(errbuf) );
00494 
00495     <span class="comment">// main thread loop</span>
00496     <span class="keywordflow">while</span> (1)
00497     {
00498     pthread_t threadId;                 <span class="comment">// Pthread variable that keeps the thread structures</span>
00499     <span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *pars;         <span class="comment">// parameters needed by the daemon_serviceloop()</span>
00500 
00501         <span class="comment">// Connection creation</span>
00502         fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
00503 
00504         sockctrl= accept(sockmain, (<span class="keyword">struct</span> sockaddr *) &amp;from, &amp;fromlen);
00505         
00506         <span class="keywordflow">if</span> (sockctrl == -1)
00507         {
00508             <span class="comment">// The accept() call can return this error when a signal is catched</span>
00509             <span class="comment">// In this case, we have simply to ignore this error code</span>
00510             <span class="comment">// Stevens, pg 124</span>
00511 <span class="preprocessor">#ifdef WIN32</span>
00512 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (WSAGetLastError() == WSAEINTR)
00513 <span class="preprocessor">#else</span>
00514 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (errno == EINTR)
00515 <span class="preprocessor">#endif</span>
00516 <span class="preprocessor"></span>                <span class="keywordflow">continue</span>;
00517 
00518             <span class="comment">// Don't check for errors here, since the error can be due to the fact that the thread </span>
00519             <span class="comment">// has been killed</span>
00520             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"accept(): "</span>, errbuf, PCAP_ERRBUF_SIZE);
00521             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00522             <span class="keywordflow">continue</span>;
00523         }
00524 
00525         <span class="comment">// checks if the connecting host is among the ones allowed</span>
00526         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a19">sock_check_hostlist</a>(hostlist, RPCAP_HOSTLIST_SEP, &amp;from, errbuf) )
00527         {
00528             <a class="code" href="pcap-remote_8c.html#a20">rpcap_senderror</a>(sockctrl, errbuf, PCAP_ERR_HOSTNOAUTH, fakeerrbuf);
00529             <a class="code" href="sockutils_8c.html#a12">sock_close</a>(sockctrl, fakeerrbuf);
00530             <span class="keywordflow">continue</span>;
00531         }
00532 
00533 
00534 <span class="preprocessor">#ifdef WIN32</span>
00535 <span class="preprocessor"></span>        <span class="comment">// in case of passive mode, this variable is deallocated by the daemon_serviceloop()</span>
00536         pars= (<span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *) malloc ( sizeof(struct daemon_slpars) );
00537         <span class="keywordflow">if</span> (pars == NULL)
00538         {
00539             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00540             <span class="keywordflow">continue</span>;
00541         }
00542 
00543         pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>= sockctrl;
00544         pars-&gt;<a class="code" href="structdaemon__slpars.html#m3">activeclose</a>= 0;       <span class="comment">// useless in passive mode</span>
00545         pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>= 0;
00546         pars-&gt;<a class="code" href="structdaemon__slpars.html#m2">nullAuthAllowed</a>= <a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>;
00547 
00548         <span class="keywordflow">if</span> ( pthread_create( &amp;threadId, NULL, (<span class="keywordtype">void</span> *) &amp;daemon_serviceloop, (<span class="keywordtype">void</span> *) pars) )
00549         {
00550             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"Error creating the child thread"</span>, 1);
00551             <span class="keywordflow">continue</span>;
00552         }
00553 
00554 <span class="preprocessor">#else</span>
00555 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (pid= fork() ) == 0)   <span class="comment">// I am the child</span>
00556         {
00557             <span class="comment">// in case of passive mode, this variable is deallocated by the daemon_serviceloop()</span>
00558             pars= (<span class="keyword">struct </span>daemon_slpars *) malloc ( sizeof(struct daemon_slpars) );
00559             <span class="keywordflow">if</span> (pars == NULL)
00560             {
00561                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00562                 exit(0);
00563             }
00564 
00565             pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>= sockctrl;
00566             pars-&gt;<a class="code" href="structdaemon__slpars.html#m3">activeclose</a>= 0;       <span class="comment">// useless in passive mode</span>
00567             pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>= 0;
00568             pars-&gt;<a class="code" href="structdaemon__slpars.html#m2">nullAuthAllowed</a>= <a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>;
00569 
00570             <span class="comment">// Close the main socket (must be open only in the parent)</span>
00571             closesocket(sockmain);
00572 
00573             <a class="code" href="daemon_8c.html#a13">daemon_serviceloop</a>( (<span class="keywordtype">void</span> *) pars);
00574             exit(0);
00575         }
00576 
00577         <span class="comment">// I am the parent</span>
00578         <span class="comment">// Close the childsocket (must be open only in the child)</span>
00579         closesocket(sockctrl);
00580 <span class="preprocessor">#endif</span>
00581 <span class="preprocessor"></span>
00582         <span class="comment">// loop forever, until interrupted</span>
00583     }
00584 }
00585 
00586 
00587 
00588 
<a name="l00596"></a><a class="code" href="rpcapd_8c.html#a11">00596</a> <span class="keywordtype">void</span> <a class="code" href="rpcapd_8c.html#a11">main_active</a>(<span class="keywordtype">void</span> *ptr)
00597 {
00598 <span class="keywordtype">char</span> <a class="code" href="inet_8c.html#a5">errbuf</a>[<a class="code" href="group__wpcap__def.html#a8">PCAP_ERRBUF_SIZE</a> + 1];  <span class="comment">// keeps the error string, prior to be printed</span>
00599 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sockctrl;                    <span class="comment">// keeps the socket ID for this control connection</span>
00600 <span class="keyword">struct </span>addrinfo hints;              <span class="comment">// temporary struct to keep settings needed to open the new socket</span>
00601 <span class="keyword">struct </span>addrinfo *addrinfo;          <span class="comment">// keeps the addrinfo chain; required to open a new socket</span>
00602 <span class="keyword">struct </span><a class="code" href="structactive__pars.html">active_pars</a> *activepars;
00603 <span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *pars;         <span class="comment">// parameters needed by the daemon_serviceloop()</span>
00604 
00605 
00606     activepars= (<span class="keyword">struct </span><a class="code" href="structactive__pars.html">active_pars</a> *) ptr;
00607 
00608     <span class="comment">// Prepare to open a new server socket</span>
00609     memset(&amp;hints, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));
00610                                     <span class="comment">// WARNING Currently it supports only ONE socket family among IPv4 and IPv6 </span>
00611     hints.ai_family = AF_INET;      <span class="comment">// PF_UNSPEC to have both IPv4 and IPv6 server</span>
00612     hints.ai_socktype = SOCK_STREAM;
00613     hints.ai_family= activepars-&gt;ai_family;
00614 
00615     <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Connecting to host %s, port %s, using protocol %s"</span>,
00616             activepars-&gt;address, activepars-&gt;port, (hints.ai_family == AF_INET) ? <span class="stringliteral">"IPv4"</span>: <span class="stringliteral">"IPv6"</span> );
00617     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00618 
00619     <span class="comment">// Initialize errbuf</span>
00620     memset(errbuf, 0, <span class="keyword">sizeof</span>(errbuf) );
00621 
00622     <span class="comment">// Do the work</span>
00623     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(activepars-&gt;address, activepars-&gt;port, &amp;hints, &amp;addrinfo, errbuf) == -1)
00624     {
00625         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00626         <span class="keywordflow">return</span>;
00627     }
00628 
00629     <span class="keywordflow">while</span> (1)
00630     {
00631     <span class="keywordtype">int</span> activeclose;
00632 
00633         <span class="keywordflow">if</span> ( (sockctrl= <a class="code" href="sockutils_8c.html#a11">sock_open</a>(addrinfo, SOCKOPEN_CLIENT, 0, errbuf)) == -1)
00634         {
00635             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00636             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"Error connecting to host %s, port %s, using protocol %s"</span>,
00637                     activepars-&gt;address, activepars-&gt;port, (hints.ai_family == AF_INET) ? <span class="stringliteral">"IPv4"</span>: <span class="stringliteral">"IPv6"</span> );
00638             <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00639             <a class="code" href="pcap-remote_8c.html#a19">pthread_suspend</a>(RPCAP_ACTIVE_WAIT * 1000);
00640             <span class="keywordflow">continue</span>;
00641         }
00642 
00643         pars= (<span class="keyword">struct </span><a class="code" href="structdaemon__slpars.html">daemon_slpars</a> *) malloc ( sizeof(struct daemon_slpars) );
00644         <span class="keywordflow">if</span> (pars == NULL)
00645         {
00646             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"malloc() failed: %s"</span>, <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00647             <span class="keywordflow">continue</span>;
00648         }
00649 
00650         pars-&gt;<a class="code" href="structdaemon__slpars.html#m0">sockctrl</a>= sockctrl;
00651         pars-&gt;<a class="code" href="structdaemon__slpars.html#m3">activeclose</a>= 0;
00652         pars-&gt;<a class="code" href="structdaemon__slpars.html#m1">isactive</a>= 1;
00653         pars-&gt;<a class="code" href="structdaemon__slpars.html#m2">nullAuthAllowed</a>= <a class="code" href="fileconf_8c.html#a2">nullAuthAllowed</a>;
00654 
00655         <a class="code" href="daemon_8c.html#a13">daemon_serviceloop</a>( (<span class="keywordtype">void</span> *) pars);
00656 
00657         activeclose= pars-&gt;<a class="code" href="structdaemon__slpars.html#m3">activeclose</a>;
00658 
00659         free(pars);
00660         <span class="comment">// If the connection is closed by the user explicitely, don't try to connect to it again</span>
00661         <span class="comment">// just exit the program</span>
00662         <span class="keywordflow">if</span> (activeclose == 1)
00663             <span class="keywordflow">break</span>;
00664     }
00665 }
00666 
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
