<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>savefile.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>savefile.c</h1><a href="savefile_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1993, 1994, 1995, 1996, 1997</span>
00003 <span class="comment"> *  The Regents of the University of California.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the University of California,</span>
00013 <span class="comment"> * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * savefile.c - supports offline use of tcpdump</span>
00022 <span class="comment"> *  Extraction/creation by Jeffrey Mogul, DECWRL</span>
00023 <span class="comment"> *  Modified by Steve McCanne, LBL.</span>
00024 <span class="comment"> *</span>
00025 <span class="comment"> * Used to save the received packet headers, after filtering, to</span>
00026 <span class="comment"> * a file, and then read them later.</span>
00027 <span class="comment"> * The first record in the file contains saved values for the machine</span>
00028 <span class="comment"> * dependent values so we can print the dump file on any architecture.</span>
00029 <span class="comment"> */</span>
00030 
00031 <span class="preprocessor">#ifndef lint</span>
<a name="l00032"></a><a class="code" href="savefile_8c.html#a51">00032</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="savefile_8c.html#a51">rcsid</a>[] =
00033     <span class="stringliteral">"@(#) $Header: /tcpdump/master/libpcap/savefile.c,v 1.75 2003/01/23 07:24:53 guy Exp $ (LBL)"</span>;
00034 <span class="preprocessor">#endif</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00041 <span class="preprocessor">#include &lt;memory.h&gt;</span>
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00043 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00044 <span class="preprocessor">#include &lt;string.h&gt;</span>
00045 
00046 <span class="preprocessor">#include "pcap-int.h"</span>
00047 
00048 <span class="preprocessor">#ifdef HAVE_OS_PROTO_H</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#include "os-proto.h"</span>
00050 <span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>
<a name="l00052"></a><a class="code" href="savefile_8c.html#a0">00052</a> <span class="preprocessor">#define TCPDUMP_MAGIC 0xa1b2c3d4</span>
<a name="l00053"></a><a class="code" href="savefile_8c.html#a1">00053</a> <span class="preprocessor"></span><span class="preprocessor">#define PATCHED_TCPDUMP_MAGIC 0xa1b2cd34</span>
00054 <span class="preprocessor"></span>
00055 <span class="comment">/*</span>
00056 <span class="comment"> * We use the "receiver-makes-right" approach to byte order,</span>
00057 <span class="comment"> * because time is at a premium when we are writing the file.</span>
00058 <span class="comment"> * In other words, the pcap_file_header and pcap_pkthdr,</span>
00059 <span class="comment"> * records are written in host byte order.</span>
00060 <span class="comment"> * Note that the packets are always written in network byte order.</span>
00061 <span class="comment"> *</span>
00062 <span class="comment"> * ntoh[ls] aren't sufficient because we might need to swap on a big-endian</span>
00063 <span class="comment"> * machine (if the file was written in little-end order).</span>
00064 <span class="comment"> */</span>
<a name="l00065"></a><a class="code" href="savefile_8c.html#a2">00065</a> <span class="preprocessor">#define SWAPLONG(y) \</span>
00066 <span class="preprocessor">((((y)&amp;0xff)&lt;&lt;24) | (((y)&amp;0xff00)&lt;&lt;8) | (((y)&amp;0xff0000)&gt;&gt;8) | (((y)&gt;&gt;24)&amp;0xff))</span>
<a name="l00067"></a><a class="code" href="savefile_8c.html#a3">00067</a> <span class="preprocessor"></span><span class="preprocessor">#define SWAPSHORT(y) \</span>
00068 <span class="preprocessor">    ( (((y)&amp;0xff)&lt;&lt;8) | ((u_short)((y)&amp;0xff00)&gt;&gt;8) )</span>
00069 <span class="preprocessor"></span>
<a name="l00070"></a><a class="code" href="savefile_8c.html#a4">00070</a> <span class="preprocessor">#define SFERR_TRUNC     1</span>
<a name="l00071"></a><a class="code" href="savefile_8c.html#a5">00071</a> <span class="preprocessor"></span><span class="preprocessor">#define SFERR_BADVERSION    2</span>
<a name="l00072"></a><a class="code" href="savefile_8c.html#a6">00072</a> <span class="preprocessor"></span><span class="preprocessor">#define SFERR_BADF      3</span>
<a name="l00073"></a><a class="code" href="savefile_8c.html#a7">00073</a> <span class="preprocessor"></span><span class="preprocessor">#define SFERR_EOF       4 </span><span class="comment">/* not really an error, just a status */</span>
00074 
00075 <span class="comment">/*</span>
00076 <span class="comment"> * We don't write DLT_* values to the capture file header, because</span>
00077 <span class="comment"> * they're not the same on all platforms.</span>
00078 <span class="comment"> *</span>
00079 <span class="comment"> * Unfortunately, the various flavors of BSD have not always used the same</span>
00080 <span class="comment"> * numerical values for the same data types, and various patches to</span>
00081 <span class="comment"> * libpcap for non-BSD OSes have added their own DLT_* codes for link</span>
00082 <span class="comment"> * layer encapsulation types seen on those OSes, and those codes have had,</span>
00083 <span class="comment"> * in some cases, values that were also used, on other platforms, for other</span>
00084 <span class="comment"> * link layer encapsulation types.</span>
00085 <span class="comment"> *</span>
00086 <span class="comment"> * This means that capture files of a type whose numerical DLT_* code</span>
00087 <span class="comment"> * means different things on different BSDs, or with different versions</span>
00088 <span class="comment"> * of libpcap, can't always be read on systems other than those like</span>
00089 <span class="comment"> * the one running on the machine on which the capture was made.</span>
00090 <span class="comment"> *</span>
00091 <span class="comment"> * Instead, we define here a set of LINKTYPE_* codes, and map DLT_* codes</span>
00092 <span class="comment"> * to LINKTYPE_* codes when writing a savefile header, and map LINKTYPE_*</span>
00093 <span class="comment"> * codes to DLT_* codes when reading a savefile header.</span>
00094 <span class="comment"> *</span>
00095 <span class="comment"> * For those DLT_* codes that have, as far as we know, the same values on</span>
00096 <span class="comment"> * all platforms (DLT_NULL through DLT_FDDI), we define LINKTYPE_xxx as</span>
00097 <span class="comment"> * DLT_xxx; that way, captures of those types can still be read by</span>
00098 <span class="comment"> * versions of libpcap that map LINKTYPE_* values to DLT_* values, and</span>
00099 <span class="comment"> * captures of those types written by versions of libpcap that map DLT_</span>
00100 <span class="comment"> * values to LINKTYPE_ values can still be read by older versions</span>
00101 <span class="comment"> * of libpcap.</span>
00102 <span class="comment"> *</span>
00103 <span class="comment"> * The other LINKTYPE_* codes are given values starting at 100, in the</span>
00104 <span class="comment"> * hopes that no DLT_* code will be given one of those values.</span>
00105 <span class="comment"> *</span>
00106 <span class="comment"> * In order to ensure that a given LINKTYPE_* code's value will refer to</span>
00107 <span class="comment"> * the same encapsulation type on all platforms, you should not allocate</span>
00108 <span class="comment"> * a new LINKTYPE_* value without consulting "tcpdump-workers@tcpdump.org".</span>
00109 <span class="comment"> * The tcpdump developers will allocate a value for you, and will not</span>
00110 <span class="comment"> * subsequently allocate it to anybody else; that value will be added to</span>
00111 <span class="comment"> * the "pcap.h" in the tcpdump.org CVS repository, so that a future</span>
00112 <span class="comment"> * libpcap release will include it.</span>
00113 <span class="comment"> *</span>
00114 <span class="comment"> * You should, if possible, also contribute patches to libpcap and tcpdump</span>
00115 <span class="comment"> * to handle the new encapsulation type, so that they can also be checked</span>
00116 <span class="comment"> * into the tcpdump.org CVS repository and so that they will appear in</span>
00117 <span class="comment"> * future libpcap and tcpdump releases.</span>
00118 <span class="comment"> */</span>
<a name="l00119"></a><a class="code" href="savefile_8c.html#a8">00119</a> <span class="preprocessor">#define LINKTYPE_NULL       DLT_NULL</span>
<a name="l00120"></a><a class="code" href="savefile_8c.html#a9">00120</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_ETHERNET   DLT_EN10MB  </span><span class="comment">/* also for 100Mb and up */</span>
<a name="l00121"></a><a class="code" href="savefile_8c.html#a10">00121</a> <span class="preprocessor">#define LINKTYPE_EXP_ETHERNET   DLT_EN3MB   </span><span class="comment">/* 3Mb experimental Ethernet */</span>
<a name="l00122"></a><a class="code" href="savefile_8c.html#a11">00122</a> <span class="preprocessor">#define LINKTYPE_AX25       DLT_AX25</span>
<a name="l00123"></a><a class="code" href="savefile_8c.html#a12">00123</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_PRONET     DLT_PRONET</span>
<a name="l00124"></a><a class="code" href="savefile_8c.html#a13">00124</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_CHAOS      DLT_CHAOS</span>
<a name="l00125"></a><a class="code" href="savefile_8c.html#a14">00125</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_TOKEN_RING DLT_IEEE802 </span><span class="comment">/* DLT_IEEE802 is used for Token Ring */</span>
<a name="l00126"></a><a class="code" href="savefile_8c.html#a15">00126</a> <span class="preprocessor">#define LINKTYPE_ARCNET     DLT_ARCNET  </span><span class="comment">/* BSD-style headers */</span>
<a name="l00127"></a><a class="code" href="savefile_8c.html#a16">00127</a> <span class="preprocessor">#define LINKTYPE_SLIP       DLT_SLIP</span>
<a name="l00128"></a><a class="code" href="savefile_8c.html#a17">00128</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_PPP        DLT_PPP</span>
<a name="l00129"></a><a class="code" href="savefile_8c.html#a18">00129</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKTYPE_FDDI       DLT_FDDI</span>
00130 <span class="preprocessor"></span>
00131 <span class="comment">/*</span>
00132 <span class="comment"> * LINKTYPE_PPP is for use when there might, or might not, be an RFC 1662</span>
00133 <span class="comment"> * PPP in HDLC-like framing header (with 0xff 0x03 before the PPP protocol</span>
00134 <span class="comment"> * field) at the beginning of the packet.</span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> * This is for use when there is always such a header; the address field</span>
00137 <span class="comment"> * might be 0xff, for regular PPP, or it might be an address field for Cisco</span>
00138 <span class="comment"> * point-to-point with HDLC framing as per section 4.3.1 of RFC 1547 ("Cisco</span>
00139 <span class="comment"> * HDLC").  This is, for example, what you get with NetBSD's DLT_PPP_SERIAL.</span>
00140 <span class="comment"> *</span>
00141 <span class="comment"> * We give it the same value as NetBSD's DLT_PPP_SERIAL, in the hopes that</span>
00142 <span class="comment"> * nobody else will choose a DLT_ value of 50, and so that DLT_PPP_SERIAL</span>
00143 <span class="comment"> * captures will be written out with a link type that NetBSD's tcpdump</span>
00144 <span class="comment"> * can read.</span>
00145 <span class="comment"> */</span>
<a name="l00146"></a><a class="code" href="savefile_8c.html#a19">00146</a> <span class="preprocessor">#define LINKTYPE_PPP_HDLC   50      </span><span class="comment">/* PPP in HDLC-like framing */</span>
00147 
<a name="l00148"></a><a class="code" href="savefile_8c.html#a20">00148</a> <span class="preprocessor">#define LINKTYPE_PPP_ETHER  51      </span><span class="comment">/* NetBSD PPP-over-Ethernet */</span>
00149 
<a name="l00150"></a><a class="code" href="savefile_8c.html#a21">00150</a> <span class="preprocessor">#define LINKTYPE_ATM_RFC1483    100     </span><span class="comment">/* LLC/SNAP-encapsulated ATM */</span>
<a name="l00151"></a><a class="code" href="savefile_8c.html#a22">00151</a> <span class="preprocessor">#define LINKTYPE_RAW        101     </span><span class="comment">/* raw IP */</span>
<a name="l00152"></a><a class="code" href="savefile_8c.html#a23">00152</a> <span class="preprocessor">#define LINKTYPE_SLIP_BSDOS 102     </span><span class="comment">/* BSD/OS SLIP BPF header */</span>
<a name="l00153"></a><a class="code" href="savefile_8c.html#a24">00153</a> <span class="preprocessor">#define LINKTYPE_PPP_BSDOS  103     </span><span class="comment">/* BSD/OS PPP BPF header */</span>
<a name="l00154"></a><a class="code" href="savefile_8c.html#a25">00154</a> <span class="preprocessor">#define LINKTYPE_C_HDLC     104     </span><span class="comment">/* Cisco HDLC */</span>
<a name="l00155"></a><a class="code" href="savefile_8c.html#a26">00155</a> <span class="preprocessor">#define LINKTYPE_IEEE802_11 105     </span><span class="comment">/* IEEE 802.11 (wireless) */</span>
<a name="l00156"></a><a class="code" href="savefile_8c.html#a27">00156</a> <span class="preprocessor">#define LINKTYPE_ATM_CLIP   106     </span><span class="comment">/* Linux Classical IP over ATM */</span>
<a name="l00157"></a><a class="code" href="savefile_8c.html#a28">00157</a> <span class="preprocessor">#define LINKTYPE_FRELAY     107     </span><span class="comment">/* Frame Relay */</span>
<a name="l00158"></a><a class="code" href="savefile_8c.html#a29">00158</a> <span class="preprocessor">#define LINKTYPE_LOOP       108     </span><span class="comment">/* OpenBSD loopback */</span>
00159 
<a name="l00160"></a><a class="code" href="savefile_8c.html#a30">00160</a> <span class="preprocessor">#define LINKTYPE_LINUX_SLL  113     </span><span class="comment">/* Linux cooked socket capture */</span>
<a name="l00161"></a><a class="code" href="savefile_8c.html#a31">00161</a> <span class="preprocessor">#define LINKTYPE_LTALK      114     </span><span class="comment">/* Apple LocalTalk hardware */</span>
<a name="l00162"></a><a class="code" href="savefile_8c.html#a32">00162</a> <span class="preprocessor">#define LINKTYPE_ECONET     115     </span><span class="comment">/* Acorn Econet */</span>
00163 
<a name="l00164"></a><a class="code" href="savefile_8c.html#a33">00164</a> <span class="preprocessor">#define LINKTYPE_CISCO_IOS  118     </span><span class="comment">/* For Cisco-internal use */</span>
<a name="l00165"></a><a class="code" href="savefile_8c.html#a34">00165</a> <span class="preprocessor">#define LINKTYPE_PRISM_HEADER   119     </span><span class="comment">/* 802.11+Prism II monitor mode */</span>
<a name="l00166"></a><a class="code" href="savefile_8c.html#a35">00166</a> <span class="preprocessor">#define LINKTYPE_AIRONET_HEADER 120     </span><span class="comment">/* FreeBSD Aironet driver stuff */</span>
<a name="l00167"></a><a class="code" href="savefile_8c.html#a36">00167</a> <span class="preprocessor">#define LINKTYPE_IP_OVER_FC 122     </span><span class="comment">/* RFC 2625 IP-over-Fibre Channel */</span>
<a name="l00168"></a><a class="code" href="savefile_8c.html#a37">00168</a> <span class="preprocessor">#define LINKTYPE_SUNATM     123     </span><span class="comment">/* Solaris+SunATM */</span>
00169 
<a name="l00170"></a><a class="code" href="savefile_8c.html#a38">00170</a> <span class="preprocessor">#define LINKTYPE_IEEE802_11_RADIO 127       </span><span class="comment">/* 802.11 plus WLAN header */</span>
00171 
<a name="l00172"></a><a class="code" href="savefile_8c.html#a39">00172</a> <span class="preprocessor">#define LINKTYPE_TZSP       128     </span><span class="comment">/* Tazmen Sniffer Protocol */</span>
00173 
<a name="l00174"></a><a class="code" href="savefile_8c.html#a40">00174</a> <span class="preprocessor">#define LINKTYPE_ARCNET_LINUX   129     </span><span class="comment">/* Linux-style headers */</span>
00175 
00176 <span class="comment">/*</span>
00177 <span class="comment"> * These types are reserved for future use.</span>
00178 <span class="comment"> */</span>
<a name="l00179"></a><a class="code" href="savefile_8c.html#a41">00179</a> <span class="preprocessor">#define LINKTYPE_ENC        109     </span><span class="comment">/* OpenBSD IPSEC enc */</span>
<a name="l00180"></a><a class="code" href="savefile_8c.html#a42">00180</a> <span class="preprocessor">#define LINKTYPE_LANE8023   110     </span><span class="comment">/* ATM LANE + 802.3 */</span>
<a name="l00181"></a><a class="code" href="savefile_8c.html#a43">00181</a> <span class="preprocessor">#define LINKTYPE_HIPPI      111     </span><span class="comment">/* NetBSD HIPPI */</span>
<a name="l00182"></a><a class="code" href="savefile_8c.html#a44">00182</a> <span class="preprocessor">#define LINKTYPE_HDLC       112     </span><span class="comment">/* NetBSD HDLC framing */</span>
<a name="l00183"></a><a class="code" href="savefile_8c.html#a45">00183</a> <span class="preprocessor">#define LINKTYPE_IPFILTER   116     </span><span class="comment">/* IP Filter capture files */</span>
<a name="l00184"></a><a class="code" href="savefile_8c.html#a46">00184</a> <span class="preprocessor">#define LINKTYPE_PFLOG      117     </span><span class="comment">/* OpenBSD DLT_PFLOG */</span>
<a name="l00185"></a><a class="code" href="savefile_8c.html#a47">00185</a> <span class="preprocessor">#define LINKTYPE_HHDLC      121     </span><span class="comment">/* Siemens HiPath HDLC */</span>
<a name="l00186"></a><a class="code" href="savefile_8c.html#a48">00186</a> <span class="preprocessor">#define LINKTYPE_RIO        124     </span><span class="comment">/* RapidIO */</span>
<a name="l00187"></a><a class="code" href="savefile_8c.html#a49">00187</a> <span class="preprocessor">#define LINKTYPE_PCI_EXP    125     </span><span class="comment">/* PCI Express */</span>
<a name="l00188"></a><a class="code" href="savefile_8c.html#a50">00188</a> <span class="preprocessor">#define LINKTYPE_AURORA     126     </span><span class="comment">/* Xilinx Aurora link layer */</span>
00189 
<a name="l00190"></a><a class="code" href="structlinktype__map.html">00190</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlinktype__map.html">linktype_map</a> {
<a name="l00191"></a><a class="code" href="structlinktype__map.html#m0">00191</a>     <span class="keywordtype">int</span> <a class="code" href="structlinktype__map.html#m0">dlt</a>;
<a name="l00192"></a><a class="code" href="structlinktype__map.html#m1">00192</a>     <span class="keywordtype">int</span> <a class="code" href="structlinktype__map.html#m1">linktype</a>;
00193 } <a class="code" href="savefile_8c.html#a52">map</a>[] = {
00194     <span class="comment">/*</span>
00195 <span class="comment">     * These DLT_* codes have LINKTYPE_* codes with values identical</span>
00196 <span class="comment">     * to the values of the corresponding DLT_* code.</span>
00197 <span class="comment">     */</span>
00198     { DLT_NULL,     <a class="code" href="savefile_8c.html#a8">LINKTYPE_NULL</a> },
00199     { DLT_EN10MB,       <a class="code" href="savefile_8c.html#a9">LINKTYPE_ETHERNET</a> },
00200     { DLT_EN3MB,        <a class="code" href="savefile_8c.html#a10">LINKTYPE_EXP_ETHERNET</a> },
00201     { DLT_AX25,     <a class="code" href="savefile_8c.html#a11">LINKTYPE_AX25</a> },
00202     { DLT_PRONET,       <a class="code" href="savefile_8c.html#a12">LINKTYPE_PRONET</a> },
00203     { DLT_CHAOS,        <a class="code" href="savefile_8c.html#a13">LINKTYPE_CHAOS</a> },
00204     { DLT_IEEE802,      <a class="code" href="savefile_8c.html#a14">LINKTYPE_TOKEN_RING</a> },
00205     { DLT_ARCNET,       <a class="code" href="savefile_8c.html#a15">LINKTYPE_ARCNET</a> },
00206     { DLT_SLIP,     <a class="code" href="savefile_8c.html#a16">LINKTYPE_SLIP</a> },
00207     { DLT_PPP,      <a class="code" href="savefile_8c.html#a17">LINKTYPE_PPP</a> },
00208     { DLT_FDDI,     <a class="code" href="savefile_8c.html#a18">LINKTYPE_FDDI</a> },
00209 
00210     <span class="comment">/*</span>
00211 <span class="comment">     * These DLT_* codes have different values on different</span>
00212 <span class="comment">     * platforms; we map them to LINKTYPE_* codes that</span>
00213 <span class="comment">     * have values that should never be equal to any DLT_*</span>
00214 <span class="comment">     * code.</span>
00215 <span class="comment">     */</span>
00216 <span class="preprocessor">#ifdef DLT_FR</span>
00217 <span class="preprocessor"></span>    <span class="comment">/* BSD/OS Frame Relay */</span>
00218     { DLT_FR,       <a class="code" href="savefile_8c.html#a28">LINKTYPE_FRELAY</a> },
00219 <span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>    { DLT_ATM_RFC1483,  <a class="code" href="savefile_8c.html#a21">LINKTYPE_ATM_RFC1483</a> },
00221     { DLT_RAW,      <a class="code" href="savefile_8c.html#a22">LINKTYPE_RAW</a> },
00222     { DLT_SLIP_BSDOS,   <a class="code" href="savefile_8c.html#a23">LINKTYPE_SLIP_BSDOS</a> },
00223     { DLT_PPP_BSDOS,    <a class="code" href="savefile_8c.html#a24">LINKTYPE_PPP_BSDOS</a> },
00224 
00225     <span class="comment">/* BSD/OS Cisco HDLC */</span>
00226     { DLT_C_HDLC,       <a class="code" href="savefile_8c.html#a25">LINKTYPE_C_HDLC</a> },
00227 
00228     <span class="comment">/*</span>
00229 <span class="comment">     * These DLT_* codes are not on all platforms, but, so far,</span>
00230 <span class="comment">     * there don't appear to be any platforms that define</span>
00231 <span class="comment">     * other codes with those values; we map them to</span>
00232 <span class="comment">     * different LINKTYPE_* values anyway, just in case.</span>
00233 <span class="comment">     */</span>
00234 
00235     <span class="comment">/* Linux ATM Classical IP */</span>
00236     { DLT_ATM_CLIP,     <a class="code" href="savefile_8c.html#a27">LINKTYPE_ATM_CLIP</a> },
00237 
00238     <span class="comment">/* NetBSD sync/async serial PPP (or Cisco HDLC) */</span>
00239     { DLT_PPP_SERIAL,   <a class="code" href="savefile_8c.html#a19">LINKTYPE_PPP_HDLC</a> },
00240 
00241     <span class="comment">/* NetBSD PPP over Ethernet */</span>
00242     { DLT_PPP_ETHER,    <a class="code" href="savefile_8c.html#a20">LINKTYPE_PPP_ETHER</a> },
00243 
00244     <span class="comment">/* IEEE 802.11 wireless */</span>
00245     { DLT_IEEE802_11,   <a class="code" href="savefile_8c.html#a26">LINKTYPE_IEEE802_11</a> },
00246 
00247     <span class="comment">/* Frame Relay */</span>
00248     { DLT_FRELAY,       <a class="code" href="savefile_8c.html#a28">LINKTYPE_FRELAY</a> },
00249 
00250     <span class="comment">/* OpenBSD loopback */</span>
00251     { DLT_LOOP,     <a class="code" href="savefile_8c.html#a29">LINKTYPE_LOOP</a> },
00252 
00253     <span class="comment">/* Linux cooked socket capture */</span>
00254     { DLT_LINUX_SLL,    <a class="code" href="savefile_8c.html#a30">LINKTYPE_LINUX_SLL</a> },
00255 
00256     <span class="comment">/* Apple LocalTalk hardware */</span>
00257     { DLT_LTALK,        <a class="code" href="savefile_8c.html#a31">LINKTYPE_LTALK</a> },
00258 
00259     <span class="comment">/* Acorn Econet */</span>
00260     { DLT_ECONET,       <a class="code" href="savefile_8c.html#a32">LINKTYPE_ECONET</a> },
00261 
00262     <span class="comment">/* For Cisco-internal use */</span>
00263     { DLT_CISCO_IOS,    <a class="code" href="savefile_8c.html#a33">LINKTYPE_CISCO_IOS</a> },
00264 
00265     <span class="comment">/* Prism II monitor-mode header plus 802.11 header */</span>
00266     { DLT_PRISM_HEADER, <a class="code" href="savefile_8c.html#a34">LINKTYPE_PRISM_HEADER</a> },
00267 
00268     <span class="comment">/* FreeBSD Aironet driver stuff */</span>
00269     { DLT_AIRONET_HEADER,   <a class="code" href="savefile_8c.html#a35">LINKTYPE_AIRONET_HEADER</a> },
00270 
00271     <span class="comment">/* Siemens HiPath HDLC */</span>
00272     { DLT_HHDLC,        <a class="code" href="savefile_8c.html#a47">LINKTYPE_HHDLC</a> },
00273 
00274     <span class="comment">/* RFC 2625 IP-over-Fibre Channel */</span>
00275     { DLT_IP_OVER_FC,   <a class="code" href="savefile_8c.html#a36">LINKTYPE_IP_OVER_FC</a> },
00276 
00277     <span class="comment">/* Solaris+SunATM */</span>
00278     { DLT_SUNATM,       <a class="code" href="savefile_8c.html#a37">LINKTYPE_SUNATM</a> },
00279 
00280     <span class="comment">/* RapidIO */</span>
00281     { DLT_RIO,      <a class="code" href="savefile_8c.html#a48">LINKTYPE_RIO</a> },
00282 
00283     <span class="comment">/* PCI Express */</span>
00284     { DLT_PCI_EXP,      <a class="code" href="savefile_8c.html#a49">LINKTYPE_PCI_EXP</a> },
00285 
00286     <span class="comment">/* Xilinx Aurora link layer */</span>
00287     { DLT_AURORA,       <a class="code" href="savefile_8c.html#a50">LINKTYPE_AURORA</a> },
00288 
00289     <span class="comment">/* 802.11 plus WLAN header */</span>
00290     { DLT_IEEE802_11_RADIO, <a class="code" href="savefile_8c.html#a38">LINKTYPE_IEEE802_11_RADIO</a> },
00291 
00292     <span class="comment">/* Tazmen Sniffer Protocol */</span>
00293     { DLT_TZSP,     <a class="code" href="savefile_8c.html#a39">LINKTYPE_TZSP</a> },
00294 
00295     <span class="comment">/* Arcnet with Linux-style link-layer headers */</span>
00296     { DLT_ARCNET_LINUX, <a class="code" href="savefile_8c.html#a40">LINKTYPE_ARCNET_LINUX</a> },
00297 
00298     <span class="comment">/*</span>
00299 <span class="comment">     * Any platform that defines additional DLT_* codes should:</span>
00300 <span class="comment">     *</span>
00301 <span class="comment">     *  request a LINKTYPE_* code and value from tcpdump.org,</span>
00302 <span class="comment">     *  as per the above;</span>
00303 <span class="comment">     *</span>
00304 <span class="comment">     *  add, in their version of libpcap, an entry to map</span>
00305 <span class="comment">     *  those DLT_* codes to the corresponding LINKTYPE_*</span>
00306 <span class="comment">     *  code;</span>
00307 <span class="comment">     *</span>
00308 <span class="comment">     *  redefine, in their "net/bpf.h", any DLT_* values</span>
00309 <span class="comment">     *  that collide with the values used by their additional</span>
00310 <span class="comment">     *  DLT_* codes, to remove those collisions (but without</span>
00311 <span class="comment">     *  making them collide with any of the LINKTYPE_*</span>
00312 <span class="comment">     *  values equal to 50 or above; they should also avoid</span>
00313 <span class="comment">     *  defining DLT_* values that collide with those</span>
00314 <span class="comment">     *  LINKTYPE_* values, either).</span>
00315 <span class="comment">     */</span>
00316     { -1,           -1 }
00317 };
00318 
00319 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00320"></a><a class="code" href="savefile_8c.html#a53">00320</a> <a class="code" href="savefile_8c.html#a53">dlt_to_linktype</a>(<span class="keywordtype">int</span> dlt)
00321 {
00322     <span class="keywordtype">int</span> i;
00323 
00324     <span class="keywordflow">for</span> (i = 0; <a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m0">dlt</a> != -1; i++) {
00325         <span class="keywordflow">if</span> (<a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m0">dlt</a> == dlt)
00326             <span class="keywordflow">return</span> (<a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m1">linktype</a>);
00327     }
00328 
00329     <span class="comment">/*</span>
00330 <span class="comment">     * If we don't have a mapping for this DLT_ code, return an</span>
00331 <span class="comment">     * error; that means that the table above needs to have an</span>
00332 <span class="comment">     * entry added.</span>
00333 <span class="comment">     */</span>
00334     <span class="keywordflow">return</span> (-1);
00335 }
00336 
00337 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00338"></a><a class="code" href="savefile_8c.html#a54">00338</a> <a class="code" href="savefile_8c.html#a54">linktype_to_dlt</a>(<span class="keywordtype">int</span> linktype)
00339 {
00340     <span class="keywordtype">int</span> i;
00341 
00342     <span class="keywordflow">for</span> (i = 0; <a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m1">linktype</a> != -1; i++) {
00343         <span class="keywordflow">if</span> (<a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m1">linktype</a> == linktype)
00344             <span class="keywordflow">return</span> (<a class="code" href="savefile_8c.html#a52">map</a>[i].<a class="code" href="structlinktype__map.html#m0">dlt</a>);
00345     }
00346 
00347     <span class="comment">/*</span>
00348 <span class="comment">     * If we don't have an entry for this link type, return</span>
00349 <span class="comment">     * the link type value; it may be a DLT_ value from an</span>
00350 <span class="comment">     * older version of libpcap.</span>
00351 <span class="comment">     */</span>
00352     <span class="keywordflow">return</span> linktype;
00353 }
00354 
00355 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00356"></a><a class="code" href="savefile_8c.html#a55">00356</a> <a class="code" href="savefile_8c.html#a55">sf_write_header</a>(FILE *fp, <span class="keywordtype">int</span> linktype, <span class="keywordtype">int</span> thiszone, <span class="keywordtype">int</span> snaplen)
00357 {
00358     <span class="keyword">struct </span><a class="code" href="structpcap__file__header.html">pcap_file_header</a> hdr;
00359 
00360     hdr.<a class="code" href="structpcap__file__header.html#m0">magic</a> = <a class="code" href="group__NPF__include.html#a37">TCPDUMP_MAGIC</a>;
00361     hdr.<a class="code" href="structpcap__file__header.html#m1">version_major</a> = <a class="code" href="group__NPF__include.html#a38">PCAP_VERSION_MAJOR</a>;
00362     hdr.<a class="code" href="structpcap__file__header.html#m2">version_minor</a> = <a class="code" href="group__NPF__include.html#a39">PCAP_VERSION_MINOR</a>;
00363 
00364     hdr.<a class="code" href="structpcap__file__header.html#m3">thiszone</a> = thiszone;
00365     hdr.<a class="code" href="structpcap__file__header.html#m5">snaplen</a> = snaplen;
00366     hdr.<a class="code" href="structpcap__file__header.html#m4">sigfigs</a> = 0;
00367     hdr.<a class="code" href="structpcap__file__header.html#m6">linktype</a> = linktype;
00368 
00369     <span class="keywordflow">if</span> (fwrite((<span class="keywordtype">char</span> *)&amp;hdr, <span class="keyword">sizeof</span>(hdr), 1, fp) != 1)
00370         <span class="keywordflow">return</span> (-1);
00371 
00372     <span class="keywordflow">return</span> (0);
00373 }
00374 
00375 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00376"></a><a class="code" href="savefile_8c.html#a56">00376</a> <a class="code" href="savefile_8c.html#a56">swap_hdr</a>(<span class="keyword">struct</span> <a class="code" href="structpcap__file__header.html">pcap_file_header</a> *hp)
00377 {
00378     hp-&gt;<a class="code" href="structpcap__file__header.html#m1">version_major</a> = <a class="code" href="savefile_8c.html#a3">SWAPSHORT</a>(hp-&gt;<a class="code" href="structpcap__file__header.html#m1">version_major</a>);
00379     hp-&gt;<a class="code" href="structpcap__file__header.html#m2">version_minor</a> = <a class="code" href="savefile_8c.html#a3">SWAPSHORT</a>(hp-&gt;<a class="code" href="structpcap__file__header.html#m2">version_minor</a>);
00380     hp-&gt;<a class="code" href="structpcap__file__header.html#m3">thiszone</a> = SWAPLONG(hp-&gt;<a class="code" href="structpcap__file__header.html#m3">thiszone</a>);
00381     hp-&gt;<a class="code" href="structpcap__file__header.html#m4">sigfigs</a> = SWAPLONG(hp-&gt;<a class="code" href="structpcap__file__header.html#m4">sigfigs</a>);
00382     hp-&gt;<a class="code" href="structpcap__file__header.html#m5">snaplen</a> = SWAPLONG(hp-&gt;<a class="code" href="structpcap__file__header.html#m5">snaplen</a>);
00383     hp-&gt;<a class="code" href="structpcap__file__header.html#m6">linktype</a> = SWAPLONG(hp-&gt;<a class="code" href="structpcap__file__header.html#m6">linktype</a>);
00384 }
00385 
00386 <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *
<a name="l00387"></a><a class="code" href="savefile_8c.html#a57">00387</a> <a class="code" href="savefile_8c.html#a57">pcap_open_offline</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fname, <span class="keywordtype">char</span> *errbuf)
00388 {
00389     <span class="keyword">register</span> <a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *p;
00390     <span class="keyword">register</span> FILE *fp;
00391     <span class="keyword">struct </span><a class="code" href="structpcap__file__header.html">pcap_file_header</a> hdr;
00392     <a class="code" href="group__wpcap__def.html#a1">bpf_u_int32</a> magic;
00393     <span class="keywordtype">int</span> linklen;
00394 
00395     p = (<a class="code" href="group__wpcap__def.html#a2">pcap_t</a> *)malloc(<span class="keyword">sizeof</span>(*p));
00396     <span class="keywordflow">if</span> (p == NULL) {
00397         strlcpy(errbuf, <span class="stringliteral">"out of swap"</span>, PCAP_ERRBUF_SIZE);
00398         <span class="keywordflow">return</span> (NULL);
00399     }
00400 
00401     memset((<span class="keywordtype">char</span> *)p, 0, <span class="keyword">sizeof</span>(*p));
00402     <span class="comment">/*</span>
00403 <span class="comment">     * Set this field so we don't close stdin in pcap_close!</span>
00404 <span class="comment">     */</span>
00405 <span class="preprocessor">#ifndef WIN32</span>
00406 <span class="preprocessor"></span>    p-&gt;fd = -1;
00407 <span class="preprocessor">#else</span>
00408 <span class="preprocessor"></span>    p-&gt;adapter = NULL;
00409 <span class="preprocessor">#endif</span>
00410 <span class="preprocessor"></span>
00411     <span class="keywordflow">if</span> (fname[0] == <span class="charliteral">'-'</span> &amp;&amp; fname[1] == <span class="charliteral">'\0'</span>)
00412         fp = stdin;
00413     <span class="keywordflow">else</span> {
00414 <span class="preprocessor">#ifndef WIN32</span>
00415 <span class="preprocessor"></span>        fp = fopen(fname, <span class="stringliteral">"r"</span>);
00416 <span class="preprocessor">#else</span>
00417 <span class="preprocessor"></span>        fp = fopen(fname, <span class="stringliteral">"rb"</span>);
00418 <span class="preprocessor">#endif</span>
00419 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fp == NULL) {
00420             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"%s: %s"</span>, fname,
00421                 <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00422             <span class="keywordflow">goto</span> bad;
00423         }
00424     }
00425     <span class="keywordflow">if</span> (fread((<span class="keywordtype">char</span> *)&amp;hdr, <span class="keyword">sizeof</span>(hdr), 1, fp) != 1) {
00426         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"fread: %s"</span>,
00427             <a class="code" href="pcap_8c.html#a28">pcap_strerror</a>(errno));
00428         <span class="keywordflow">goto</span> bad;
00429     }
00430     magic = hdr.magic;
00431     <span class="keywordflow">if</span> (magic != <a class="code" href="group__NPF__include.html#a37">TCPDUMP_MAGIC</a> &amp;&amp; magic != <a class="code" href="savefile_8c.html#a1">PATCHED_TCPDUMP_MAGIC</a>) {
00432         magic = SWAPLONG(magic);
00433         <span class="keywordflow">if</span> (magic != <a class="code" href="group__NPF__include.html#a37">TCPDUMP_MAGIC</a> &amp;&amp; magic != <a class="code" href="savefile_8c.html#a1">PATCHED_TCPDUMP_MAGIC</a>) {
00434             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE,
00435                 <span class="stringliteral">"bad dump file format"</span>);
00436             <span class="keywordflow">goto</span> bad;
00437         }
00438         p-&gt;sf.swapped = 1;
00439         <a class="code" href="savefile_8c.html#a56">swap_hdr</a>(&amp;hdr);
00440     }
00441     <span class="keywordflow">if</span> (magic == <a class="code" href="savefile_8c.html#a1">PATCHED_TCPDUMP_MAGIC</a>) {
00442         <span class="comment">/*</span>
00443 <span class="comment">         * XXX - the patch that's in some versions of libpcap</span>
00444 <span class="comment">         * changes the packet header but not the magic number;</span>
00445 <span class="comment">         * we'd have to use some hacks^H^H^H^H^Hheuristics to</span>
00446 <span class="comment">         * detect that.</span>
00447 <span class="comment">         */</span>
00448         p-&gt;sf.hdrsize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>pcap_sf_patched_pkthdr);
00449     } <span class="keywordflow">else</span>
00450         p-&gt;sf.hdrsize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>pcap_sf_pkthdr);
00451     <span class="keywordflow">if</span> (hdr.version_major &lt; <a class="code" href="group__NPF__include.html#a38">PCAP_VERSION_MAJOR</a>) {
00452         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"archaic file format"</span>);
00453         <span class="keywordflow">goto</span> bad;
00454     }
00455     p-&gt;tzoff = hdr.thiszone;
00456     p-&gt;snapshot = hdr.snaplen;
00457     p-&gt;linktype = <a class="code" href="savefile_8c.html#a54">linktype_to_dlt</a>(hdr.linktype);
00458     p-&gt;sf.rfile = fp;
00459 <span class="preprocessor">#ifndef WIN32</span>
00460 <span class="preprocessor"></span>    p-&gt;bufsize = hdr.snaplen;
00461 <span class="preprocessor">#else</span>
00462 <span class="preprocessor"></span>    <span class="comment">/* Allocate the space for pcap_pkthdr as well. It will be used by pcap_read_ex */</span>
00463     p-&gt;bufsize = hdr.snaplen+<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a>);
00464 <span class="preprocessor">#endif</span>
00465 <span class="preprocessor"></span>
00466     <span class="comment">/* Align link header as required for proper data alignment */</span>
00467     <span class="comment">/* XXX should handle all types */</span>
00468     <span class="keywordflow">switch</span> (p-&gt;linktype) {
00469 
00470     <span class="keywordflow">case</span> DLT_EN10MB:
00471         linklen = 14;
00472         <span class="keywordflow">break</span>;
00473 
00474     <span class="keywordflow">case</span> DLT_FDDI:
00475         linklen = 13 + 8;   <span class="comment">/* fddi_header + llc */</span>
00476         <span class="keywordflow">break</span>;
00477 
00478     <span class="keywordflow">case</span> DLT_NULL:
00479     <span class="keywordflow">default</span>:
00480         linklen = 0;
00481         <span class="keywordflow">break</span>;
00482     }
00483 
00484     <span class="keywordflow">if</span> (p-&gt;bufsize &lt; 0)
00485         p-&gt;bufsize = BPF_MAXBUFSIZE;
00486     p-&gt;sf.base = (u_char *)malloc(p-&gt;bufsize + BPF_ALIGNMENT);
00487     <span class="keywordflow">if</span> (p-&gt;sf.base == NULL) {
00488         strlcpy(errbuf, <span class="stringliteral">"out of swap"</span>, PCAP_ERRBUF_SIZE);
00489         <span class="keywordflow">goto</span> bad;
00490     }
00491     p-&gt;buffer = p-&gt;sf.base + BPF_ALIGNMENT - (linklen % BPF_ALIGNMENT);
00492     p-&gt;sf.version_major = hdr.version_major;
00493     p-&gt;sf.version_minor = hdr.version_minor;
00494 <span class="preprocessor">#ifdef PCAP_FDDIPAD</span>
00495 <span class="preprocessor"></span>    <span class="comment">/* XXX padding only needed for kernel fcode */</span>
00496     <a class="code" href="gencode_8c.html#a19">pcap_fddipad</a> = 0;
00497 <span class="preprocessor">#endif</span>
00498 <span class="preprocessor"></span>
00499     <span class="keywordflow">return</span> (p);
00500  bad:
00501     <span class="keywordflow">if</span>(fp)
00502         fclose(fp);
00503     free(p);
00504     <span class="keywordflow">return</span> (NULL);
00505 }
00506 
00507 <span class="comment">/*</span>
00508 <span class="comment"> * Read sf_readfile and return the next packet.  Return the header in hdr</span>
00509 <span class="comment"> * and the contents in buf.  Return 0 on success, SFERR_EOF if there were</span>
00510 <span class="comment"> * no more packets, and SFERR_TRUNC if a partial packet was encountered.</span>
00511 <span class="comment"> */</span>
00512 <span class="preprocessor">#if (defined(HAVE_PCAPREADEX) || defined(WIN32) )</span>
00513 <span class="preprocessor"></span><span class="keywordtype">int</span>
00514 <span class="preprocessor">#else</span>
00515 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span>
00516 <span class="preprocessor">#endif</span>
<a name="l00517"></a><a class="code" href="savefile_8c.html#a58">00517</a> <span class="preprocessor"></span><a class="code" href="savefile_8c.html#a58">sf_next_packet</a>(pcap_t *p, <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *hdr, u_char *buf, <span class="keywordtype">int</span> buflen)
00518 {
00519     <span class="keyword">struct </span>pcap_sf_patched_pkthdr sf_hdr;
00520     FILE *fp = p-&gt;sf.rfile;
00521 
00522     <span class="comment">/*</span>
00523 <span class="comment">     * Read the packet header; the structure we use as a buffer</span>
00524 <span class="comment">     * is the longer structure for files generated by the patched</span>
00525 <span class="comment">     * libpcap, but if the file has the magic number for an</span>
00526 <span class="comment">     * unpatched libpcap we only read as many bytes as the regular</span>
00527 <span class="comment">     * header has.</span>
00528 <span class="comment">     */</span>
00529     <span class="keywordflow">if</span> (fread(&amp;sf_hdr, p-&gt;sf.hdrsize, 1, fp) != 1) {
00530         <span class="comment">/* probably an EOF, though could be a truncated packet */</span>
00531         <span class="keywordflow">return</span> (1);
00532     }
00533 
00534     <span class="keywordflow">if</span> (p-&gt;sf.swapped) {
00535         <span class="comment">/* these were written in opposite byte order */</span>
00536         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> = SWAPLONG(sf_hdr.caplen);
00537         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a> = SWAPLONG(sf_hdr.len);
00538         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);
00539         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);
00540     } <span class="keywordflow">else</span> {
00541         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> = sf_hdr.caplen;
00542         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a> = sf_hdr.len;
00543         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec = sf_hdr.ts.tv_sec;
00544         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec = sf_hdr.ts.tv_usec;
00545     }
00546     <span class="comment">/*</span>
00547 <span class="comment">     * We interchanged the caplen and len fields at version 2.3,</span>
00548 <span class="comment">     * in order to match the bpf header layout.  But unfortunately</span>
00549 <span class="comment">     * some files were written with version 2.3 in their headers</span>
00550 <span class="comment">     * but without the interchanged fields.</span>
00551 <span class="comment">     */</span>
00552     <span class="keywordflow">if</span> (p-&gt;sf.version_minor &lt; 3 ||
00553         (p-&gt;sf.version_minor == 3 &amp;&amp; hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> &gt; hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>)) {
00554         <span class="keywordtype">int</span> t = hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>;
00555         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> = hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>;
00556         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a> = t;
00557     }
00558 
00559     <span class="keywordflow">if</span> (hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> &gt; buflen) {
00560         <span class="comment">/*</span>
00561 <span class="comment">         * This can happen due to Solaris 2.3 systems tripping</span>
00562 <span class="comment">         * over the BUFMOD problem and not setting the snapshot</span>
00563 <span class="comment">         * correctly in the savefile header.  If the caplen isn't</span>
00564 <span class="comment">         * grossly wrong, try to salvage.</span>
00565 <span class="comment">         */</span>
00566         <span class="keyword">static</span> u_char *tp = NULL;
00567         <span class="keyword">static</span> <span class="keywordtype">int</span> tsize = 0;
00568 
00569         <span class="keywordflow">if</span> (hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> &gt; 65535) {
00570             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
00571                 <span class="stringliteral">"bogus savefile header"</span>);
00572             <span class="keywordflow">return</span> (-1);
00573         }
00574 
00575         <span class="keywordflow">if</span> (tsize &lt; hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>) {
00576             tsize = ((hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> + 1023) / 1024) * 1024;
00577             <span class="keywordflow">if</span> (tp != NULL)
00578                 free((u_char *)tp);
00579             tp = (u_char *)malloc(tsize);
00580             <span class="keywordflow">if</span> (tp == NULL) {
00581                 tsize = 0;
00582                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
00583                     <span class="stringliteral">"BUFMOD hack malloc"</span>);
00584                 <span class="keywordflow">return</span> (-1);
00585             }
00586         }
00587         <span class="keywordflow">if</span> (fread((<span class="keywordtype">char</span> *)tp, hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>, 1, fp) != 1) {
00588             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
00589                 <span class="stringliteral">"truncated dump file"</span>);
00590             <span class="keywordflow">return</span> (-1);
00591         }
00592         <span class="comment">/*</span>
00593 <span class="comment">         * We can only keep up to buflen bytes.  Since caplen &gt; buflen</span>
00594 <span class="comment">         * is exactly how we got here, we know we can only keep the</span>
00595 <span class="comment">         * first buflen bytes and must drop the remainder.  Adjust</span>
00596 <span class="comment">         * caplen accordingly, so we don't get confused later as</span>
00597 <span class="comment">         * to how many bytes we have to play with.</span>
00598 <span class="comment">         */</span>
00599         hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a> = buflen;
00600         memcpy((<span class="keywordtype">char</span> *)buf, (<span class="keywordtype">char</span> *)tp, buflen);
00601 
00602     } <span class="keywordflow">else</span> {
00603         <span class="comment">/* read the packet itself */</span>
00604 
00605         <span class="keywordflow">if</span> (fread((<span class="keywordtype">char</span> *)buf, hdr-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>, 1, fp) != 1) {
00606             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
00607                 <span class="stringliteral">"truncated dump file"</span>);
00608             <span class="keywordflow">return</span> (-1);
00609         }
00610     }
00611     <span class="keywordflow">return</span> (0);
00612 }
00613 
00614 <span class="comment">/*</span>
00615 <span class="comment"> * Print out packets stored in the file initialized by sf_read_init().</span>
00616 <span class="comment"> * If cnt &gt; 0, return after 'cnt' packets, otherwise continue until eof.</span>
00617 <span class="comment"> */</span>
00618 <span class="keywordtype">int</span>
<a name="l00619"></a><a class="code" href="savefile_8c.html#a59">00619</a> <a class="code" href="savefile_8c.html#a59">pcap_offline_read</a>(pcap_t *p, <span class="keywordtype">int</span> cnt, pcap_handler callback, u_char *user)
00620 {
00621     <span class="keyword">struct </span><a class="code" href="structbpf__insn.html">bpf_insn</a> *fcode = p-&gt;fcode.bf_insns;
00622     <span class="keywordtype">int</span> status = 0;
00623     <span class="keywordtype">int</span> <a class="code" href="bpf__image_8c.html#a1">n</a> = 0;
00624 
00625     <span class="keywordflow">while</span> (status == 0) {
00626         <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> h;
00627 
00628         status = <a class="code" href="savefile_8c.html#a58">sf_next_packet</a>(p, &amp;h, p-&gt;buffer, p-&gt;bufsize);
00629         <span class="keywordflow">if</span> (status) {
00630             <span class="keywordflow">if</span> (status == 1)
00631                 <span class="keywordflow">return</span> (0);
00632             <span class="keywordflow">return</span> (status);
00633         }
00634 
00635         <span class="keywordflow">if</span> (fcode == NULL ||
00636             <a class="code" href="group__NPF__code.html#a26">bpf_filter</a>(fcode, p-&gt;buffer, h.<a class="code" href="structpcap__pkthdr.html#m2">len</a>, h.<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>)) {
00637             (*callback)(user, &amp;h, p-&gt;buffer);
00638             <span class="keywordflow">if</span> (++<a class="code" href="bpf__image_8c.html#a1">n</a> &gt;= cnt &amp;&amp; cnt &gt; 0)
00639                 <span class="keywordflow">break</span>;
00640         }
00641     }
00642     <span class="comment">/*XXX this breaks semantics tcpslice expects */</span>
00643     <span class="keywordflow">return</span> (n);
00644 }
00645 
00646 <span class="comment">/*</span>
00647 <span class="comment"> * Output a packet to the initialized dump file.</span>
00648 <span class="comment"> */</span>
00649 <span class="keywordtype">void</span>
<a name="l00650"></a><a class="code" href="savefile_8c.html#a60">00650</a> <a class="code" href="savefile_8c.html#a60">pcap_dump</a>(u_char *user, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h, <span class="keyword">const</span> u_char *sp)
00651 {
00652     <span class="keyword">register</span> FILE *f;
00653     <span class="keyword">struct </span>pcap_sf_pkthdr sf_hdr;
00654 
00655     f = (FILE *)user;
00656     sf_hdr.ts.tv_sec  = h-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_sec;
00657     sf_hdr.ts.tv_usec = h-&gt;<a class="code" href="structpcap__pkthdr.html#m0">ts</a>.tv_usec;
00658     sf_hdr.caplen     = h-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>;
00659     sf_hdr.len        = h-&gt;<a class="code" href="structpcap__pkthdr.html#m2">len</a>;
00660     <span class="comment">/* XXX we should check the return status */</span>
00661     (void)fwrite(&amp;sf_hdr, <span class="keyword">sizeof</span>(sf_hdr), 1, f);
00662     (void)fwrite((<span class="keywordtype">char</span> *)sp, h-&gt;<a class="code" href="structpcap__pkthdr.html#m1">caplen</a>, 1, f);
00663 }
00664 
00665 <span class="comment">/*</span>
00666 <span class="comment"> * Initialize so that sf_write() will output to the file named 'fname'.</span>
00667 <span class="comment"> */</span>
00668 <a class="code" href="group__wpcap__def.html#a3">pcap_dumper_t</a> *
<a name="l00669"></a><a class="code" href="savefile_8c.html#a61">00669</a> <a class="code" href="savefile_8c.html#a61">pcap_dump_open</a>(pcap_t *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *fname)
00670 {
00671     FILE *f;
00672     <span class="keywordtype">int</span> linktype;
00673 
00674     linktype = <a class="code" href="savefile_8c.html#a53">dlt_to_linktype</a>(p-&gt;linktype);
00675     <span class="keywordflow">if</span> (linktype == -1) {
00676         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
00677             <span class="stringliteral">"%s: link-layer type %d isn't supported in savefiles"</span>,
00678             fname, linktype);
00679         <span class="keywordflow">return</span> (NULL);
00680     }
00681 
00682     <span class="keywordflow">if</span> (fname[0] == <span class="charliteral">'-'</span> &amp;&amp; fname[1] == <span class="charliteral">'\0'</span>) {
00683         f = stdout;
00684 <span class="preprocessor">#ifdef WIN32</span>
00685 <span class="preprocessor"></span>        _setmode(_fileno(f), _O_BINARY);
00686 <span class="preprocessor">#endif</span>
00687 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00688 <span class="preprocessor">#ifndef WIN32</span>
00689 <span class="preprocessor"></span>        f = fopen(fname, <span class="stringliteral">"w"</span>);
00690 <span class="preprocessor">#else</span>
00691 <span class="preprocessor"></span>        f = fopen(fname, <span class="stringliteral">"wb"</span>);
00692         setbuf(f, NULL);    <span class="comment">/* XXX - why? */</span>
00693 <span class="preprocessor">#endif</span>
00694 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (f == NULL) {
00695             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(p-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">"%s: %s"</span>,
00696                 fname, <a class="code" href="group__wpcap__fn.html#a28">pcap_strerror</a>(errno));
00697             <span class="keywordflow">return</span> (NULL);
00698         }
00699     }
00700     (void)<a class="code" href="savefile_8c.html#a55">sf_write_header</a>(f, linktype, p-&gt;tzoff, p-&gt;snapshot);
00701     <span class="keywordflow">return</span> ((<a class="code" href="group__wpcap__def.html#a3">pcap_dumper_t</a> *)f);
00702 }
00703 
00704 <span class="keywordtype">int</span>
<a name="l00705"></a><a class="code" href="savefile_8c.html#a62">00705</a> <a class="code" href="savefile_8c.html#a62">pcap_dump_flush</a>(pcap_dumper_t *p)
00706 {
00707 
00708     <span class="keywordflow">if</span> (fflush((FILE *)p) == EOF)
00709         <span class="keywordflow">return</span> (-1);
00710     <span class="keywordflow">else</span>
00711         <span class="keywordflow">return</span> (0);
00712 }
00713 
00714 <span class="keywordtype">void</span>
<a name="l00715"></a><a class="code" href="savefile_8c.html#a63">00715</a> <a class="code" href="savefile_8c.html#a63">pcap_dump_close</a>(pcap_dumper_t *p)
00716 {
00717 
00718 <span class="preprocessor">#ifdef notyet</span>
00719 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ferror((FILE *)p))
00720         <span class="keywordflow">return</span>-an-error;
00721     <span class="comment">/* XXX should check return from fclose() too */</span>
00722 <span class="preprocessor">#endif</span>
00723 <span class="preprocessor"></span>    (void)fclose((FILE *)p);
00724 }
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
