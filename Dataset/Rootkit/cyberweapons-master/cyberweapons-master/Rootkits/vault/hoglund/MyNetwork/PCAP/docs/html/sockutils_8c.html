<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sockutils.c File Reference</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>sockutils.c File Reference</h1><code>#include "<a class="el" href="sockutils_8h-source.html">sockutils.h</a>"</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>

<p>
<a href="sockutils_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a0">WINSOCK_MAJOR_VERSION</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a1">WINSOCK_MINOR_VERSION</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a2">SHUT_WR</a>&nbsp;&nbsp;&nbsp;SD_SEND</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a3">snprintf</a>&nbsp;&nbsp;&nbsp;_snprintf</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a4">TEMP_BUF_SIZE</a>&nbsp;&nbsp;&nbsp;65536</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a3">sock_ismcastaddr</a> (const struct sockaddr *saddr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It checks if the sockaddr variable contains a multicast address.</em> <a href="group__remote__pri__func.html#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a8">sock_geterror</a> (const char *caller, char *string, int <a class="el" href="gencode_8c.html#a27">size</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves the error message after an error occurred in the socket interface.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a9">sock_init</a> (char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes sockets.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a10">sock_cleanup</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It deallocates sockets.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a11">sock_open</a> (struct addrinfo *addrinfo, int server, int nconn, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes a network connection both from the client and the server side.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a12">sock_close</a> (SOCKET sock, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Closes the present (TCP and UDP) socket connection.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a13">sock_validaddr</a> (const char *<a class="el" href="rpcapd_8c.html#a7">address</a>, const char *<a class="el" href="rpcapd_8c.html#a8">port</a>, struct addrinfo *hints, struct addrinfo **addrinfo, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that the address, port and flags given are valids and it returns an 'addrinfo' stucture.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a14">sock_send</a> (SOCKET socket, const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends the amount of data contained into 'buffer' on the given socket.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a15">sock_bufferize</a> (const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *tempbuf, int *<a class="el" href="gencode_8c.html#a30">offset</a>, int totsize, int checkonly, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It copies the amount of data contained into 'buffer' into 'tempbuf'. and it checks for buffer overflows.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a16">sock_recv</a> (SOCKET sock, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive exactly 'size' bytes.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a17">sock_recv_dgram</a> (SOCKET sock, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive one message.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a18">sock_discard</a> (SOCKET sock, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It discards N bytes that are currently waiting to be read on the current socket.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a19">sock_check_hostlist</a> (char *<a class="el" href="rpcapd_8c.html#a0">hostlist</a>, const char *sep, struct sockaddr_storage *from, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a20">sock_cmpaddr</a> (struct sockaddr_storage *first, struct sockaddr_storage *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compares two addresses contained into two sockaddr_storage structures.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a5">sockcount</a> = 0</td></tr>
<tr><td nowrap align=right valign=top>char&nbsp;</td><td valign=bottom><a class="el" href="sockutils_8c.html#a6">fakeerrbuf</a> [SOCK_ERRBUF_SIZE+1]</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The goal of this file it to provide a common set of primitives for socket manipulation. Although the socket interface defined in the RFC 2553 (and its updates) is excellent, several minor issues are still hidden when we want to operate on several operating systems.<p>
These calls do not want to provide a better socket interface; vice versa, they want to provide a set of calls that is portable among several operating systems, hiding their differences.
<p>
Definition in file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.<hr><h2>Define Documentation</h2>
<a name="a2" doxytag="sockutils.c::SHUT_WR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SHUT_WR&nbsp;&nbsp;&nbsp;SD_SEND
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The control code for shutdown() is different in Win32 
<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00063">63</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="sockutils.c::snprintf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define snprintf&nbsp;&nbsp;&nbsp;_snprintf
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The snprintf is called _snprintf() in Win32 
<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00064">64</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="inet_8c-source.html#l00300">add_addr_to_iflist()</a>, <a class="el" href="inet_8c-source.html#l00132">add_or_find_if()</a>, <a class="el" href="daemon_8c-source.html#l00599">daemon_AuthUserPwd()</a>, <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01147">daemon_unpackapplyfilter()</a>, <a class="el" href="fileconf_8c-source.html#l00055">fileconf_read()</a>, <a class="el" href="rpcapd_8c-source.html#l00119">main()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="gencode_8c-source.html#l00310">pcap_compile()</a>, <a class="el" href="pcap-new_8c-source.html#l00495">pcap_createsrcstr()</a>, <a class="el" href="savefile_8c-source.html#l00669">pcap_dump_open()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap_8c-source.html#l00498">pcap_getnonblock()</a>, <a class="el" href="pcap_8c-source.html#l00215">pcap_list_datalinks()</a>, <a class="el" href="pcap-new_8c-source.html#l00881">pcap_open()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00144">pcap_open_live()</a>, <a class="el" href="savefile_8c-source.html#l00387">pcap_open_offline()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00636">pcap_parsesrcstr()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00079">pcap_read()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-new_8c-source.html#l01285">pcap_remoteact_list()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00337">pcap_sendpacket()</a>, <a class="el" href="Win32-Extensions_8c-source.html#l00120">pcap_sendqueue_transmit()</a>, <a class="el" href="pcap_8c-source.html#l00246">pcap_set_datalink()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00359">pcap_setbuff()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00292">pcap_setfilter()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00377">pcap_setmintocopy()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00318">pcap_setmode()</a>, <a class="el" href="pcap_8c-source.html#l00528">pcap_setnonblock()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="Pcap-win32_8c-source.html#l00060">pcap_stats()</a>, <a class="el" href="Win32-Extensions_8c-source.html#l00051">pcap_stats_ex()</a>, <a class="el" href="pcap_8c-source.html#l00617">pcap_strerror()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l02043">rpcap_checkver()</a>, <a class="el" href="pcap-remote_8c-source.html#l00133">rpcap_deseraddr()</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="savefile_8c-source.html#l00517">sf_next_packet()</a>, <a class="el" href="sockutils_8c-source.html#l00524">sock_bufferize()</a>, <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00386">sock_validaddr()</a>, and <a class="el" href="win32-svc_8c-source.html#l00070">svc_geterr()</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="sockutils.c::TEMP_BUF_SIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TEMP_BUF_SIZE&nbsp;&nbsp;&nbsp;65536
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a0" doxytag="sockutils.c::WINSOCK_MAJOR_VERSION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define WINSOCK_MAJOR_VERSION&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ask for Winsock 2.2 
<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00056">56</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="sockutils.c::WINSOCK_MINOR_VERSION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define WINSOCK_MINOR_VERSION&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ask for Winsock 2.2 
<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00057">57</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a15" doxytag="sockutils.c::sock_bufferize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_bufferize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tempbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>totsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>checkonly</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It copies the amount of data contained into 'buffer' into 'tempbuf'. and it checks for buffer overflows.
<p>
This function basically copies 'size' bytes of data contained into 'buffer' into 'tempbuf', starting at offset 'offset'. Before that, it checks that the resulting buffer will not be larger than 'totsize'. Finally, it updates the 'offset' variable in order to point to the first empty location of the buffer.<p>
In case the function is called with 'checkonly' equal to 1, it does not copy the data into the buffer. It only checks for buffer overflows and it updates the 'offset' variable. This mode can be useful when the buffer already contains the data (maybe because the producer writes directly into the target buffer), so only the buffer overflow check has to be made. In this case, both 'buffer' and 'tempbuf' can be NULL values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer that keeps the data that has to be copied.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be copied.</td></tr>
    <tr><td valign=top><em>tempbuf:</em>&nbsp;</td><td>user-allocated buffer (of size 'totsize') in which data has to be copied.</td></tr>
    <tr><td valign=top><em>offset:</em>&nbsp;</td><td>an index into 'tempbuf' which keeps the location of its first empty location.</td></tr>
    <tr><td valign=top><em>totsize:</em>&nbsp;</td><td>total size of the buffer in which data is being copied.</td></tr>
    <tr><td valign=top><em>checkonly:</em>&nbsp;</td><td>'1' if we do not want to copy data into the buffer and we want just do a buffer ovreflow control, '0' if data has to be copied as well.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. When the function returns, 'tempbuf' will have the new string appended, and 'offset' will keep the length of that buffer. In case of 'checkonly == 1', data is not copied, but 'offset' is updated in any case.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>This function assumes that the buffer in which data has to be stored is large 'totbuf' bytes.<p>
In case of 'checkonly', be carefully to call this function *before* copying the data into the buffer. Otherwise, the control about the buffer overflow is useless. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00524">524</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l01713">offset</a>, <a class="el" href="gencode_8c-source.html#l04255">size</a>, and <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01104">pcap_pack_bpffilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="sockutils.c::sock_check_hostlist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_check_hostlist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sep</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>from</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.
<p>
This function is useful after an accept() call in order to check if the connecting host is allowed to connect to me. To do that, we have a buffer that keeps the list of the allowed host; this function checks the sockaddr_storage structure of the connecting host against this host list, and it returns '0' is the host is included in this list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>hostlist:</em>&nbsp;</td><td>a string that contains the list of the allowed host.</td></tr>
    <tr><td valign=top><em>sep:</em>&nbsp;</td><td>a string that keeps the separators used between the hosts (for example the space character) in the host list.</td></tr>
    <tr><td valign=top><em>from:</em>&nbsp;</td><td>a sockaddr_storage structure, as it is returned by the accept() call.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00726">726</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="fileconf_8c-source.html#l00044">hostlist</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, <a class="el" href="sockutils_8c-source.html#l00823">sock_cmpaddr()</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="sockutils.c::sock_cleanup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sock_cleanup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It deallocates sockets.
<p>
This function is pretty useless on UNIX, since socket deallocation is not required. However it is required on Win32. In UNIX, this function appears to be completely empty.<p>
<dl compact><dt><b>Returns:</b></dt><dd>No error values. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00192">192</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00058">sockcount</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00409">main_cleanup()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-new_8c-source.html#l01249">pcap_remoteact_cleanup()</a>, and <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="sockutils.c::sock_close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes the present (TCP and UDP) socket connection.
<p>
This function sends a shutdown() on the socket in order to disable send() calls (while recv() ones are still allowed). Then, it closes the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the socket identifier of the connection that has to be closed.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00334">334</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>
<a name="a20" doxytag="sockutils.c::sock_cmpaddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_cmpaddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct sockaddr_storage *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compares two addresses contained into two sockaddr_storage structures.
<p>
This function is useful to compare two addresses, given their internal representation, i.e. an sockaddr_storage structure.<p>
The two structures do not need to be sockaddr_storage; you can have both 'sockaddr_in' and sockaddr_in6, properly acsted in order to be compliant to the function interface.<p>
This function will return '0' if the two addresses matches, '-1' if not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>first:</em>&nbsp;</td><td>a sockaddr_storage structure, (for example the one that is returned by an accept() call), containing the first address to compare.</td></tr>
    <tr><td valign=top><em>second:</em>&nbsp;</td><td>a sockaddr_storage structure containing the second address to compare.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if the addresses are equal, '-1' if they are different. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00823">823</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l02086">rpcap_remoteact_getsock()</a>, and <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="sockutils.c::sock_discard"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_discard </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It discards N bytes that are currently waiting to be read on the current socket.
<p>
This function is useful in case we receive a message we cannot undestand (e.g. wrong version number when receiving a network packet), so that we have to discard all data before reading a new message.<p>
This function will read 'size' bytes from the socket and discard them. It defines an internal buffer in which data will be copied; however, in case this buffer is not large enough, it will cycle in order to read everything as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be discarded.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00672">672</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, and <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l02043">rpcap_checkver()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, and <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="sockutils.c::sock_geterror"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sock_geterror </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>caller</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It retrieves the error message after an error occurred in the socket interface.
<p>
This function is defined because of the different way errors are returned in UNIX and Win32. This function provides a consistent way to retrieve the error message (after a socket error occurred) on all the platforms.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>caller:</em>&nbsp;</td><td>a pointer to a user-allocated string which contains a message that has to be printed *before* the true error message. It could be, for example, 'this error comes from the recv() call at line 31'.</td></tr>
    <tr><td valign=top><em>string:</em>&nbsp;</td><td>a pointer to an user-allocated buffer that will contain the complete error message. This buffer has to be at least 'size' in length.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>the size of the buffer in which the error message will be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>No return values. The error message is returned in the 'string' parameter. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00116">116</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8h-source.html#l00136">SOCK_ERRBUF_SIZE</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, <a class="el" href="pcap-new_8c-source.html#l01285">pcap_remoteact_list()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>, <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>, <a class="el" href="sockutils_8c-source.html#l00726">sock_check_hostlist()</a>, <a class="el" href="sockutils_8c-source.html#l00334">sock_close()</a>, <a class="el" href="sockutils_8c-source.html#l00254">sock_open()</a>, <a class="el" href="sockutils_8c-source.html#l00566">sock_recv()</a>, <a class="el" href="sockutils_8c-source.html#l00635">sock_recv_dgram()</a>, and <a class="el" href="sockutils_8c-source.html#l00443">sock_send()</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="sockutils.c::sock_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>errbuf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It initializes sockets.
<p>
This function is pretty useless on UNIX, since socket initialization is not required. However it is required on Win32. In UNIX, this function appears to be completely empty.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00160">160</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8c-source.html#l00058">sockcount</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00119">main()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, and <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="sockutils.c::sock_open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct addrinfo *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>addrinfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>nconn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It initializes a network connection both from the client and the server side.
<p>
In case of a client socket, this function calls socket() and connect(). In the meanwhile, it checks for any socket error. If an error occurs, it writes the error message into 'errbuf'.<p>
In case of a server socket, the function calls socket(), bind() and listen().<p>
In no cases this fucntion will authenticate the user on the remote host. This function has to be done in the <a class="el" href="group__remote__pri__func.html#a29">rpcap_sendauth()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>addrinfo:</em>&nbsp;</td><td>pointer to an addrinfo variable which will be used to open the socket and such. This variable is the one returned by the previous call to sockvalidateaddr().</td></tr>
    <tr><td valign=top><em>server:</em>&nbsp;</td><td>'1' if this is a server socket, '0' otherwise.</td></tr>
    <tr><td valign=top><em>nconn:</em>&nbsp;</td><td>number of the connections that are allowed to wait into the listen() call. This value has no meanings in case of a client socket.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the socket that has been opened (that has to be used in the following sockets calls) if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00254">254</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>, and <a class="el" href="sockutils_8h-source.html#l00063">SOCKET</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="sockutils.c::sock_recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It waits on a connected socket and it manages to receive exactly 'size' bytes.
<p>
This function basically calls the recv() socket function and it checks that no error occurred. If that happens, it writes the error message into 'errbuf'. In case the socket does not have enough data available, it cycles on the recv() util the requested data (of size 'size') is arrived.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data has to be stored</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>size of the allocated buffer. WARNING: this indicates the number of bytes that we are expecting to be read. This function (differenctly from the rpcap_recv_dgram() ) block until the number of bytes read is equal to 'size'.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00566">566</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, <a class="el" href="sockutils_8h-source.html#l00117">SOCK_ASSERT</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00104">daemon_serviceloop()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01147">daemon_unpackapplyfilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01945">rpcap_checkmsg()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01298">rpcap_thrdatamain_stream()</a>, and <a class="el" href="sockutils_8c-source.html#l00672">sock_discard()</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="sockutils.c::sock_recv_dgram"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_recv_dgram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sock</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It waits on a connected socket and it manages to receive one message.
<p>
There is a difference here between this function and the <a class="el" href="sockutils_8c.html#a16">sock_recv()</a>: the previous one will loop until 'size' bytes are read (i.e. until a message with the expected size has arrived); here just one recv() is done, and all what is waiting in the socket bufer is read all at once.<p>
This function is required for UDP sockets, in which the message has to be read all at once, otherwise it is discarded. Therefore we have to call this function with a large buffer, in order to be sure no data is lost. It follow that the number of bytes received is usually less than the size buffer: therefore we must exit anyway, even if the number of bytes read is less than the size of the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sock:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data has to be stored.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>size of the allocated buffer. WARNING: this indicates the maximum number of bytes that we can read. This function (differenctly from the rpcap_recv_dgram() ) does not block if the number of bytes read is equal to 'size'.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one), due to a network problem.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00635">635</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="pcap-remote_8c-source.html#l01514">rpcap_thrdatamain_dgram()</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="sockutils.c::sock_send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SOCKET&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>socket</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It sends the amount of data contained into 'buffer' on the given socket.
<p>
This function basically calls the send() socket function and it checks that all the data specified in 'buffer' (of size 'size') will be sent. If an error occurs, it writes the error message into 'errbuf'. In case the socket buffer does not have enough space, it loops until all data has been sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>socket:</em>&nbsp;</td><td>the connected socket currently opened.</td></tr>
    <tr><td valign=top><em>buffer:</em>&nbsp;</td><td>a char pointer to a user-allocated buffer in which data is contained.</td></tr>
    <tr><td valign=top><em>size:</em>&nbsp;</td><td>number of bytes that have to be sent.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00443">443</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="gencode_8c-source.html#l04255">size</a>, and <a class="el" href="sockutils_8c-source.html#l00116">sock_geterror()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00444">daemon_checkauth()</a>, <a class="el" href="daemon_8c-source.html#l01116">daemon_endcapture()</a>, <a class="el" href="daemon_8c-source.html#l00692">daemon_findalldevs()</a>, <a class="el" href="daemon_8c-source.html#l01248">daemon_getstats()</a>, <a class="el" href="daemon_8c-source.html#l01287">daemon_getstatsnopcap()</a>, <a class="el" href="daemon_8c-source.html#l00820">daemon_opensource()</a>, <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="daemon_8c-source.html#l01323">daemon_thrdatamain()</a>, <a class="el" href="daemon_8c-source.html#l01210">daemon_updatefilter()</a>, <a class="el" href="pcap-remote_8c-source.html#l00300">pcap_close_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l01153">pcap_remoteact_close()</a>, <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01161">pcap_updatefilter_remote()</a>, <a class="el" href="pcap-remote_8c-source.html#l01752">rpcap_sendauth()</a>, <a class="el" href="pcap-remote_8c-source.html#l01707">rpcap_senderror()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00434">rpcap_stats_remote()</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="sockutils.c::sock_validaddr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sock_validaddr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>address</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>port</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct addrinfo *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>hints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct addrinfo **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>addrinfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks that the address, port and flags given are valids and it returns an 'addrinfo' stucture.
<p>
This function basically calls the getaddrinfo() calls, and it performs a set of sanity checks to control that everything is fine (e.g. a TCP socket cannot have a mcast address, and such). If an error occurs, it writes the error message into 'errbuf'.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>address:</em>&nbsp;</td><td>a pointer to a user-allocated buffer containing the network address to check. It could be both a numeric - literal address, and it can be NULL or "" (useful in case of a server socket which has to bind to all addresses).</td></tr>
    <tr><td valign=top><em>port:</em>&nbsp;</td><td>a pointer to a user-allocated buffer containing the network port to use.</td></tr>
    <tr><td valign=top><em>hints:</em>&nbsp;</td><td>an addrinfo variable (passed by reference) containing the flags needed to create the addrinfo structure appropriately.</td></tr>
    <tr><td valign=top><em>addrinfo:</em>&nbsp;</td><td>it represents the true returning value. This is a pointer to an addrinfo variable (passed by reference), which will be allocated by this function and returned back to the caller. This variable will be used in the next sockets calls.</td></tr>
    <tr><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size SOCK_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned in the 'errbuf' variable. The addrinfo variable that has to be used in the following sockets calls is returned into the addrinfo parameter.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>The 'addrinfo' variable has to be deleted by the programmer by calling freeaddrinfo() when it is no longer needed.<p>
SOCKET: I should check all the accept() in order to bind to all addresses (in case addrinfo has more han one pointers, and all connect() to use all addresses (in the case the firs one fails) </dd></dl>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00386">386</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
References <a class="el" href="sockutils_8c-source.html#l00064">snprintf</a>, and <a class="el" href="sockutils_8c-source.html#l00208">sock_ismcastaddr()</a>.
<p>
Referenced by <a class="el" href="daemon_8c-source.html#l00903">daemon_startcapture()</a>, <a class="el" href="rpcapd_8c-source.html#l00596">main_active()</a>, <a class="el" href="rpcapd_8c-source.html#l00296">main_startup()</a>, <a class="el" href="pcap-new_8c-source.html#l00150">pcap_findalldevs_ex()</a>, <a class="el" href="pcap-remote_8c-source.html#l00554">pcap_opensource_remote()</a>, <a class="el" href="pcap-new_8c-source.html#l00996">pcap_remoteact_accept()</a>, and <a class="el" href="pcap-remote_8c-source.html#l00761">pcap_startcapture_remote()</a>.    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a6" doxytag="sockutils.c::fakeerrbuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char fakeerrbuf[SOCK_ERRBUF_SIZE + 1]
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00085">85</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="rpcapd_8c-source.html#l00478">main_passive()</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="sockutils.c::sockcount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sockcount = 0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Variable that allows calling the WSAStartup() only one time 
<p>
Definition at line <a class="el" href="sockutils_8c-source.html#l00058">58</a> of file <a class="el" href="sockutils_8c-source.html">sockutils.c</a>.
<p>
Referenced by <a class="el" href="sockutils_8c-source.html#l00192">sock_cleanup()</a>, and <a class="el" href="sockutils_8c-source.html#l00160">sock_init()</a>.    </td>
  </tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
