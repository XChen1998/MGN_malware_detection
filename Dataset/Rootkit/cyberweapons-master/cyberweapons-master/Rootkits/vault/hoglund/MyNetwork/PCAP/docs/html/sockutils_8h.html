<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sockutils.h File Reference</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>sockutils.h File Reference</h1><code>#include &lt;winsock2.h&gt;</code><br>
<code>#include &lt;ws2tcpip.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>

<p>
<a href="sockutils_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__struct.html#a12">SOCKET</a>&nbsp;&nbsp;&nbsp;unsigned int</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>In Win32, sockets use unsigned integers; in UNIX, they use signed integer.</em> <a href="group__remote__struct.html#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(msg, expr)&nbsp;&nbsp;&nbsp;{ fprintf(stderr, "%s\<a class="el" href="gencode_8c.html#a61">n</a>", msg); assert(expr); }</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>DEBUG facility: it prints an error message on the screen (stderr).</em> <a href="group__remote__pri__struct.html#a51"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a52">SOCKBUF_CHECKONLY</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a53">SOCKBUF_BUFFERIZE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a54">SOCKOPEN_CLIENT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a55">SOCKOPEN_SERVER</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__struct.html#a56">SOCK_ERRBUF_SIZE</a>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a0">sock_geterror</a> (const char *caller, char *string, int <a class="el" href="gencode_8c.html#a27">size</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It retrieves the error message after an error occurred in the socket interface.</em> <a href="group__remote__pri__func.html#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a1">sock_init</a> (char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes sockets.</em> <a href="group__remote__pri__func.html#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a2">sock_cleanup</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It deallocates sockets.</em> <a href="group__remote__pri__func.html#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a6">sock_validaddr</a> (const char *<a class="el" href="rpcapd_8c.html#a7">address</a>, const char *<a class="el" href="rpcapd_8c.html#a8">port</a>, struct addrinfo *hints, struct addrinfo **addrinfo, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that the address, port and flags given are valids and it returns an 'addrinfo' stucture.</em> <a href="group__remote__pri__func.html#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a9">sock_recv</a> (SOCKET socket, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive exactly 'size' bytes.</em> <a href="group__remote__pri__func.html#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a10">sock_recv_dgram</a> (SOCKET sock, char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It waits on a connected socket and it manages to receive one message.</em> <a href="group__remote__pri__func.html#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a4">sock_open</a> (struct addrinfo *addrinfo, int server, int nconn, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It initializes a network connection both from the client and the server side.</em> <a href="group__remote__pri__func.html#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a5">sock_close</a> (SOCKET sock, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Closes the present (TCP and UDP) socket connection.</em> <a href="group__remote__pri__func.html#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a7">sock_send</a> (SOCKET socket, const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It sends the amount of data contained into 'buffer' on the given socket.</em> <a href="group__remote__pri__func.html#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a8">sock_bufferize</a> (const char *buffer, int <a class="el" href="gencode_8c.html#a27">size</a>, char *tempbuf, int *<a class="el" href="gencode_8c.html#a30">offset</a>, int totsize, int checkonly, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It copies the amount of data contained into 'buffer' into 'tempbuf'. and it checks for buffer overflows.</em> <a href="group__remote__pri__func.html#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a11">sock_discard</a> (SOCKET socket, int <a class="el" href="gencode_8c.html#a27">size</a>, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>It discards N bytes that are currently waiting to be read on the current socket.</em> <a href="group__remote__pri__func.html#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a12">sock_check_hostlist</a> (char *<a class="el" href="rpcapd_8c.html#a0">hostlist</a>, const char *sep, struct sockaddr_storage *from, char *<a class="el" href="inet_8c.html#a5">errbuf</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.</em> <a href="group__remote__pri__func.html#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__remote__pri__func.html#a13">sock_cmpaddr</a> (struct sockaddr_storage *first, struct sockaddr_storage *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compares two addresses contained into two sockaddr_storage structures.</em> <a href="group__remote__pri__func.html#a13"></a><em></em></font><br><br></td></tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
