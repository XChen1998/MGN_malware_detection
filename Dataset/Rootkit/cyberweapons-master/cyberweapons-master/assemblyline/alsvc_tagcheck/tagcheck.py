""" TagCheck Signature Service
See README.md for details about this service.
"""

from assemblyline.al.common import forge
from assemblyline.common.charset import safe_str
from assemblyline.common.importing import module_attribute_by_name
from assemblyline.al.service.base import ServiceBase
from assemblyline.al.common.result import Result, ResultSection, SCORE, TAG_TYPE, TAG_WEIGHT

import re


class TagCheck(ServiceBase):
    SERVICE_CATEGORY = 'Static Analysis'
    SERVICE_ACCEPTS = '.*'
    SERVICE_DESCRIPTION = "A post-service that compares all TAGs generated by a AL to a signature set"
    SERVICE_REVISION = ServiceBase.parse_revision('$Id$')
    SERVICE_VERSION = '1'
    SERVICE_ENABLED = True
    SERVICE_STAGE = 'POST'
    SERVICE_CPU_CORES = 0.25
    SERVICE_RAM_MB = 256

    def __init__(self, cfg=None):
        super(TagCheck, self).__init__(cfg)
        ds = forge.get_datastore()
        self.signatures = ds.get_blob('tagcheck_signatures')
        self.callbacks = {}

    # Ensure re-scan if services selected are different from cached result.
    def get_config_data(self, task):
        config_data = super(TagCheck, self).get_config_data(task)
        config_data["__SERVICE_LIST__"] = [x.split(".", 1)[0] for x in task.results if not x.endswith(".e")]
        return config_data

    def start(self):
        self.log.debug("TagCheck signature service started")

    def callback(self, cb, request, result, sig_classification, args):
        if cb not in self.callbacks:
            self.callbacks[cb] = module_attribute_by_name(cb)
        if len(args) > 0:
            return self.callbacks[cb](request, result, sig_classification, args)
        else:
            return self.callbacks[cb](request, result, sig_classification)

    def execute(self, request):

        # If no signatures, exit.
        if not self.signatures:
            request.result = Result()
            return
        else:

            # Generate section in results set
            result = Result()

            # Set up values and get list of result tags
            tag_match = False
            result_tags = request.get_tags()

            if result_tags:
                for signature_name, sig in self.signatures.iteritems():
                    sig_classification = sig.get('classification', None) or self.SERVICE_CLASSIFICATION
                    if sig_classification == 'None':
                        sig_classification = self.SERVICE_CLASSIFICATION
                    # sig_status = sig['status'] -- Not currently used
                    if re.match('^(INFO|LOW|MED|HIGH|VHIGH|SURE|NULL|OK|NOT)$', sig['score']):
                        sig_score = sig['score']
                    elif re.match('^[0-9]+$', sig['score']):
                        sig_score = int(sig['score'])
                    else:
                        sig_score = 'NULL'
                    sig_threatactor = sig['threat_actor']
                    sig_implantfam = sig['implant_family']
                    sig_comment = sig['comment']
                    sig_values = sig['values']
                    sig_callback = sig['callback']

                    sigs_matched = []
                    tags_matched = []
                    matched_count = 0

                    for s in sig_values:
                        s_matched = 0
                        stag_type = s.split(":", 1)[0]
                        stag_value = s.split(":", 1)[1]
                        for r in result_tags:
                            rtag_type = safe_str(r["type"])
                            rtag_value = safe_str(r["value"])
                            if re.match(stag_type, rtag_type) and re.match(stag_value, rtag_value):
                                sigs_matched.append(s)
                                tags_matched.append(rtag_value)
                                if s_matched == 0:
                                    s_matched += 1
                                    matched_count += 1

                    if len(sig_values) == matched_count:

                        tag_match = True

                        result_details = ResultSection(
                                score=SCORE.NULL,
                                title_text="TagCheck Signature Match for signature [%s]" % signature_name,
                                classification=sig_classification
                            )

                        if type(sig_score) == int:
                            result_details.score = sig_score
                        else:
                            result_details.score = SCORE[sig_score]

                        if sig_comment:
                            result_details.add_line("Signature Info: %s" % sig_comment)

                        result_details.add_line("Tags Matched:")
                        for mtch in tags_matched:
                            result_details.add_line(mtch)

                        result.add_tag(
                            TAG_TYPE['TAGCHECK_RULE'],
                            signature_name,
                            TAG_WEIGHT.NULL,
                            classification=sig_classification
                        )

                        if sig_implantfam != "None":
                            result.add_tag(
                                TAG_TYPE['IMPLANT_NAME'],
                                "%s" % sig_implantfam,
                                TAG_WEIGHT.NULL,
                                usage='IDENTIFICATION',
                                classification=sig_classification
                            )
                        if sig_threatactor != "None":
                            result.add_tag(
                                TAG_TYPE['THREAT_ACTOR'],
                                "%s" % sig_threatactor,
                                TAG_WEIGHT.NULL,
                                usage='IDENTIFICATION',
                                classification=sig_classification
                            )

                        if sig_callback != "None":
                            if ':' in sig_callback:
                                cb = sig_callback.split(':', 1)[0]
                                args = sig_callback.split(':', 1)[1]
                            else:
                                cb = sig_callback
                                args = ""
                            # noinspection PyBroadException
                            try:
                                self.callback(cb, request, result_details, sig_classification, args)
                            except:
                                result_details.add_line('ERROR: Callback "{}" was not found' .format(cb))

                        result.add_section(result_details)

                if not tag_match:
                    result_details = ResultSection(
                        SCORE.NULL,
                        "No tag signature matches detected.",
                        self.SERVICE_CLASSIFICATION
                    )
                    result.add_section(result_details)

            else:
                result_details = ResultSection(
                    SCORE.NULL,
                    "No result tags generated to compare.",
                    self.SERVICE_CLASSIFICATION
                )
                result.add_section(result_details)

            request.result = result

            return
