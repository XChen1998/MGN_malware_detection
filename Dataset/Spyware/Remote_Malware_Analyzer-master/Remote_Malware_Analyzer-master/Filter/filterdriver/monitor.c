#include <stdio.h>
#include "fltdrvKernel.h"

#include "fltdrvCommon.h"
#include "fltInc.h"

#include "sockets.h"
#include "process.h"

// HANDLE handle;
PFLT_FILTER gFilterHandle;
ULONG gTraceFlags = 0;

typedef struct _WORK_QUEUE {
    struct _WORK_QUEUE * Next;
	struct _WORK_QUEUE * Prev;
	char buffer[3000];
} WORK_QUEUE, *PWORK_QUEUE;

WORK_QUEUE * Head;
WORK_QUEUE * End;
BOOLEAN Stop;

PETHREAD Thread;

HANDLE threadHandle;




#pragma prefast(disable:__WARNING_ENCODE_MEMBER_FUNCTION_POINTER, "Not valid for kernel mode drivers")

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, FilterUnload)
#endif

NTSTATUS
DriverEntry (
    __in PDRIVER_OBJECT DriverObject,
    __in PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status,ntStatus;
	UNICODE_STRING file_unicode;
	WCHAR filename[]=L"\\??\\C:\\log.txt";
	OBJECT_ATTRIBUTES obj;
	IO_STATUS_BLOCK iostatus;
	trace = 0;

    UNREFERENCED_PARAMETER( RegistryPath );

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("PassThrough!DriverEntry: Entered\n") );

	RtlInitUnicodeString(&file_unicode,filename);
    status = FltRegisterFilter( DriverObject,
                                &FilterRegistration,
                                &gFilterHandle );

    ASSERT( NT_SUCCESS( status ) );

    if (NT_SUCCESS( status )) {

		ntStatus = sendthenrecv();
		StartWorkQueue();
		
        status = FltStartFiltering( gFilterHandle );

        if (!NT_SUCCESS( status )) {

            FltUnregisterFilter( gFilterHandle );
        }
		PsSetLoadImageNotifyRoutine(CreateRoutine);
		ntStatus = PsSetCreateProcessNotifyRoutine(CreateProcessNotify ,FALSE);
		DbgPrint("%x\n", ntStatus);
		DetectPid();
    }

    return status;
}

NTSTATUS
FilterUnload (
    __in FLT_FILTER_UNLOAD_FLAGS Flags
    )

{
	NTSTATUS  nt;
    UNREFERENCED_PARAMETER( Flags );

   // PAGED_CODE();
	DbgPrint("UNLOAD 1\n");

	PsRemoveLoadImageNotifyRoutine(CreateRoutine);
	nt = PsSetCreateProcessNotifyRoutine(CreateProcessNotify ,TRUE);
		DbgPrint("UNLOAD 2%x\n", nt);
	
    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("PassThrough!PtUnload: Entered\n") );

    FltUnregisterFilter( gFilterHandle );

	Stop = TRUE;
	
	KeWaitForSingleObject(Thread, Executive, KernelMode, FALSE, 0);
	
	ObDereferenceObject(Thread);

	if(sock) disconnectfromserver(sock);
	cleanupwsk(&clireg);

	DbgPrint("UNLOAD 3\n");
    return STATUS_SUCCESS;
}


NTSTATUS AddInQueue(__in char * buf)
{
	NTSTATUS status =  STATUS_SUCCESS;
	WORK_QUEUE * liste_temp = NULL;
	
	if(buf == NULL) return STATUS_UNSUCCESSFUL;

	if(Head == NULL) // premier element a etre insere
	{
		__try{
			
			Head = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
			if(Head ==  NULL) return STATUS_UNSUCCESSFUL;
			End = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
			if(End ==  NULL) return STATUS_UNSUCCESSFUL;
			
			Head->Next =  End;
			Head->Prev =  NULL;
			if(strlen(buf) > sizeof(Head->buffer)) return STATUS_UNSUCCESSFUL;
			RtlZeroMemory(&Head->buffer, sizeof(Head->buffer));
			strcpy(Head->buffer, buf);
			End->Next = NULL;
			End->Prev = Head;
			strcpy(End->buffer, "First one\n");
			return status;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			status=GetExceptionCode();
			DbgPrint("Exception RegNtPreDeleteKey : %x\n", status);
			return status;
		}
	}
	
	if(Head != NULL) // il y a au moins un element dans la liste
	{
		liste_temp = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
		if(liste_temp ==  NULL) return STATUS_UNSUCCESSFUL;
		
		if(strlen(buf) > sizeof(liste_temp->buffer)) return STATUS_UNSUCCESSFUL;
		RtlZeroMemory(&liste_temp->buffer, sizeof(liste_temp->buffer));
		strcpy(liste_temp->buffer, buf);
		liste_temp->Next = Head->Next;
		Head->Prev =liste_temp;
		liste_temp->Prev = NULL;
		
		Head = liste_temp;
		
		if(End ==  NULL) End = liste_temp;
		return status;
	}
	return status;
}

NTSTATUS RemoveQueue()
{
	NTSTATUS status =  STATUS_SUCCESS;

	
	if(End ==  NULL) return STATUS_UNSUCCESSFUL;
	if(End != NULL) // il y a au moins un eleement
	{
		__try{
			if(End->buffer == NULL) return STATUS_UNSUCCESSFUL;
			status = senddata(sock, End->buffer, strlen(End->buffer));
			
			if(End->Prev != NULL)
			{
				End = End->Prev ;
				//ExFreePool(End->Next);
				End->Next = NULL;			
			}
			else 
				End = NULL;
			

			return status;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			status=GetExceptionCode();
			DbgPrint("Exception removequereue : %x\n", status);
			return status;
		}
	}
	return status;
}



VOID WorkerThread (
  __in PVOID Context
    )
{
	NTSTATUS status;
	UNREFERENCED_PARAMETER(Context);
	KeSetPriorityThread(KeGetCurrentThread(), 	15);

	for(;;)
	{
		status = RemoveQueue();
		if(status ==  STATUS_UNSUCCESSFUL && Stop == TRUE)
			break;	
	}
    PsTerminateSystemThread(STATUS_SUCCESS);
}



NTSTATUS StartWorkQueue()
{
    NTSTATUS status;
	PKTHREAD KThread;  
  PAGED_CODE();
    
	Head = NULL;
	End = NULL,
    Stop = FALSE;
    
    status = PsCreateSystemThread(
                &threadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
                WorkerThread, NULL);
	DbgPrint("Status thread : %x \n", status);
	
	
    status = ObReferenceObjectByHandle(
                threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode,
                &Thread, NULL);
 
    ZwClose(threadHandle);
    if(!NT_SUCCESS(status)) {
        return status;
    }

    return status;
}


NTSTATUS
sendthenrecv(void)
{
	NTSTATUS         status;

	WSK_PROVIDER_NPI pronpi;
	SOCKADDR_IN      srvaddr;

	srvaddr.sin_family                 = AF_INET;
	srvaddr.sin_port                   = RtlUshortByteSwap(1338);
	srvaddr.sin_addr.S_un.S_un_b.s_b1  = 192;
	srvaddr.sin_addr.S_un.S_un_b.s_b2  = 168;
	srvaddr.sin_addr.S_un.S_un_b.s_b3  = 99;
	srvaddr.sin_addr.S_un.S_un_b.s_b4  = 70;

	status = initwsk(&clireg, &pronpi);
	if(!NT_SUCCESS(status)){
		DbgPrint("initwsk() failed: 0x%x\n", status);
		return status;
	}

	DbgPrint("Initialized!\n");

	status = connecttoserver(&pronpi, (PSOCKADDR)&srvaddr, &sock);
	if(!NT_SUCCESS(status)){
		cleanupwsk(&clireg);
		DbgPrint("connecttoserver() failed: 0x%x\n", status);
		return status;
	}

	DbgPrint("Connected!\n");
	return STATUS_SUCCESS;
}



/*
FSAutoAttach
# 0.2.1.0
> Exécuté lors de l'apparition d'un nouveau volume.
*/
NTSTATUS FSAttach(PCFLT_RELATED_OBJECTS FltObjects, FLT_INSTANCE_SETUP_FLAGS Flags, DEVICE_TYPE VolumeDeviceType, FLT_FILESYSTEM_TYPE VolumeFilesystemType)
{
	DbgPrint("Attached!\n");
	return STATUS_SUCCESS;
}

/*
FSDetachRequest
# 0.2.1.0
> Exécuté lors d'une demande de détachement de volume.
*/
NTSTATUS FSDetachRequest(PCFLT_RELATED_OBJECTS FltObjects, FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags)
{
	//A priori, seules les requêtes manuelles passent par cette routine.
	DbgPrint("[FSDetachRequest] Refus de détachement du volume.\n");
	return STATUS_FLT_DO_NOT_DETACH;
}

/*
FSPreCallback
# to_do
> Sera exécuté dans le sens software->hardware sur les messages aux IRPs correspondantes.
*/
FLT_PREOP_CALLBACK_STATUS FSPreCallback(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID *CompletionContext)
{
	NTSTATUS rc;
	PFLT_FILE_NAME_INFORMATION name = NULL;
	NTSTATUS rstatus = FLT_PREOP_SUCCESS_NO_CALLBACK;
	BOOLEAN IsDir;
	UNICODE_STRING  log_unicode;
	UNICODE_STRING  log_dir_unicode;
	UNICODE_STRING  log_dir_1_unicode;
	WCHAR Log[]=L"\\Device\\HarddiskVolume2\\log.txt";
	WCHAR Log_dir[]=L"\\Device\\HarddiskVolume2";
	WCHAR Log_dir_1[]=L"\\Device\\HarddiskVolume2\\";
	char buffer[100];
	LARGE_INTEGER time;
	
	if(ExGetPreviousMode() == KernelMode) return rstatus;
	
	RtlZeroMemory(&buffer, sizeof(buffer));

	// return rstatus;
	
	if(FLT_IS_FS_FILTER_OPERATION(Data))
		return rstatus;
	
	
	FltIsDirectory(Data->Iopb->TargetFileObject,FltObjects->Instance,&IsDir);
	if(IsDir)
	{
		return rstatus;
		DbgPrint("Directory TODO\n");
	}
	
	switch(Data->Iopb->MajorFunction)
	{
	// Pas monitore pour le moment
		case IRP_MJ_PNP:
		case IRP_MJ_MDL_READ_COMPLETE:
		case IRP_MJ_MDL_READ:
		case IRP_MJ_PREPARE_MDL_WRITE:
		case IRP_MJ_MDL_WRITE_COMPLETE:
		case IRP_MJ_VOLUME_MOUNT:
		case IRP_MJ_VOLUME_DISMOUNT:
		case IRP_MJ_OPERATION_END:
		case IRP_MJ_QUERY_INFORMATION:

		case IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
		case IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION:
		case IRP_MJ_ACQUIRE_FOR_MOD_WRITE:
		case IRP_MJ_RELEASE_FOR_MOD_WRITE:
		case IRP_MJ_ACQUIRE_FOR_CC_FLUSH:
		case IRP_MJ_RELEASE_FOR_CC_FLUSH:
		case IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE:
		case IRP_MJ_NETWORK_QUERY_OPEN:
		case IRP_MJ_FLUSH_BUFFERS:
		case IRP_MJ_QUERY_VOLUME_INFORMATION:
		case IRP_MJ_SET_VOLUME_INFORMATION:
		case IRP_MJ_DIRECTORY_CONTROL:
		case IRP_MJ_FILE_SYSTEM_CONTROL:
		case IRP_MJ_DEVICE_CONTROL:
		case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		case IRP_MJ_SHUTDOWN:
		case IRP_MJ_LOCK_CONTROL:
		case IRP_MJ_CLEANUP:
		case IRP_MJ_CREATE_MAILSLOT:
		case IRP_MJ_QUERY_SECURITY:
		case IRP_MJ_SET_SECURITY:
		case IRP_MJ_QUERY_QUOTA:
		case IRP_MJ_SET_QUOTA:
			break;
		
		
		case IRP_MJ_CREATE:
		case IRP_MJ_CREATE_NAMED_PIPE:
		case IRP_MJ_CLOSE:
		case IRP_MJ_READ:
		case IRP_MJ_WRITE:
		case IRP_MJ_QUERY_EA:
		case IRP_MJ_SET_EA:
		case IRP_MJ_SET_INFORMATION:
			if(FltObjects->FileObject != NULL )
			{
				rc = FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &name);
				if(rc == STATUS_SUCCESS)
				{	
					// RtlInitUnicodeString(&log_dir_1_unicode , Log_dir_1);
					// if( RtlCompareUnicodeString(&name->Name,&log_dir_1_unicode,TRUE) == 0 ) { DbgPrint("Matchd dir foucn\n"); return rstatus;}
					 
					// RtlInitUnicodeString(&log_dir_unicode , Log_dir);
					// if( RtlCompareUnicodeString(&name->Name,&log_dir_unicode,TRUE) == 0 ) { DbgPrint("Matchd dir foucn\n"); return rstatus;}
					
					// RtlInitUnicodeString(&log_unicode , Log);
					// if( RtlCompareUnicodeString(&name->Name,&log_unicode,TRUE) == 0 ) { DbgPrint("Matchd foucn\n"); return rstatus; }
					
					
					AddInQueue("------- Enter in IRP\n");
					sprintf_s(buffer,sizeof(buffer),"trace=%i , cpu=%i\n",trace++, KeGetCurrentProcessorNumber());
					AddInQueue(buffer);
					KeQuerySystemTime(&time);
					RtlZeroMemory(&buffer, sizeof(buffer));
					sprintf_s(buffer,sizeof(buffer),"timestamp=%I64d\n",time.QuadPart);
					AddInQueue(buffer);
					
					switch(Data->Iopb->MajorFunction)
					{
						case IRP_MJ_CREATE:
							AddInQueue("Access : create\n");
							break;
						case IRP_MJ_CREATE_NAMED_PIPE:
							AddInQueue("Access : create named pipe\n");
							break;
						case IRP_MJ_CLOSE:
							AddInQueue("Access : close\n");
							break;
						case IRP_MJ_READ:
							AddInQueue("Access : read\n");
							break;
						case IRP_MJ_WRITE:
							AddInQueue("Access : write\n");
							break;
						case IRP_MJ_QUERY_EA:
							AddInQueue("Access : query EA\n");
							break;
						case IRP_MJ_SET_EA:
							AddInQueue("Access : set EA\n");
							break;
						case IRP_MJ_SET_INFORMATION:
							 if(Data->Iopb->Parameters.SetFileInformation.FileInformationClass == FileDispositionInformation)
							 {
								 PFILE_DISPOSITION_INFORMATION pFileInfo = (PFILE_DISPOSITION_INFORMATION)Data->Iopb->Parameters.SetFileInformation.InfoBuffer;
								 if(pFileInfo->DeleteFile)
									 AddInQueue("Access : unlink\n");
								else
									AddInQueue("Access : Todo\n");
							 }
							 else
								AddInQueue("Access : Todok\n");
							
							break;
					}
					
					PrintFileName(name);
					if(name != NULL)
						FltReleaseFileNameInformation(name);
					AddInQueue("-------- Exit IRP\n");
				}
			
			}	
			break;
		default:
			DbgPrint("Not implemented %x\n", Data->Iopb->MajorFunction);
	}
	
	
	return rstatus;
}
/*
FSPostCallback
# to_check_and_complete
> Sera exécuté dans le sens hardware->software sur les messages IRP correspondants.
*/
FLT_POSTOP_CALLBACK_STATUS FSPostCallback(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags)
{
	NTSTATUS rstatus = FLT_POSTOP_FINISHED_PROCESSING;

	return rstatus;
}
