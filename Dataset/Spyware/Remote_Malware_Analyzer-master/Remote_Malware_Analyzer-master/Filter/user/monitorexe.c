#include <DriverSpecs.h>
__user_code

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <strsafe.h>
#include <fltUser.h>

#include "fltdrvCommon.h"
HANDLE pipehandle;
HANDLE th_handle;
int exit_th;

void ListenDriver()
{
 char buffer[4000];
	DWORD dw1;
	
	while(TRUE)
	{
		ReadFile(pipehandle, &buffer, sizeof(buffer), &dw1, NULL);
        printf("%s\n", buffer);
		if(exit_th == 1)
        {
            CloseHandle(pipehandle);
            break;
        }
	}
}


#pragma warning(push)
#pragma warning(disable:4706) // assignment within conditional expression

int _cdecl
main(int argc, char *argv[])
{
    HANDLE port = INVALID_HANDLE_VALUE;
	//HANDLE pipehandle;
//	PFILTER_MESSAGE_HEADER message_header;
	Communication comm;
    HRESULT hResult = S_OK;
	DWORD y;
	char buffer[4000];
    DWORD dw1;
	OVERLAPPED *pOver = NULL;
	WCHAR filename[] = L"\\??\\pipe\\framework";

	COMMAND_MESSAGE* ibuf = (COMMAND_MESSAGE*) calloc(1, sizeof(COMMAND_MESSAGE));
	COMMAND_MESSAGE* obuf = (COMMAND_MESSAGE*) calloc(1, sizeof(COMMAND_MESSAGE));
	obuf->Command = COMM_ERROR;
	hResult = FilterConnectCommunicationPort(FS_PORT_NAME, (DWORD) 0, NULL, (WORD) 0, NULL, &port);
	if (IS_ERROR(hResult))
	{
		printf("* Unable to open communication port with FS Filter Driver.%x\n", hResult);
		return EXIT_FAILURE;
	}
	printf("> Connected.\n");

	ibuf->Command = COMM_HELLO;
	ibuf->Data[0] = (int)GetCurrentProcessId(); //On récupère le PID de notre processus.
	hResult = FilterSendMessage(port, ibuf, sizeof(COMMAND_MESSAGE), obuf, sizeof(COMMAND_MESSAGE), &y);
	if (IS_ERROR(hResult))
	{
		printf("* Unexpected answer received.\n");
		CloseHandle(port);
		return EXIT_FAILURE;
	}
	printf("> Filter registered our PID.\n");

	hResult = FilterSendMessage(port, ibuf, sizeof(COMMAND_MESSAGE), obuf, sizeof(COMMAND_MESSAGE), &y);
	pOver = (OVERLAPPED*)calloc(1, sizeof(OVERLAPPED));
	pOver->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	ZeroMemory(buffer, sizeof(buffer));

	th_handle =  CreateThread(0,0,(LPTHREAD_START_ROUTINE) ListenDriver,0,0,&dw1);

	system("pause 1>Nul");
    exit_th = 1;
    TerminateThread(th_handle,0);

    if(pipehandle)
        CloseHandle(pipehandle);
	CloseHandle(port);
	printf("> Exiting...\n");
	return EXIT_SUCCESS;
	
}
