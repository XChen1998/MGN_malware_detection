#include "pigaregmonitor.h"

#define DRIVER_NAME L"pigaregmonitor"

PDEVICE_OBJECT  g_pDeviceObject  = NULL;
PDEVICE_CONTEXT g_pDeviceContext = NULL;
PDEVICE_OBJECT devobj;

typedef struct _WORK_QUEUE {
    struct _WORK_QUEUE * Next;
	struct _WORK_QUEUE * Prev;
	char buffer[1000];
} WORK_QUEUE, *PWORK_QUEUE;

WORK_QUEUE * Head;
WORK_QUEUE * End;
BOOLEAN Stop;

PETHREAD Thread;

HANDLE threadHandle;

NTSTATUS StartWorkQueue();
VOID WorkerThread (  __in PVOID Context);

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,     IN PUNICODE_STRING RegistryPath
    )
{
	NTSTATUS        status;
	PDEVICE_OBJECT         deviceObject        = NULL; 
	NTSTATUS               ntStatus; 
	// UNICODE_STRING  devname = RTL_CONSTANT_STRING(L"\\Device\\pigaregfilter");
	WCHAR                  deviceNameBuffer[]  = L"\\Device\\"DRIVER_NAME; 
	UNICODE_STRING         deviceNameUnicodeString; 
	WCHAR                  deviceLinkBuffer[]  = L"\\DosDevices\\"DRIVER_NAME; 
	UNICODE_STRING         deviceLinkUnicodeString; 

	UNREFERENCED_PARAMETER(RegistryPath);
	
	RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

	//Create and Initialize device object
	ntStatus = IoCreateDevice (DriverObject, 
								sizeof (DEVICE_CONTEXT), 
								&deviceNameUnicodeString, 
								0x6666, 
								0, 
								FALSE, 
								&deviceObject 
								); 
	
	
	if (NT_SUCCESS(ntStatus)) 
	{ 
		RtlInitUnicodeString (&deviceLinkUnicodeString, deviceLinkBuffer);
		ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString, &deviceNameUnicodeString);
		
		// Simplification de la communication entre user-mode et kernel-mode
		if (!NT_SUCCESS(ntStatus)) 
		{
			IoDeleteDevice (deviceObject); 
			DbgPrint("DriverEntry: IoCreationSymbolicLink failed");
			return ntStatus; 
		} 
		
		g_pDeviceObject  = deviceObject;
		g_pDeviceContext = deviceObject->DeviceExtension;

		g_pDeviceContext->pDriverObject = DriverObject;
		g_pDeviceContext->pDeviceObject = deviceObject;
		
		DriverObject->DriverUnload                         = DriverUnload; 
		DriverObject->MajorFunction[IRP_MJ_CREATE]         = DrvCreateClose;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DrvCreateClose;
		DriverObject->MajorFunction[IRP_MJ_WRITE]          = DrvWrite;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDispatch;
		trace=0;
		ntStatus = sendthenrecv();
		StartWorkQueue();
		
		
		if(!NT_SUCCESS(ntStatus))
		{
			IoDeleteSymbolicLink (&deviceLinkUnicodeString);
			IoDeleteDevice (deviceObject); 
			DbgPrint("DriverEntry: Connection failed \n");
			return ntStatus; 
		}
			
		
		ntStatus= CmRegisterCallback(RegistryCallback, g_pDeviceContext, &g_pDeviceContext->RegCookie);
		if(!NT_SUCCESS(ntStatus)) return ntStatus;
		
		
		return STATUS_SUCCESS; 
	} 
	else
	{
		DbgPrint("DriverEntry: IOCreateDevice failed");
		return ntStatus; 
	}

}


VOID WorkerThread (
  __in PVOID Context
    )
{
	NTSTATUS status;
	UNREFERENCED_PARAMETER(Context);
	KeSetPriorityThread(KeGetCurrentThread(), 	1);

	
	for(;;)
	{
		status = RemoveQueue();
		if(status ==  STATUS_UNSUCCESSFUL && Stop == TRUE)
			break;	
	}
    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    WCHAR                  deviceLinkBuffer[]  = L"\\DosDevices\\"DRIVER_NAME;
    UNICODE_STRING         deviceLinkUnicodeString;
   	DbgPrint("Unload driver...\n");
	
	CmUnRegisterCallback(g_pDeviceContext->RegCookie);
	
	Stop = TRUE;
	
	KeWaitForSingleObject(Thread, Executive, KernelMode, FALSE, 0);
	
	 ObDereferenceObject(Thread);
	// if(threadHandle)
		// ZwClose(threadHandle);

	if(sock) disconnectfromserver(sock);
	cleanupwsk(&clireg);
	
	RtlInitUnicodeString (&deviceLinkUnicodeString,deviceLinkBuffer);
	IoDeleteSymbolicLink (&deviceLinkUnicodeString);
	IoDeleteDevice (DriverObject->DeviceObject);
}	

NTSTATUS AddInQueue(__in char * buf)
{
	NTSTATUS status =  STATUS_SUCCESS;
	WORK_QUEUE * liste_temp = NULL;
	
	if(buf == NULL) return STATUS_UNSUCCESSFUL;

	if(Head == NULL) // premier element a etre insere
	{
		__try{
			
			Head = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
			if(Head ==  NULL) return STATUS_UNSUCCESSFUL;
			End = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
			if(End ==  NULL) return STATUS_UNSUCCESSFUL;
			
			Head->Next =  End;
			Head->Prev =  NULL;
			if(strlen(buf) > sizeof(Head->buffer)) return STATUS_UNSUCCESSFUL;
			RtlZeroMemory(&Head->buffer, sizeof(Head->buffer));
			strcpy(Head->buffer, buf);
			End->Next = NULL;
			End->Prev = Head;
			strcpy(End->buffer, "First one\n");
			return status;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			status=GetExceptionCode();
			DbgPrint("Exception RegNtPreDeleteKey : %x\n", status);
			return status;
		}
	}
	
	if(Head != NULL) // il y a au moins un element dans la liste
	{
		liste_temp = (WORK_QUEUE *) ExAllocatePoolWithTag(PagedPool, sizeof(WORK_QUEUE), 0);
		if(liste_temp ==  NULL) return STATUS_UNSUCCESSFUL;
		
		if(strlen(buf) > sizeof(liste_temp->buffer)) return STATUS_UNSUCCESSFUL;
		RtlZeroMemory(&liste_temp->buffer, sizeof(liste_temp->buffer));
		strcpy(liste_temp->buffer, buf);
		liste_temp->Next = Head->Next;
		Head->Prev =liste_temp;
		liste_temp->Prev = NULL;
		
		Head = liste_temp;
		
		if(End ==  NULL) End = liste_temp;
		return status;
	}
	return status;
}

NTSTATUS RemoveQueue()
{
	NTSTATUS status =  STATUS_SUCCESS;
	// WORK_QUEUE * liste_temp = NULL;
	
	if(End ==  NULL) return STATUS_UNSUCCESSFUL;
	if(End != NULL) // il y a au moins un eleement
	{
		__try{
			if(End->buffer == NULL) return STATUS_UNSUCCESSFUL;
			status = senddata(sock, End->buffer, strlen(End->buffer));

			if(End->Prev != NULL)
			{
				End = End->Prev ;
				//ExFreePool(End->Next);
				End->Next = NULL;			
			}
			else 
				End = NULL;
			

			return status;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			status=GetExceptionCode();
			DbgPrint("Exception removequereue : %x\n", status);
			return status;
		}
	}
	return status;
}



NTSTATUS StartWorkQueue()
{
    NTSTATUS status;
    PAGED_CODE();
    
	Head = NULL;
	End = NULL,
    Stop = FALSE;
    
    status = PsCreateSystemThread(
                &threadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
                WorkerThread, NULL);
	DbgPrint("Status thread : %x \n", status);
	
	
    status = ObReferenceObjectByHandle(
                threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode,
                &Thread, NULL);
    
    ZwClose(threadHandle);
    if(!NT_SUCCESS(status)) {
        return status;
    }

    return status;
}


NTSTATUS
sendthenrecv(void)
{
	NTSTATUS         status;

	WSK_PROVIDER_NPI pronpi;
	SOCKADDR_IN      srvaddr;

	srvaddr.sin_family                 = AF_INET;
	srvaddr.sin_port                   = RtlUshortByteSwap(1337);
	srvaddr.sin_addr.S_un.S_un_b.s_b1  = 192;
	srvaddr.sin_addr.S_un.S_un_b.s_b2  = 168;
	srvaddr.sin_addr.S_un.S_un_b.s_b3  = 99;
	srvaddr.sin_addr.S_un.S_un_b.s_b4  = 70;

	status = initwsk(&clireg, &pronpi);
	if(!NT_SUCCESS(status)){
		DbgPrint("initwsk() failed: 0x%x\n", status);
		return status;
	}

	DbgPrint("Initialized!\n");

	status = connecttoserver(&pronpi, (PSOCKADDR)&srvaddr, &sock);
	if(!NT_SUCCESS(status)){
		cleanupwsk(&clireg);
		DbgPrint("connecttoserver() failed: 0x%x\n", status);
		return status;
	}

	DbgPrint("Connected!\n");
	return STATUS_SUCCESS;
}


/**
 * @description : Fonction qui va recuperer les IRP : DeviceIO
 * @param : DeviceObject
 * @param : IRP
 * @return : NTSTATUS
 **/
NTSTATUS DriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
UNREFERENCED_PARAMETER(DeviceObject);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

/**
 * @description : Fonction qui va recuperer les IRP CREATE ET CLOSE
 * @param : DeviceObject
 * @param : IRP
 * @return : NTSTATUS
 **/

NTSTATUS DrvCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status      = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}


NTSTATUS DrvWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
UNREFERENCED_PARAMETER(DeviceObject);	
	Irp->IoStatus.Status      = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}


