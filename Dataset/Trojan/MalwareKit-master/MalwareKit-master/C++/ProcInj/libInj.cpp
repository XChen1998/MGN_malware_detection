#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>

HANDLE GetProcessByName(PCWSTR name);

int main(int argc, char **argv){
  HANDLE hThread;
  HANDLE hProcess;
  char szLibPath[1024];  // The name of our "LibSpy.dll" module
                                 // (including full path!);
  void* pLibRemote;   // The address (in the remote process) where
                        // szLibPath will be copied to;
  DWORD   hLibModule;   // Base address of loaded module (==HMODULE);
  HMODULE hKernel32 = ::GetModuleHandle("Kernel32");

  // PCWSTR notepad = "notepad.exe";
  hProcess = GetProcessByName(L"notepad.exe");

  // sqLibPath = "C:\\Users\\Andrew\\Documents\\TaaSera\\ProcInj";
  strcpy(szLibPath, "C:\\Users\\Andrew\\Documents\\TaaSera\\ProcInj\\libpopup.so");

  // 1. Allocate memory in the remote process for szLibPath
  // 2. Write szLibPath to the allocated memory
  pLibRemote = ::VirtualAllocEx( hProcess, NULL, sizeof(szLibPath),
                                 MEM_COMMIT, PAGE_READWRITE );
     ::WriteProcessMemory( hProcess, pLibRemote, (void*)szLibPath,
                       sizeof(szLibPath), NULL );
                       // Get handle of the loaded module
                     ::GetExitCodeThread( hThread, &hLibModule );

     // Clean up
     ::CloseHandle( hThread );
     ::VirtualFreeEx( hProcess, pLibRemote, sizeof(szLibPath),
     MEM_RELEASE );

     // Unload "LibSpy.dll" from the target process
    // (via CreateRemoteThread & FreeLibrary)
    hThread = ::CreateRemoteThread( hProcess, NULL, 0,
                (LPTHREAD_START_ROUTINE) ::GetProcAddress( hKernel32,
                                           "FreeLibrary" ),
                (void*)hLibModule, 0, NULL );
    ::WaitForSingleObject( hThread, INFINITE );

    // Clean up
    ::CloseHandle( hThread );
    CloseHandle(hProcess);
}

HANDLE GetProcessByName(PCWSTR name)
{
    DWORD pid = 0;

    // Create toolhelp snapshot.
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 process;
    ZeroMemory(&process, sizeof(process));
    process.dwSize = sizeof(process);

    // Walkthrough all processes.
    if (Process32First(snapshot, &process))
    {
        do
        {
            // Compare process.szExeFile based on format of name, i.e., trim file path
            // trim .exe if necessary, etc.
            if (MatchProcessName(process.szExeFile, name))
            {
               pid = process.th32ProcessID;
               break;
            }
        } while (Process32Next(snapshot, &process));
    }

    CloseHandle(snapshot);

    if (pid != 0)
    {
         return OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    }

    // Not found


       return NULL;
}
