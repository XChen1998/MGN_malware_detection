#include "ThreadController.h"
#include <vector>

// Date constructor
ThreadController::ThreadController()
{
	threads = vector<HANDLE>();
	accessMutex = CreateMutex(NULL, true, NULL);
	if (accessMutex == NULL) {
		printf("ThreadController could not create its mutex\n");
	}
	ReleaseMutex(accessMutex);
}

void ThreadController::createThread(LPTHREAD_START_ROUTINE threadFunc, int stackSize)
{
	// wait and lock the access mutex
	WaitForSingleObject(accessMutex, INFINITE);

	DWORD myThreadID;
	HANDLE threadHandle = CreateThread(0, stackSize, threadFunc, NULL, 0, &myThreadID);

	// CreateThread returns null on failure
	if (threadHandle != NULL) {
		threads.push_back(threadHandle);
	}

	// put the main thread to sleep for a second to give the new thread some time to run before checking
	// if it might have quit early 
	Sleep(1000);
	DWORD retVal = 0;
	// check if the thread is active or if it quit early
	GetExitCodeThread(threadHandle, &retVal);
	// our threads will return 1 when they quit early
	if (retVal == -1) {
		CloseHandle(threads.back());
		threads.pop_back();
	}

	ReleaseMutex(accessMutex);
}

void ThreadController::closeAllThreads() 
{
	// wait and lock the access mutex
	WaitForSingleObject(accessMutex, INFINITE);

	while (threads.size() > 0) {
		CloseHandle(threads.back());
		threads.pop_back();
	}

	ReleaseMutex(accessMutex);
}

int ThreadController::getThreadCount()
{
	return threads.size();
}