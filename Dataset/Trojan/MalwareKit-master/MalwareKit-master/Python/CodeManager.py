import os
import subprocess
import datetime

class CodeManager:
    'Class for managing source code'
    souceCodeObj = None
    buildOutputFile = 'build.log'

    def __init__(self, sourceCode):
      self.sourceCodeObj = sourceCode

    # adds header, defition and function call to the source code object
    # feature_obj is an object of the class MalwareFeature
    def add_malware_feature(self, feature_obj):
        for d in feature_obj.get_func_declarations():
            self.sourceCodeObj.add_func_declaration(d)
        for g in feature_obj.get_global_variables():
            self.sourceCodeObj.add_global_variable(g)
        for d in feature_obj.get_func_definitions():
            self.sourceCodeObj.add_func_definition(d)
        for c in feature_obj.get_func_call():
            self.sourceCodeObj.add_line_to_main(c)

    # prints build results to a file specified in the global scope
    # output_filename - the file to open and write the output to
    # buid_cmd - the commmand that was executed
    # build_output - the results of the command
    def log_build_results(self, output_filename, build_cmd, build_output):
        output_log = open(output_filename, 'a')
        output_log.write('--------------------------------------------------\n')
        date = datetime.datetime.now().date()
        time = datetime.datetime.now().time()
        output_log.write('Time: ' + str(date) + ' ' + str(time) + '\n')
        output_log.write("Build Command: " + build_cmd + '\n')
        output_log.write('\nBuild Error:\n' + build_output + '\n')
        output_log.write('--------------------------------------------------\n')
        output_log.close()

    # calls g++ to build the source file into an executable
    # exe_file_name - the name of the executable to be compiled
    # source_file_name - the name of the source code file
    def build_executable(self, exe_file_name, source_file_name):
        # have the sourceCodeObj export the code to a file
        self.sourceCodeObj.export_code(source_file_name)
        # check if the sourceCode File exist first
        if os.path.isfile(source_file_name):
            buildCmd = 'g++ -o' + exe_file_name + ' ' + source_file_name
            proc = subprocess.Popen(buildCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (out, err) = proc.communicate()

            # if there were erros trying to compile, write them to a log file
            if err:
                # print "Build Error: ", err
                print "Build Failed"
                self.log_build_results(self.buildOutputFile, buildCmd, err)
            else:
                print "Build Successful"
        else:
            print "Source code file does not exist"
